{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (interfaces/IERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC20/IERC20.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC5267.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (interfaces/IERC5267.sol)\n\npragma solidity ^0.8.0;\n\ninterface IERC5267 {\n    /**\n     * @dev MAY be emitted to signal that the domain could have changed.\n     */\n    event EIP712DomainChanged();\n\n    /**\n     * @dev returns the fields and values that describe the domain separator used by this contract for EIP-712\n     * signature.\n     */\n    function eip712Domain()\n        external\n        view\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        );\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be _NOT_ENTERED\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == _ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\nimport \"./extensions/IERC20Metadata.sol\";\nimport \"../../utils/Context.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20, IERC20Metadata {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address from, address to, uint256 amount) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(address from, address to, uint256 amount) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n            // Overflow not possible: the sum of all balances is capped by totalSupply, and the sum is preserved by\n            // decrementing then incrementing.\n            _balances[to] += amount;\n        }\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        unchecked {\n            // Overflow not possible: balance + amount is at most totalSupply + amount, which is checked above.\n            _balances[account] += amount;\n        }\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n            // Overflow not possible: amount <= accountBalance <= totalSupply.\n            _totalSupply -= amount;\n        }\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 amount) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(address from, address to, uint256 amount) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n// EIP-2612 is Final as of 2022-11-01. This file is deprecated.\n\nimport \"./ERC20Permit.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n// EIP-2612 is Final as of 2022-11-01. This file is deprecated.\n\nimport \"./IERC20Permit.sol\";\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Permit.sol\";\nimport \"../ERC20.sol\";\nimport \"../../../utils/cryptography/ECDSA.sol\";\nimport \"../../../utils/cryptography/EIP712.sol\";\nimport \"../../../utils/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.3) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(IERC20 token, address spender, uint256 value) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance + value));\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, oldAllowance - value));\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeWithSelector(token.approve.selector, spender, value);\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, 0));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Use a ERC-2612 signature to set the `owner` approval toward `spender` on `token`.\n     * Revert on invalid signature.\n     */\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        require(returndata.length == 0 || abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return\n            success && (returndata.length == 0 || abi.decode(returndata, (bool))) && Address.isContract(address(token));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     *\n     * Furthermore, `isContract` will also return true if the target contract within\n     * the same transaction is already scheduled for destruction by `SELFDESTRUCT`,\n     * which only has an effect at the end of a transaction.\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.0/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and revert (either by bubbling\n     * the revert reason or using the provided one) in case of unsuccessful call or if target was not a contract.\n     *\n     * _Available since v4.8._\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        if (success) {\n            if (returndata.length == 0) {\n                // only check isContract if the call was successful and the return data is empty\n                // otherwise we already know that it was a contract\n                require(isContract(target), \"Address: call to non-contract\");\n            }\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason or using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            _revert(returndata, errorMessage);\n        }\n    }\n\n    function _revert(bytes memory returndata, string memory errorMessage) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert(errorMessage);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary Counters {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV // Deprecated in v4.8\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(bytes32 hash, bytes32 r, bytes32 vs) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32 message) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, \"\\x19Ethereum Signed Message:\\n32\")\n            mstore(0x1c, hash)\n            message := keccak256(0x00, 0x3c)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32 data) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(ptr, \"\\x19\\x01\")\n            mstore(add(ptr, 0x02), domainSeparator)\n            mstore(add(ptr, 0x22), structHash)\n            data := keccak256(ptr, 0x42)\n        }\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Data with intended validator, created from a\n     * `validator` and `data` according to the version 0 of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toDataWithIntendedValidatorHash(address validator, bytes memory data) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x00\", validator, data));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/cryptography/EIP712.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./ECDSA.sol\";\nimport \"../ShortStrings.sol\";\nimport \"../../interfaces/IERC5267.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * NOTE: In the upgradeable version of this contract, the cached values will correspond to the address, and the domain\n * separator of the implementation contract. This will cause the `_domainSeparatorV4` function to always rebuild the\n * separator from the immutable values, which is cheaper than accessing a cached version in cold storage.\n *\n * _Available since v3.4._\n *\n * @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n */\nabstract contract EIP712 is IERC5267 {\n    using ShortStrings for *;\n\n    bytes32 private constant _TYPE_HASH =\n        keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _cachedDomainSeparator;\n    uint256 private immutable _cachedChainId;\n    address private immutable _cachedThis;\n\n    bytes32 private immutable _hashedName;\n    bytes32 private immutable _hashedVersion;\n\n    ShortString private immutable _name;\n    ShortString private immutable _version;\n    string private _nameFallback;\n    string private _versionFallback;\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        _name = name.toShortStringWithFallback(_nameFallback);\n        _version = version.toShortStringWithFallback(_versionFallback);\n        _hashedName = keccak256(bytes(name));\n        _hashedVersion = keccak256(bytes(version));\n\n        _cachedChainId = block.chainid;\n        _cachedDomainSeparator = _buildDomainSeparator();\n        _cachedThis = address(this);\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        if (address(this) == _cachedThis && block.chainid == _cachedChainId) {\n            return _cachedDomainSeparator;\n        } else {\n            return _buildDomainSeparator();\n        }\n    }\n\n    function _buildDomainSeparator() private view returns (bytes32) {\n        return keccak256(abi.encode(_TYPE_HASH, _hashedName, _hashedVersion, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev See {EIP-5267}.\n     *\n     * _Available since v4.9._\n     */\n    function eip712Domain()\n        public\n        view\n        virtual\n        override\n        returns (\n            bytes1 fields,\n            string memory name,\n            string memory version,\n            uint256 chainId,\n            address verifyingContract,\n            bytes32 salt,\n            uint256[] memory extensions\n        )\n    {\n        return (\n            hex\"0f\", // 01111\n            _name.toStringWithFallback(_nameFallback),\n            _version.toStringWithFallback(_versionFallback),\n            block.chainid,\n            address(this),\n            bytes32(0),\n            new uint256[](0)\n        );\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1, \"Math: mulDiv overflow\");\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (rounding == Rounding.Up && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (rounding == Rounding.Up && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (rounding == Rounding.Up && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256, rounded down, of a positive value.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (rounding == Rounding.Up && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SafeCast.sol)\n// This file was procedurally generated from scripts/generate/templates/SafeCast.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCast {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248 downcasted) {\n        downcasted = int248(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 248 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240 downcasted) {\n        downcasted = int240(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 240 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232 downcasted) {\n        downcasted = int232(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 232 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224 downcasted) {\n        downcasted = int224(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 224 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216 downcasted) {\n        downcasted = int216(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 216 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208 downcasted) {\n        downcasted = int208(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 208 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200 downcasted) {\n        downcasted = int200(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 200 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192 downcasted) {\n        downcasted = int192(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 192 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184 downcasted) {\n        downcasted = int184(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 184 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176 downcasted) {\n        downcasted = int176(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 176 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168 downcasted) {\n        downcasted = int168(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 168 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160 downcasted) {\n        downcasted = int160(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 160 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152 downcasted) {\n        downcasted = int152(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 152 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144 downcasted) {\n        downcasted = int144(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 144 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136 downcasted) {\n        downcasted = int136(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 136 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128 downcasted) {\n        downcasted = int128(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 128 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120 downcasted) {\n        downcasted = int120(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 120 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112 downcasted) {\n        downcasted = int112(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 112 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104 downcasted) {\n        downcasted = int104(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 104 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96 downcasted) {\n        downcasted = int96(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 96 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88 downcasted) {\n        downcasted = int88(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 88 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80 downcasted) {\n        downcasted = int80(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 80 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72 downcasted) {\n        downcasted = int72(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 72 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64 downcasted) {\n        downcasted = int64(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 64 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56 downcasted) {\n        downcasted = int56(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 56 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48 downcasted) {\n        downcasted = int48(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 48 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40 downcasted) {\n        downcasted = int40(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 40 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32 downcasted) {\n        downcasted = int32(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 32 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24 downcasted) {\n        downcasted = int24(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 24 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16 downcasted) {\n        downcasted = int16(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 16 bits\");\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8 downcasted) {\n        downcasted = int8(value);\n        require(downcasted == value, \"SafeCast: value doesn't fit in 8 bits\");\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.8.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ShortStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/ShortStrings.sol)\n\npragma solidity ^0.8.8;\n\nimport \"./StorageSlot.sol\";\n\n// | string  | 0xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA   |\n// | length  | 0x                                                              BB |\ntype ShortString is bytes32;\n\n/**\n * @dev This library provides functions to convert short memory strings\n * into a `ShortString` type that can be used as an immutable variable.\n *\n * Strings of arbitrary length can be optimized using this library if\n * they are short enough (up to 31 bytes) by packing them with their\n * length (1 byte) in a single EVM word (32 bytes). Additionally, a\n * fallback mechanism can be used for every other case.\n *\n * Usage example:\n *\n * ```solidity\n * contract Named {\n *     using ShortStrings for *;\n *\n *     ShortString private immutable _name;\n *     string private _nameFallback;\n *\n *     constructor(string memory contractName) {\n *         _name = contractName.toShortStringWithFallback(_nameFallback);\n *     }\n *\n *     function name() external view returns (string memory) {\n *         return _name.toStringWithFallback(_nameFallback);\n *     }\n * }\n * ```\n */\nlibrary ShortStrings {\n    // Used as an identifier for strings longer than 31 bytes.\n    bytes32 private constant _FALLBACK_SENTINEL = 0x00000000000000000000000000000000000000000000000000000000000000FF;\n\n    error StringTooLong(string str);\n    error InvalidShortString();\n\n    /**\n     * @dev Encode a string of at most 31 chars into a `ShortString`.\n     *\n     * This will trigger a `StringTooLong` error is the input string is too long.\n     */\n    function toShortString(string memory str) internal pure returns (ShortString) {\n        bytes memory bstr = bytes(str);\n        if (bstr.length > 31) {\n            revert StringTooLong(str);\n        }\n        return ShortString.wrap(bytes32(uint256(bytes32(bstr)) | bstr.length));\n    }\n\n    /**\n     * @dev Decode a `ShortString` back to a \"normal\" string.\n     */\n    function toString(ShortString sstr) internal pure returns (string memory) {\n        uint256 len = byteLength(sstr);\n        // using `new string(len)` would work locally but is not memory safe.\n        string memory str = new string(32);\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(str, len)\n            mstore(add(str, 0x20), sstr)\n        }\n        return str;\n    }\n\n    /**\n     * @dev Return the length of a `ShortString`.\n     */\n    function byteLength(ShortString sstr) internal pure returns (uint256) {\n        uint256 result = uint256(ShortString.unwrap(sstr)) & 0xFF;\n        if (result > 31) {\n            revert InvalidShortString();\n        }\n        return result;\n    }\n\n    /**\n     * @dev Encode a string into a `ShortString`, or write it to storage if it is too long.\n     */\n    function toShortStringWithFallback(string memory value, string storage store) internal returns (ShortString) {\n        if (bytes(value).length < 32) {\n            return toShortString(value);\n        } else {\n            StorageSlot.getStringSlot(store).value = value;\n            return ShortString.wrap(_FALLBACK_SENTINEL);\n        }\n    }\n\n    /**\n     * @dev Decode a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     */\n    function toStringWithFallback(ShortString value, string storage store) internal pure returns (string memory) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return toString(value);\n        } else {\n            return store;\n        }\n    }\n\n    /**\n     * @dev Return the length of a string that was encoded to `ShortString` or written to storage using {setWithFallback}.\n     *\n     * WARNING: This will return the \"byte length\" of the string. This may not reflect the actual length in terms of\n     * actual characters as the UTF-8 encoding of a single character can span over multiple bytes.\n     */\n    function byteLengthWithFallback(ShortString value, string storage store) internal view returns (uint256) {\n        if (ShortString.unwrap(value) != _FALLBACK_SENTINEL) {\n            return byteLength(value);\n        } else {\n            return bytes(store).length;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/StorageSlot.sol)\n// This file was procedurally generated from scripts/generate/templates/StorageSlot.js.\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```solidity\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, `uint256`._\n * _Available since v4.9 for `string`, `bytes`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    struct StringSlot {\n        string value;\n    }\n\n    struct BytesSlot {\n        bytes value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` with member `value` located at `slot`.\n     */\n    function getStringSlot(bytes32 slot) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `StringSlot` representation of the string storage pointer `store`.\n     */\n    function getStringSlot(string storage store) internal pure returns (StringSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` with member `value` located at `slot`.\n     */\n    function getBytesSlot(bytes32 slot) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BytesSlot` representation of the bytes storage pointer `store`.\n     */\n    function getBytesSlot(bytes storage store) internal pure returns (BytesSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := store.slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.9.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./math/Math.sol\";\nimport \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), _SYMBOLS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toString(int256 value) internal pure returns (string memory) {\n        return string(abi.encodePacked(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value))));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "contracts/core/interfaces/ISmardexFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.8.17;\r\n\r\ninterface ISmardexFactory {\r\n    /**\r\n     * @notice emitted at each SmardexPair created\r\n     * @param token0 address of the token0\r\n     * @param token1 address of the token1\r\n     * @param pair address of the SmardexPair created\r\n     * @param totalPair number of SmardexPair created so far\r\n     */\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256 totalPair);\r\n\r\n    /**\r\n     * @notice emitted at each SmardexPair manually added\r\n     * @param token0 address of the token0\r\n     * @param token1 address of the token1\r\n     * @param pair address of the SmardexPair created\r\n     * @param totalPair number of SmardexPair created so far\r\n     */\r\n    event PairAdded(address indexed token0, address indexed token1, address pair, uint256 totalPair);\r\n\r\n    /**\r\n     * @notice emitted each time feesLP and feesPool are changed\r\n     * @param feesLP new feesLP\r\n     * @param feesPool new feesPool\r\n     */\r\n    event FeesChanged(uint256 indexed feesLP, uint256 indexed feesPool);\r\n\r\n    /**\r\n     * @notice emitted when the feeTo is updated\r\n     * @param previousFeeTo the previous feeTo address\r\n     * @param newFeeTo the new feeTo address\r\n     */\r\n    event FeeToUpdated(address indexed previousFeeTo, address indexed newFeeTo);\r\n\r\n    /**\r\n     * @notice return which address fees will be transferred\r\n     */\r\n    function feeTo() external view returns (address);\r\n\r\n    /**\r\n     * @notice return the address of the pair of 2 tokens\r\n     */\r\n    function getPair(address _tokenA, address _tokenB) external view returns (address pair_);\r\n\r\n    /**\r\n     * @notice return the address of the pair at index\r\n     * @param _index index of the pair\r\n     * @return pair_ address of the pair\r\n     */\r\n    function allPairs(uint256 _index) external view returns (address pair_);\r\n\r\n    /**\r\n     * @notice return the quantity of pairs\r\n     * @return quantity in uint256\r\n     */\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice return numerators of pair fees, denominator is 1_000_000\r\n     * @return feesLP_ numerator of fees sent to LP at pair creation\r\n     * @return feesPool_ numerator of fees sent to Pool at pair creation\r\n     */\r\n    function getDefaultFees() external view returns (uint128 feesLP_, uint128 feesPool_);\r\n\r\n    /**\r\n     * @notice whether whitelist is open\r\n     * @return open_ true if the whitelist is open, false otherwise\r\n     */\r\n    function whitelistOpen() external view returns (bool open_);\r\n\r\n    /**\r\n     * @notice create pair with 2 address\r\n     * @param _tokenA address of tokenA\r\n     * @param _tokenB address of tokenB\r\n     * @return pair_ address of the pair created\r\n     */\r\n    function createPair(address _tokenA, address _tokenB) external returns (address pair_);\r\n\r\n    /**\r\n     * @notice set the address who will receive fees, can only be call by the owner\r\n     * @param _feeTo address to replace\r\n     */\r\n    function setFeeTo(address _feeTo) external;\r\n\r\n    /**\r\n     * @notice set feesLP and feesPool for each new pair (onlyOwner)\r\n     * @notice sum of new feesLp and feesPool must be <= FEES_MAX = 10% FEES_BASE\r\n     * @param _feesLP new numerator of fees sent to LP, must be >= 1\r\n     * @param _feesPool new numerator of fees sent to Pool, could be = 0\r\n     */\r\n    function setFees(uint128 _feesLP, uint128 _feesPool) external;\r\n\r\n    /**\r\n     * @notice disable whitelist (onlyOwner)\r\n     * whitelist cannot be re-opened after that.\r\n     */\r\n    function closeWhitelist() external;\r\n\r\n    /**\r\n     * @notice add a pair manually\r\n     * @param _pair pair address to add (must be an ISmardexPair)\r\n     */\r\n    function addPair(address _pair) external;\r\n}\r\n"
    },
    "contracts/core/interfaces/ISmardexMintCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.8.17;\r\n\r\ninterface ISmardexMintCallback {\r\n    /**\r\n     * @notice callback data for mint\r\n     * @param token0 address of the first token of the pair\r\n     * @param token1 address of the second token of the pair\r\n     * @param amount0 amount of token0 to provide\r\n     * @param amount1 amount of token1 to provide\r\n     * @param payer address of the payer to provide token for the mint\r\n     */\r\n    struct MintCallbackData {\r\n        address token0;\r\n        address token1;\r\n        uint256 amount0;\r\n        uint256 amount1;\r\n        address payer;\r\n    }\r\n\r\n    /**\r\n     * @notice callback to implement when calling SmardexPair.mint\r\n     * @param _data callback data for mint\r\n     */\r\n    function smardexMintCallback(MintCallbackData calldata _data) external;\r\n}\r\n"
    },
    "contracts/core/interfaces/ISmardexOwnableFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.8.17;\r\n\r\nimport \"./ISmardexFactory.sol\";\r\n\r\n/**\r\n * @notice the real interface of SmardexFactory, including owner's functions.\r\n *         Needs to be separate due to a missing IOwner interface of OpenZeppelin\r\n */\r\ninterface ISmardexOwnableFactory is ISmardexFactory {\r\n    /**\r\n     * @notice emitted each ownership transfer\r\n     * @param previousOwner previous owner\r\n     * @param newOwner new owner\r\n     */\r\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\r\n\r\n    /**\r\n     * @dev Returns the address of the current owner.\r\n     * @return address of the owner\r\n     */\r\n    function owner() external view returns (address);\r\n\r\n    /**\r\n     * @dev Leaves the contract without owner. It will not be possible to call\r\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n     *\r\n     * NOTE: Renouncing ownership will leave the contract without an owner,\r\n     * thereby removing any functionality that is only available to the owner.\r\n     */\r\n    function renounceOwnership() external;\r\n\r\n    /**\r\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n     * Can only be called by the current owner.\r\n     * @param _newOwner : address of the new owner\r\n     */\r\n    function transferOwnership(address _newOwner) external;\r\n}\r\n"
    },
    "contracts/core/interfaces/ISmardexPair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity >=0.8.17;\r\n\r\n// interfaces\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\r\n\r\ninterface ISmardexPair is IERC20, IERC20Permit {\r\n    /**\r\n     * @notice swap parameters used by function swap\r\n     * @param amountCalculated return amount from getAmountIn/Out is always positive but to avoid too much cast, is int\r\n     * @param fictiveReserveIn fictive reserve of the in-token of the pair\r\n     * @param fictiveReserveOut fictive reserve of the out-token of the pair\r\n     * @param priceAverageIn in-token ratio component of the price average\r\n     * @param priceAverageOut out-token ratio component of the price average\r\n     * @param token0 address of the token0\r\n     * @param token1 address of the token1\r\n     * @param balanceIn contract balance of the in-token\r\n     * @param balanceOut contract balance of the out-token\r\n     */\r\n    struct SwapParams {\r\n        int256 amountCalculated;\r\n        uint256 fictiveReserveIn;\r\n        uint256 fictiveReserveOut;\r\n        uint256 priceAverageIn;\r\n        uint256 priceAverageOut;\r\n        address token0;\r\n        address token1;\r\n        uint256 balanceIn;\r\n        uint256 balanceOut;\r\n    }\r\n\r\n    /**\r\n     * @notice emitted at each mint\r\n     * @param sender address calling the mint function (usually the Router contract)\r\n     * @param to address that receives the LP-tokens\r\n     * @param amount0 amount of token0 to be added in liquidity\r\n     * @param amount1 amount of token1 to be added in liquidity\r\n     * @dev the amount of LP-token sent can be caught using the transfer event of the pair\r\n     */\r\n    event Mint(address indexed sender, address indexed to, uint256 amount0, uint256 amount1);\r\n\r\n    /**\r\n     * @notice emitted at each burn\r\n     * @param sender address calling the burn function (usually the Router contract)\r\n     * @param to address that receives the tokens\r\n     * @param amount0 amount of token0 to be withdrawn\r\n     * @param amount1 amount of token1 to be withdrawn\r\n     * @dev the amount of LP-token sent can be caught using the transfer event of the pair\r\n     */\r\n    event Burn(address indexed sender, address indexed to, uint256 amount0, uint256 amount1);\r\n\r\n    /**\r\n     * @notice emitted at each swap\r\n     * @param sender address calling the swap function (usually the Router contract)\r\n     * @param to address that receives the out-tokens\r\n     * @param amount0 amount of token0 to be swapped\r\n     * @param amount1 amount of token1 to be swapped\r\n     * @dev one of the 2 amount is always negative, the other one is always positive. The positive one is the one that\r\n     * the user send to the contract, the negative one is the one that the contract send to the user.\r\n     */\r\n    event Swap(address indexed sender, address indexed to, int256 amount0, int256 amount1);\r\n\r\n    /**\r\n     * @notice emitted each time the fictive reserves are changed (mint, burn, swap)\r\n     * @param reserve0 the new reserve of token0\r\n     * @param reserve1 the new reserve of token1\r\n     * @param fictiveReserve0 the new fictive reserve of token0\r\n     * @param fictiveReserve1 the new fictive reserve of token1\r\n     * @param priceAverage0 the new priceAverage of token0\r\n     * @param priceAverage1 the new priceAverage of token1\r\n     */\r\n    event Sync(\r\n        uint256 reserve0,\r\n        uint256 reserve1,\r\n        uint256 fictiveReserve0,\r\n        uint256 fictiveReserve1,\r\n        uint256 priceAverage0,\r\n        uint256 priceAverage1\r\n    );\r\n\r\n    /**\r\n     * @notice emitted each time feesLP and feesPool are changed\r\n     * @param feesLP new feesLP\r\n     * @param feesPool new feesPool\r\n     */\r\n    event FeesChanged(uint256 indexed feesLP, uint256 indexed feesPool);\r\n\r\n    /**\r\n     * @notice get the factory address\r\n     * @return address of the factory\r\n     */\r\n    function factory() external view returns (address);\r\n\r\n    /**\r\n     * @notice get the token0 address\r\n     * @return address of the token0\r\n     */\r\n    function token0() external view returns (address);\r\n\r\n    /**\r\n     * @notice get the token1 address\r\n     * @return address of the token1\r\n     */\r\n    function token1() external view returns (address);\r\n\r\n    /**\r\n     * @notice called once by the factory at time of deployment\r\n     * @param _token0 address of token0\r\n     * @param _token1 address of token1\r\n     * @param _feesLP uint128 feesLP numerator\r\n     * @param _feesPool uint128 feesPool numerator\r\n     */\r\n    function initialize(address _token0, address _token1, uint128 _feesLP, uint128 _feesPool) external;\r\n\r\n    /**\r\n     * @notice return current Reserves of both token in the pair,\r\n     *  corresponding to token balance - pending fees\r\n     * @return reserve0_ current reserve of token0 - pending fee0\r\n     * @return reserve1_ current reserve of token1 - pending fee1\r\n     */\r\n    function getReserves() external view returns (uint256 reserve0_, uint256 reserve1_);\r\n\r\n    /**\r\n     * @notice return current fictive reserves of both token in the pair\r\n     * @return fictiveReserve0_ current fictive reserve of token0\r\n     * @return fictiveReserve1_ current fictive reserve of token1\r\n     */\r\n    function getFictiveReserves() external view returns (uint256 fictiveReserve0_, uint256 fictiveReserve1_);\r\n\r\n    /**\r\n     * @notice return current pending fees of both token in the pair\r\n     * @return fees0_ current pending fees of token0\r\n     * @return fees1_ current pending fees of token1\r\n     */\r\n    function getFeeToAmounts() external view returns (uint256 fees0_, uint256 fees1_);\r\n\r\n    /**\r\n     * @notice return numerators of pair fees, denominator is 1_000_000\r\n     * @return feesLP_ numerator of fees sent to LP\r\n     * @return feesPool_ numerator of fees sent to Pool\r\n     */\r\n    function getPairFees() external view returns (uint128 feesLP_, uint128 feesPool_);\r\n\r\n    /**\r\n     * @notice return last updated price average at timestamp of both token in the pair,\r\n     *  read price0Average/price1Average for current price of token0/token1\r\n     * @return priceAverage0_ current price for token0\r\n     * @return priceAverage1_ current price for token1\r\n     * @return blockTimestampLast_ last block timestamp when price was updated\r\n     */\r\n    function getPriceAverage()\r\n        external\r\n        view\r\n        returns (uint256 priceAverage0_, uint256 priceAverage1_, uint256 blockTimestampLast_);\r\n\r\n    /**\r\n     * @notice return current price average of both token in the pair for provided currentTimeStamp\r\n     *  read price0Average/price1Average for current price of token0/token1\r\n     * @param _fictiveReserveIn,\r\n     * @param _fictiveReserveOut,\r\n     * @param _priceAverageLastTimestamp,\r\n     * @param _priceAverageIn current price for token0\r\n     * @param _priceAverageOut current price for token1\r\n     * @param _currentTimestamp block timestamp to get price\r\n     * @return priceAverageIn_ current price for token0\r\n     * @return priceAverageOut_ current price for token1\r\n     */\r\n    function getUpdatedPriceAverage(\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint256 _priceAverageLastTimestamp,\r\n        uint256 _priceAverageIn,\r\n        uint256 _priceAverageOut,\r\n        uint256 _currentTimestamp\r\n    ) external pure returns (uint256 priceAverageIn_, uint256 priceAverageOut_);\r\n\r\n    /**\r\n     * @notice Mint lp tokens proportionally of added tokens in balance. Should be called from a contract\r\n     * that makes safety checks like the SmardexRouter\r\n     * @param _to address who will receive minted tokens\r\n     * @param _amount0 amount of token0 to provide\r\n     * @param _amount1 amount of token1 to provide\r\n     * @return liquidity_ amount of lp tokens minted and sent to the address defined in parameter\r\n     */\r\n    function mint(\r\n        address _to,\r\n        uint256 _amount0,\r\n        uint256 _amount1,\r\n        address _payer\r\n    ) external returns (uint256 liquidity_);\r\n\r\n    /**\r\n     * @notice Burn lp tokens in the balance of the contract. Sends to the defined address the amount of token0 and\r\n     * token1 proportionally of the amount burned. Should be called from a contract that makes safety checks like the\r\n     * SmardexRouter\r\n     * @param _to address who will receive tokens\r\n     * @return amount0_ amount of token0 sent to the address defined in parameter\r\n     * @return amount1_ amount of token0 sent to the address defined in parameter\r\n     */\r\n    function burn(address _to) external returns (uint256 amount0_, uint256 amount1_);\r\n\r\n    /**\r\n     * @notice Swaps tokens. Sends to the defined address the amount of token0 and token1 defined in parameters.\r\n     * Tokens to trade should be already sent in the contract.\r\n     * Swap function will check if the resulted balance is correct with current reserves and reserves fictive.\r\n     * Should be called from a contract that makes safety checks like the SmardexRouter\r\n     * @param _to address who will receive tokens\r\n     * @param _zeroForOne token0 to token1\r\n     * @param _amountSpecified amount of token wanted\r\n     * @param _data used for flash swap, data.length must be 0 for regular swap\r\n     */\r\n    function swap(\r\n        address _to,\r\n        bool _zeroForOne,\r\n        int256 _amountSpecified,\r\n        bytes calldata _data\r\n    ) external returns (int256 amount0_, int256 amount1_);\r\n\r\n    /**\r\n     * @notice set feesLP and feesPool of the pair\r\n     * @notice sum of new feesLp and feesPool must be <= 100_000\r\n     * @param _feesLP new numerator of fees sent to LP, must be >= 1\r\n     * @param _feesPool new numerator of fees sent to Pool, could be = 0\r\n     */\r\n    function setFees(uint128 _feesLP, uint128 _feesPool) external;\r\n\r\n    /**\r\n     * @notice withdraw all reserve on the pair in case no liquidity has never been provided\r\n     * @param _to address who will receive tokens\r\n     */\r\n    function skim(address _to) external;\r\n}\r\n"
    },
    "contracts/core/interfaces/ISmardexSwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.8.17;\r\n\r\ninterface ISmardexSwapCallback {\r\n    /**\r\n     * @notice callback data for swap from SmardexRouter\r\n     * @param path path of the swap, array of token addresses tightly packed\r\n     * @param payer address of the payer for the swap\r\n     */\r\n    struct SwapCallbackData {\r\n        bytes path;\r\n        address payer;\r\n    }\r\n\r\n    /**\r\n     * @notice callback data for swap\r\n     * @param _amount0Delta amount of token0 for the swap (negative is incoming, positive is required to pay to pair)\r\n     * @param _amount1Delta amount of token1 for the swap (negative is incoming, positive is required to pay to pair)\r\n     * @param _data for Router path and payer for the swap (see router for details)\r\n     */\r\n    function smardexSwapCallback(int256 _amount0Delta, int256 _amount1Delta, bytes calldata _data) external;\r\n}\r\n"
    },
    "contracts/core/libraries/SmardexLibrary.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity =0.8.17;\r\n\r\n// libraries\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\n\r\n// interfaces\r\nimport \"../interfaces/ISmardexPair.sol\";\r\n\r\nlibrary SmardexLibrary {\r\n    /// @notice base of the FEES\r\n    uint256 public constant FEES_BASE = 1_000_000;\r\n\r\n    /// @notice max fees of feesLP and feesPool sum, 10% FEES_BASE\r\n    uint256 public constant FEES_MAX = FEES_BASE / 10;\r\n\r\n    /// @notice precision for approxEq, not in percent but in APPROX_PRECISION_BASE\r\n    uint256 public constant APPROX_PRECISION = 1;\r\n\r\n    /// @notice base of the APPROX_PRECISION\r\n    uint256 public constant APPROX_PRECISION_BASE = 1_000_000;\r\n\r\n    /// @notice number of seconds to reset priceAverage\r\n    uint256 private constant MAX_BLOCK_DIFF_SECONDS = 300;\r\n\r\n    /// @notice parameters of getAmountIn and getAmountOut\r\n    struct GetAmountParameters {\r\n        uint256 amount;\r\n        uint256 reserveIn;\r\n        uint256 reserveOut;\r\n        uint256 fictiveReserveIn;\r\n        uint256 fictiveReserveOut;\r\n        uint256 priceAverageIn;\r\n        uint256 priceAverageOut;\r\n        uint128 feesLP;\r\n        uint128 feesPool;\r\n    }\r\n\r\n    /**\r\n     * @notice check if 2 numbers are approximately equal, using APPROX_PRECISION\r\n     * @param _x number to compare\r\n     * @param _y number to compare\r\n     * @return true if numbers are approximately equal, false otherwise\r\n     */\r\n    function approxEq(uint256 _x, uint256 _y) internal pure returns (bool) {\r\n        if (_x == _y) {\r\n            return true;\r\n        } else if (_x > _y) {\r\n            return _x < (_y + (_y * APPROX_PRECISION) / APPROX_PRECISION_BASE);\r\n        } else {\r\n            return _y < (_x + (_x * APPROX_PRECISION) / APPROX_PRECISION_BASE);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice check if 2 ratio are approximately equal: _xNum _/ xDen ~= _yNum / _yDen\r\n     * @param _xNum numerator of the first ratio to compare\r\n     * @param _xDen denominator of the first ratio to compare\r\n     * @param _yNum numerator of the second ratio to compare\r\n     * @param _yDen denominator of the second ratio to compare\r\n     * @return true if ratio are approximately equal, false otherwise\r\n     */\r\n    function ratioApproxEq(uint256 _xNum, uint256 _xDen, uint256 _yNum, uint256 _yDen) internal pure returns (bool) {\r\n        return approxEq(_xNum * _yDen, _xDen * _yNum);\r\n    }\r\n\r\n    /**\r\n     * @notice update priceAverage given old timestamp, new timestamp and prices\r\n     * @param _fictiveReserveIn ratio component of the new price of the in-token\r\n     * @param _fictiveReserveOut ratio component of the new price of the out-token\r\n     * @param _priceAverageLastTimestamp timestamp of the last priceAverage update (0, if never updated)\r\n     * @param _priceAverageIn ratio component of the last priceAverage of the in-token\r\n     * @param _priceAverageOut ratio component of the last priceAverage of the out-token\r\n     * @param _currentTimestamp timestamp of the priceAverage to update\r\n     * @return newPriceAverageIn_ ratio component of the updated priceAverage of the in-token\r\n     * @return newPriceAverageOut_ ratio component of the updated priceAverage of the out-token\r\n     */\r\n    function getUpdatedPriceAverage(\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint256 _priceAverageLastTimestamp,\r\n        uint256 _priceAverageIn,\r\n        uint256 _priceAverageOut,\r\n        uint256 _currentTimestamp\r\n    ) internal pure returns (uint256 newPriceAverageIn_, uint256 newPriceAverageOut_) {\r\n        require(_currentTimestamp >= _priceAverageLastTimestamp, \"SmardexPair: INVALID_TIMESTAMP\");\r\n\r\n        // very first time\r\n        if (_priceAverageLastTimestamp == 0) {\r\n            newPriceAverageIn_ = _fictiveReserveIn;\r\n            newPriceAverageOut_ = _fictiveReserveOut;\r\n        }\r\n        // another tx has been done in the same timestamp\r\n        else if (_priceAverageLastTimestamp == _currentTimestamp) {\r\n            newPriceAverageIn_ = _priceAverageIn;\r\n            newPriceAverageOut_ = _priceAverageOut;\r\n        }\r\n        // need to compute new linear-average price\r\n        else {\r\n            // compute new price:\r\n            uint256 _timeDiff = Math.min(_currentTimestamp - _priceAverageLastTimestamp, MAX_BLOCK_DIFF_SECONDS);\r\n\r\n            newPriceAverageIn_ = _fictiveReserveIn;\r\n            newPriceAverageOut_ =\r\n                (((MAX_BLOCK_DIFF_SECONDS - _timeDiff) * _priceAverageOut * newPriceAverageIn_) /\r\n                    _priceAverageIn +\r\n                    _timeDiff *\r\n                    _fictiveReserveOut) /\r\n                MAX_BLOCK_DIFF_SECONDS;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice compute the firstTradeAmountIn so that the price reach the price Average\r\n     * @param _param contain all params required from struct GetAmountParameters\r\n     * @return firstAmountIn_ the first amount of in-token\r\n     *\r\n     * @dev if the trade is going in the direction that the price will never reach the priceAverage, or if _amountIn\r\n     * is not big enough to reach the priceAverage or if the price is already equal to the priceAverage, then\r\n     * firstAmountIn_ will be set to _amountIn\r\n     */\r\n    function computeFirstTradeQtyIn(GetAmountParameters memory _param) internal pure returns (uint256 firstAmountIn_) {\r\n        // default value\r\n        firstAmountIn_ = _param.amount;\r\n\r\n        // if trade is in the good direction\r\n        if (_param.fictiveReserveOut * _param.priceAverageIn > _param.fictiveReserveIn * _param.priceAverageOut) {\r\n            // pre-compute all operands\r\n            uint256 _toSub = _param.fictiveReserveIn * ((FEES_BASE * 2) - (_param.feesPool * 2) - _param.feesLP);\r\n            uint256 _toDiv = (FEES_BASE - _param.feesPool) * 2;\r\n            uint256 _inSqrt = (((_param.fictiveReserveIn * _param.fictiveReserveOut) * 4) / _param.priceAverageOut) *\r\n                _param.priceAverageIn *\r\n                ((FEES_BASE - _param.feesPool - _param.feesLP) * (FEES_BASE - _param.feesPool)) +\r\n                ((_param.fictiveReserveIn * _param.fictiveReserveIn) * (_param.feesLP * _param.feesLP));\r\n\r\n            // reverse sqrt check to only compute sqrt if really needed\r\n            uint256 _inSqrtCompare = _toSub + _param.amount * _toDiv;\r\n            if (_inSqrt < _inSqrtCompare * _inSqrtCompare) {\r\n                firstAmountIn_ = (Math.sqrt(_inSqrt) - _toSub) / _toDiv;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice compute the firstTradeAmountOut so that the price reach the price Average\r\n     * @param _param contain all params required from struct GetAmountParameters\r\n     * @return firstAmountOut_ the first amount of out-token\r\n     *\r\n     * @dev if the trade is going in the direction that the price will never reach the priceAverage, or if _amountOut\r\n     * is not big enough to reach the priceAverage or if the price is already equal to the priceAverage, then\r\n     * firstAmountOut_ will be set to _amountOut\r\n     */\r\n    function computeFirstTradeQtyOut(\r\n        GetAmountParameters memory _param\r\n    ) internal pure returns (uint256 firstAmountOut_) {\r\n        // default value\r\n        firstAmountOut_ = _param.amount;\r\n        uint256 _reverseFeesTotal = FEES_BASE - _param.feesPool - _param.feesLP;\r\n        // if trade is in the good direction\r\n        if (_param.fictiveReserveOut * _param.priceAverageIn > _param.fictiveReserveIn * _param.priceAverageOut) {\r\n            // pre-compute all operands\r\n            uint256 _fictiveReserveOutPredFees = (_param.fictiveReserveIn * _param.feesLP * _param.priceAverageOut) /\r\n                _param.priceAverageIn;\r\n            uint256 _toAdd = ((_param.fictiveReserveOut * _reverseFeesTotal) * 2) + _fictiveReserveOutPredFees;\r\n            uint256 _toDiv = _reverseFeesTotal * 2;\r\n\r\n            uint256 _inSqrt = (((_param.fictiveReserveOut * _fictiveReserveOutPredFees) * 4) *\r\n                (_reverseFeesTotal * (FEES_BASE - _param.feesPool))) /\r\n                _param.feesLP +\r\n                (_fictiveReserveOutPredFees * _fictiveReserveOutPredFees);\r\n\r\n            // reverse sqrt check to only compute sqrt if really needed\r\n            uint256 _inSqrtCompare = _toAdd - _param.amount * _toDiv;\r\n            if (_inSqrt > _inSqrtCompare * _inSqrtCompare) {\r\n                firstAmountOut_ = (_toAdd - Math.sqrt(_inSqrt)) / _toDiv;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice compute fictive reserves\r\n     * @param _reserveIn reserve of the in-token\r\n     * @param _reserveOut reserve of the out-token\r\n     * @param _fictiveReserveIn fictive reserve of the in-token\r\n     * @param _fictiveReserveOut fictive reserve of the out-token\r\n     * @return newFictiveReserveIn_ new fictive reserve of the in-token\r\n     * @return newFictiveReserveOut_ new fictive reserve of the out-token\r\n     */\r\n    function computeFictiveReserves(\r\n        uint256 _reserveIn,\r\n        uint256 _reserveOut,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut\r\n    ) internal pure returns (uint256 newFictiveReserveIn_, uint256 newFictiveReserveOut_) {\r\n        if (_reserveOut * _fictiveReserveIn < _reserveIn * _fictiveReserveOut) {\r\n            uint256 _temp = (((_reserveOut * _reserveOut) / _fictiveReserveOut) * _fictiveReserveIn) / _reserveIn;\r\n            newFictiveReserveIn_ =\r\n                (_temp * _fictiveReserveIn) /\r\n                _fictiveReserveOut +\r\n                (_reserveOut * _fictiveReserveIn) /\r\n                _fictiveReserveOut;\r\n            newFictiveReserveOut_ = _reserveOut + _temp;\r\n        } else {\r\n            newFictiveReserveIn_ = (_fictiveReserveIn * _reserveOut) / _fictiveReserveOut + _reserveIn;\r\n            newFictiveReserveOut_ = (_reserveIn * _fictiveReserveOut) / _fictiveReserveIn + _reserveOut;\r\n        }\r\n\r\n        // div all values by 4\r\n        newFictiveReserveIn_ /= 4;\r\n        newFictiveReserveOut_ /= 4;\r\n    }\r\n\r\n    /**\r\n     * @notice apply k const rule using fictive reserve, when the amountIn is specified\r\n     * @param _param contain all params required from struct GetAmountParameters\r\n     * @return amountOut_ qty of token that leaves in the contract\r\n     * @return newReserveIn_ new reserve of the in-token after the transaction\r\n     * @return newReserveOut_ new reserve of the out-token after the transaction\r\n     * @return newFictiveReserveIn_ new fictive reserve of the in-token after the transaction\r\n     * @return newFictiveReserveOut_ new fictive reserve of the out-token after the transaction\r\n     */\r\n    function applyKConstRuleOut(\r\n        GetAmountParameters memory _param\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 amountOut_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        // k const rule\r\n        uint256 _amountInWithFee = _param.amount * (FEES_BASE - _param.feesLP - _param.feesPool);\r\n        uint256 _numerator = _amountInWithFee * _param.fictiveReserveOut;\r\n        uint256 _denominator = _param.fictiveReserveIn * FEES_BASE + _amountInWithFee;\r\n        amountOut_ = _numerator / _denominator;\r\n\r\n        // update new reserves and add lp-fees to pools\r\n        uint256 _amountInWithFeeLp = (_amountInWithFee + (_param.amount * _param.feesLP)) / FEES_BASE;\r\n        newReserveIn_ = _param.reserveIn + _amountInWithFeeLp;\r\n        newFictiveReserveIn_ = _param.fictiveReserveIn + _amountInWithFeeLp;\r\n        newReserveOut_ = _param.reserveOut - amountOut_;\r\n        newFictiveReserveOut_ = _param.fictiveReserveOut - amountOut_;\r\n    }\r\n\r\n    /**\r\n     * @notice apply k const rule using fictive reserve, when the amountOut is specified\r\n     * @param _param contain all params required from struct GetAmountParameters\r\n     * @return amountIn_ qty of token that arrives in the contract\r\n     * @return newReserveIn_ new reserve of the in-token after the transaction\r\n     * @return newReserveOut_ new reserve of the out-token after the transaction\r\n     * @return newFictiveReserveIn_ new fictive reserve of the in-token after the transaction\r\n     * @return newFictiveReserveOut_ new fictive reserve of the out-token after the transaction\r\n     */\r\n    function applyKConstRuleIn(\r\n        GetAmountParameters memory _param\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 amountIn_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        // k const rule\r\n        uint256 _numerator = _param.fictiveReserveIn * _param.amount * FEES_BASE;\r\n        uint256 _denominator = (_param.fictiveReserveOut - _param.amount) *\r\n            (FEES_BASE - _param.feesPool - _param.feesLP);\r\n        amountIn_ = _numerator / _denominator + 1;\r\n\r\n        // update new reserves\r\n        uint256 _amountInWithFeeLp = (amountIn_ * (FEES_BASE - _param.feesPool)) / FEES_BASE;\r\n        newReserveIn_ = _param.reserveIn + _amountInWithFeeLp;\r\n        newFictiveReserveIn_ = _param.fictiveReserveIn + _amountInWithFeeLp;\r\n        newReserveOut_ = _param.reserveOut - _param.amount;\r\n        newFictiveReserveOut_ = _param.fictiveReserveOut - _param.amount;\r\n    }\r\n\r\n    /**\r\n     * @notice return the amount of tokens the user would get by doing a swap\r\n     * @param _param contain all params required from struct GetAmountParameters\r\n     * @return amountOut_ The amount of token the user would receive\r\n     * @return newReserveIn_ reserves of the selling token after the swap\r\n     * @return newReserveOut_ reserves of the buying token after the swap\r\n     * @return newFictiveReserveIn_ fictive reserve of the selling token after the swap\r\n     * @return newFictiveReserveOut_ fictive reserve of the buying token after the swap\r\n     */\r\n    function getAmountOut(\r\n        GetAmountParameters memory _param\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 amountOut_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        require(_param.amount != 0, \"SmarDexLibrary: INSUFFICIENT_INPUT_AMOUNT\");\r\n        require(\r\n            _param.reserveIn != 0 &&\r\n                _param.reserveOut != 0 &&\r\n                _param.fictiveReserveIn != 0 &&\r\n                _param.fictiveReserveOut != 0,\r\n            \"SmarDexLibrary: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n\r\n        uint256 _amountInWithFees = (_param.amount * (FEES_BASE - _param.feesPool - _param.feesLP)) / FEES_BASE;\r\n        uint256 _firstAmountIn = computeFirstTradeQtyIn(\r\n            SmardexLibrary.GetAmountParameters({\r\n                amount: _amountInWithFees,\r\n                reserveIn: _param.reserveIn,\r\n                reserveOut: _param.reserveOut,\r\n                fictiveReserveIn: _param.fictiveReserveIn,\r\n                fictiveReserveOut: _param.fictiveReserveOut,\r\n                priceAverageIn: _param.priceAverageIn,\r\n                priceAverageOut: _param.priceAverageOut,\r\n                feesLP: _param.feesLP,\r\n                feesPool: _param.feesPool\r\n            })\r\n        );\r\n\r\n        // if there is 2 trade: 1st trade mustn't re-compute fictive reserves, 2nd should\r\n        if (\r\n            _firstAmountIn == _amountInWithFees &&\r\n            ratioApproxEq(\r\n                _param.fictiveReserveIn,\r\n                _param.fictiveReserveOut,\r\n                _param.priceAverageIn,\r\n                _param.priceAverageOut\r\n            )\r\n        ) {\r\n            (_param.fictiveReserveIn, _param.fictiveReserveOut) = computeFictiveReserves(\r\n                _param.reserveIn,\r\n                _param.reserveOut,\r\n                _param.fictiveReserveIn,\r\n                _param.fictiveReserveOut\r\n            );\r\n        }\r\n\r\n        // avoid stack too deep\r\n        {\r\n            uint256 _firstAmountInNoFees = (_firstAmountIn * FEES_BASE) / (FEES_BASE - _param.feesPool - _param.feesLP);\r\n            (\r\n                amountOut_,\r\n                newReserveIn_,\r\n                newReserveOut_,\r\n                newFictiveReserveIn_,\r\n                newFictiveReserveOut_\r\n            ) = applyKConstRuleOut(\r\n                SmardexLibrary.GetAmountParameters({\r\n                    amount: _firstAmountInNoFees,\r\n                    reserveIn: _param.reserveIn,\r\n                    reserveOut: _param.reserveOut,\r\n                    fictiveReserveIn: _param.fictiveReserveIn,\r\n                    fictiveReserveOut: _param.fictiveReserveOut,\r\n                    priceAverageIn: _param.priceAverageIn,\r\n                    priceAverageOut: _param.priceAverageOut,\r\n                    feesLP: _param.feesLP,\r\n                    feesPool: _param.feesPool\r\n                })\r\n            );\r\n\r\n            // update amountIn in case there is a second trade\r\n            _param.amount -= _firstAmountInNoFees;\r\n        }\r\n\r\n        // if we need a second trade\r\n        if (_firstAmountIn < _amountInWithFees) {\r\n            // in the second trade ALWAYS recompute fictive reserves\r\n            (newFictiveReserveIn_, newFictiveReserveOut_) = computeFictiveReserves(\r\n                newReserveIn_,\r\n                newReserveOut_,\r\n                newFictiveReserveIn_,\r\n                newFictiveReserveOut_\r\n            );\r\n\r\n            uint256 _secondAmountOutNoFees;\r\n            (\r\n                _secondAmountOutNoFees,\r\n                newReserveIn_,\r\n                newReserveOut_,\r\n                newFictiveReserveIn_,\r\n                newFictiveReserveOut_\r\n            ) = applyKConstRuleOut(\r\n                SmardexLibrary.GetAmountParameters({\r\n                    amount: _param.amount,\r\n                    reserveIn: newReserveIn_,\r\n                    reserveOut: newReserveOut_,\r\n                    fictiveReserveIn: newFictiveReserveIn_,\r\n                    fictiveReserveOut: newFictiveReserveOut_,\r\n                    priceAverageIn: _param.priceAverageIn,\r\n                    priceAverageOut: _param.priceAverageOut,\r\n                    feesLP: _param.feesLP,\r\n                    feesPool: _param.feesPool\r\n                })\r\n            );\r\n            amountOut_ += _secondAmountOutNoFees;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice return the amount of tokens the user should spend by doing a swap\r\n     * @param _param contain all params required from struct GetAmountParameters\r\n     * @return amountIn_ The amount of token the user would spend to receive _amountOut\r\n     * @return newReserveIn_ reserves of the selling token after the swap\r\n     * @return newReserveOut_ reserves of the buying token after the swap\r\n     * @return newFictiveReserveIn_ fictive reserve of the selling token after the swap\r\n     * @return newFictiveReserveOut_ fictive reserve of the buying token after the swap\r\n     */\r\n    function getAmountIn(\r\n        GetAmountParameters memory _param\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 amountIn_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        require(_param.amount != 0, \"SmarDexLibrary: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        require(\r\n            _param.amount < _param.fictiveReserveOut &&\r\n                _param.reserveIn != 0 &&\r\n                _param.reserveOut != 0 &&\r\n                _param.fictiveReserveIn != 0 &&\r\n                _param.fictiveReserveOut != 0,\r\n            \"SmarDexLibrary: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n\r\n        uint256 _firstAmountOut = computeFirstTradeQtyOut(_param);\r\n\r\n        // if there is 2 trade: 1st trade mustn't re-compute fictive reserves, 2nd should\r\n        if (\r\n            _firstAmountOut == _param.amount &&\r\n            ratioApproxEq(\r\n                _param.fictiveReserveIn,\r\n                _param.fictiveReserveOut,\r\n                _param.priceAverageIn,\r\n                _param.priceAverageOut\r\n            )\r\n        ) {\r\n            (_param.fictiveReserveIn, _param.fictiveReserveOut) = computeFictiveReserves(\r\n                _param.reserveIn,\r\n                _param.reserveOut,\r\n                _param.fictiveReserveIn,\r\n                _param.fictiveReserveOut\r\n            );\r\n        }\r\n\r\n        (amountIn_, newReserveIn_, newReserveOut_, newFictiveReserveIn_, newFictiveReserveOut_) = applyKConstRuleIn(\r\n            SmardexLibrary.GetAmountParameters({\r\n                amount: _firstAmountOut,\r\n                reserveIn: _param.reserveIn,\r\n                reserveOut: _param.reserveOut,\r\n                fictiveReserveIn: _param.fictiveReserveIn,\r\n                fictiveReserveOut: _param.fictiveReserveOut,\r\n                priceAverageIn: _param.priceAverageIn,\r\n                priceAverageOut: _param.priceAverageOut,\r\n                feesLP: _param.feesLP,\r\n                feesPool: _param.feesPool\r\n            })\r\n        );\r\n\r\n        // if we need a second trade\r\n        if (_firstAmountOut < _param.amount) {\r\n            // in the second trade ALWAYS recompute fictive reserves\r\n            (newFictiveReserveIn_, newFictiveReserveOut_) = computeFictiveReserves(\r\n                newReserveIn_,\r\n                newReserveOut_,\r\n                newFictiveReserveIn_,\r\n                newFictiveReserveOut_\r\n            );\r\n\r\n            uint256 _secondAmountIn;\r\n            (\r\n                _secondAmountIn,\r\n                newReserveIn_,\r\n                newReserveOut_,\r\n                newFictiveReserveIn_,\r\n                newFictiveReserveOut_\r\n            ) = applyKConstRuleIn(\r\n                SmardexLibrary.GetAmountParameters({\r\n                    amount: _param.amount - _firstAmountOut,\r\n                    reserveIn: newReserveIn_,\r\n                    reserveOut: newReserveOut_,\r\n                    fictiveReserveIn: newFictiveReserveIn_,\r\n                    fictiveReserveOut: newFictiveReserveOut_,\r\n                    priceAverageIn: _param.priceAverageIn,\r\n                    priceAverageOut: _param.priceAverageOut,\r\n                    feesLP: _param.feesLP,\r\n                    feesPool: _param.feesPool\r\n                })\r\n            );\r\n            amountIn_ += _secondAmountIn;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n/**\r\n * @title TransferHelper\r\n * @notice helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\n * @custom:from Uniswap lib, adapted to version 0.8.17\r\n * @custom:url https://github.com/Uniswap/solidity-lib/blob/master/contracts/libraries/TransferHelper.sol\r\n */\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper::safeApprove: approve failed\"\r\n        );\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper::safeTransfer: transfer failed\"\r\n        );\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint256 value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(\r\n            success && (data.length == 0 || abi.decode(data, (bool))),\r\n            \"TransferHelper::transferFrom: transferFrom failed\"\r\n        );\r\n    }\r\n\r\n    function safeTransferETH(address to, uint256 value) internal {\r\n        (bool success, ) = to.call{ value: value }(new bytes(0));\r\n        require(success, \"TransferHelper::safeTransferETH: ETH transfer failed\");\r\n    }\r\n}\r\n"
    },
    "contracts/core/SmardexFactory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// contracts\r\nimport \"./SmardexPair.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n// interfaces\r\nimport \"./interfaces/ISmardexFactory.sol\";\r\n\r\n// When adding empty pair to whitelist\r\nerror EmptyPair();\r\n\r\n// When trying to create a new pair and whitelist is open\r\nerror WhitelistNotClosed();\r\n\r\n// When trying to manually add a pair and whitelist was closed\r\nerror WhitelistNotOpen();\r\n\r\n/**\r\n * @title SmardexFactory\r\n * @notice facilitates creation of SmardexPair to swap tokens.\r\n */\r\ncontract SmardexFactory is Ownable, ISmardexFactory {\r\n    bool public whitelistOpen = true;\r\n    address public feeTo;\r\n    uint128 internal feesLP = 700; // MIN 1\r\n    uint128 internal feesPool = 300;\r\n\r\n    mapping(address => mapping(address => address)) public getPair;\r\n    address[] public allPairs;\r\n\r\n    modifier onlyIfWhitelistIsOpen() {\r\n        if (!whitelistOpen) revert WhitelistNotOpen();\r\n        _;\r\n    }\r\n\r\n    modifier onlyIfWhitelistIsClosed() {\r\n        if (whitelistOpen) revert WhitelistNotClosed();\r\n        _;\r\n    }\r\n\r\n    ///@inheritdoc ISmardexFactory\r\n    function allPairsLength() external view returns (uint256) {\r\n        return allPairs.length;\r\n    }\r\n\r\n    ///@inheritdoc ISmardexFactory\r\n    function getDefaultFees() external view returns (uint128 feesLP_, uint128 feesPool_) {\r\n        feesLP_ = feesLP;\r\n        feesPool_ = feesPool;\r\n    }\r\n\r\n    ///@inheritdoc ISmardexFactory\r\n    function createPair(address _tokenA, address _tokenB) external onlyIfWhitelistIsClosed returns (address pair_) {\r\n        require(_tokenA != _tokenB, \"SmarDex: IDENTICAL_ADDRESSES\");\r\n        (address _token0, address _token1) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\r\n        require(_token0 != address(0), \"SmarDex: ZERO_ADDRESS\");\r\n        require(getPair[_token0][_token1] == address(0), \"SmarDex: PAIR_EXISTS\"); // single check is sufficient\r\n        bytes32 _salt = keccak256(abi.encodePacked(_token0, _token1));\r\n        SmardexPair _pair = new SmardexPair{ salt: _salt }();\r\n        _pair.initialize(_token0, _token1, feesLP, feesPool);\r\n        pair_ = address(_pair);\r\n        getPair[_token0][_token1] = pair_;\r\n        getPair[_token1][_token0] = pair_; // populate mapping in the reverse direction\r\n        allPairs.push(pair_);\r\n\r\n        emit PairCreated(_token0, _token1, pair_, allPairs.length);\r\n    }\r\n\r\n    ///@inheritdoc ISmardexFactory\r\n    function setFeeTo(address _feeTo) external onlyOwner {\r\n        address _previousFeeTo = feeTo;\r\n        feeTo = _feeTo;\r\n\r\n        emit FeeToUpdated(_previousFeeTo, _feeTo);\r\n    }\r\n\r\n    ///@inheritdoc ISmardexFactory\r\n    function setFees(uint128 _feesLP, uint128 _feesPool) external onlyOwner {\r\n        require(_feesLP != 0, \"SmarDex: ZERO_FEES_LP\");\r\n        require(_feesLP + _feesPool <= SmardexLibrary.FEES_MAX, \"SmarDex: FEES_MAX\");\r\n        feesLP = _feesLP;\r\n        feesPool = _feesPool;\r\n\r\n        emit FeesChanged(_feesLP, _feesPool);\r\n    }\r\n\r\n    ///@inheritdoc ISmardexFactory\r\n    function closeWhitelist() external onlyOwner onlyIfWhitelistIsOpen {\r\n        whitelistOpen = false;\r\n    }\r\n\r\n    ///@inheritdoc ISmardexFactory\r\n    function addPair(address _pair) external onlyOwner onlyIfWhitelistIsOpen {\r\n        // gas savings and check pair is not address(0) and has property .token0() and .token1()\r\n        address _token0 = ISmardexPair(_pair).token0();\r\n        address _token1 = ISmardexPair(_pair).token1();\r\n\r\n        // avoid the pairs that already exist, single check is sufficient\r\n        require(getPair[_token0][_token1] == address(0), \"SmarDex: PAIR_EXISTS\");\r\n\r\n        // check if pair is empty, because new pairs have the skim function, but not the old ones.\r\n        // It would so revert to use the router with an empty old-pair.\r\n        if (ISmardexPair(_pair).totalSupply() == 0) {\r\n            revert EmptyPair();\r\n        }\r\n\r\n        allPairs.push(_pair);\r\n        getPair[_token0][_token1] = _pair;\r\n        getPair[_token1][_token0] = _pair; // populate mapping in the reverse direction\r\n\r\n        emit PairAdded(_token0, _token1, _pair, allPairs.length);\r\n    }\r\n}\r\n"
    },
    "contracts/core/SmardexPair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// contracts\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\r\n\r\n// libraries\r\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\r\nimport \"./libraries/SmardexLibrary.sol\";\r\nimport \"./libraries/TransferHelper.sol\";\r\n\r\n// interfaces\r\nimport \"./interfaces/ISmardexPair.sol\";\r\nimport \"./interfaces/ISmardexOwnableFactory.sol\";\r\nimport \"./interfaces/ISmardexSwapCallback.sol\";\r\nimport \"./interfaces/ISmardexMintCallback.sol\";\r\n\r\n/**\r\n * @title SmardexPair\r\n * @notice Pair contract that allows user to swap 2 ERC20-strict tokens in a decentralised and automated way\r\n */\r\ncontract SmardexPair is ISmardexPair, ERC20Permit {\r\n    using SafeCast for uint256;\r\n    using SafeCast for int256;\r\n\r\n    uint8 private constant CONTRACT_UNLOCKED = 1;\r\n    uint8 private constant CONTRACT_LOCKED = 2;\r\n    uint256 private constant MINIMUM_LIQUIDITY = 10 ** 3;\r\n    bytes4 private constant AUTOSWAP_SELECTOR = bytes4(keccak256(bytes(\"executeWork(address,address)\")));\r\n\r\n    address public immutable factory;\r\n    address public token0;\r\n    address public token1;\r\n\r\n    // smardex pair fees numerators, denominator is 1_000_000\r\n    uint128 internal feesLP = 1; // numerator of fees sent to lp, min 1,\r\n    uint128 internal feesPool; // numerator of fees sent to pool\r\n\r\n    // smardex new fictive reserves\r\n    uint128 internal fictiveReserve0;\r\n    uint128 internal fictiveReserve1; // accessible via getFictiveReserves()\r\n\r\n    // moving average on the price\r\n    uint128 internal priceAverage0;\r\n    uint128 internal priceAverage1;\r\n    uint40 internal priceAverageLastTimestamp; // accessible via getPriceAverage()\r\n\r\n    // fee for FEE_POOL\r\n    uint104 internal feeToAmount0;\r\n    uint104 internal feeToAmount1; // accessible via getFeeToAmounts()\r\n\r\n    // reentrancy\r\n    uint8 private lockStatus = CONTRACT_UNLOCKED;\r\n\r\n    modifier lock() {\r\n        require(lockStatus == CONTRACT_UNLOCKED, \"SmarDex: LOCKED\");\r\n        lockStatus = CONTRACT_LOCKED;\r\n        _;\r\n        lockStatus = CONTRACT_UNLOCKED;\r\n    }\r\n\r\n    modifier onlyFactoryOwner() {\r\n        require(msg.sender == ISmardexOwnableFactory(factory).owner(), \"SmarDex: NOT_OWNER\");\r\n        _;\r\n    }\r\n\r\n    constructor() ERC20(\"SmarDex LP-Token\", \"SDEX-LP\") ERC20Permit(\"SmarDex LP-Token\") {\r\n        factory = msg.sender;\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPair\r\n    function initialize(address _token0, address _token1, uint128 _feesLP, uint128 _feesPool) external override {\r\n        require(msg.sender == factory, \"SmarDex: FORBIDDEN\"); // sufficient check\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n        _setFees(_feesLP, _feesPool);\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPair\r\n    function getReserves() external view override returns (uint256 reserve0_, uint256 reserve1_) {\r\n        reserve0_ = IERC20(token0).balanceOf(address(this)) - feeToAmount0;\r\n        reserve1_ = IERC20(token1).balanceOf(address(this)) - feeToAmount1;\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPair\r\n    function getFictiveReserves() external view override returns (uint256 fictiveReserve0_, uint256 fictiveReserve1_) {\r\n        fictiveReserve0_ = fictiveReserve0;\r\n        fictiveReserve1_ = fictiveReserve1;\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPair\r\n    function getFeeToAmounts() external view override returns (uint256 fees0_, uint256 fees1_) {\r\n        fees0_ = feeToAmount0;\r\n        fees1_ = feeToAmount1;\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPair\r\n    function getPairFees() external view override returns (uint128 feesLP_, uint128 feesPool_) {\r\n        feesLP_ = feesLP;\r\n        feesPool_ = feesPool;\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPair\r\n    function getPriceAverage()\r\n        external\r\n        view\r\n        returns (uint256 priceAverage0_, uint256 priceAverage1_, uint256 priceAverageLastTimestamp_)\r\n    {\r\n        priceAverage0_ = priceAverage0;\r\n        priceAverage1_ = priceAverage1;\r\n        priceAverageLastTimestamp_ = priceAverageLastTimestamp;\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPair\r\n    function getUpdatedPriceAverage(\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint256 _priceAverageLastTimestamp,\r\n        uint256 _priceAverageIn,\r\n        uint256 _priceAverageOut,\r\n        uint256 _currentTimestamp\r\n    ) public pure returns (uint256 priceAverageIn_, uint256 priceAverageOut_) {\r\n        (priceAverageIn_, priceAverageOut_) = SmardexLibrary.getUpdatedPriceAverage(\r\n            _fictiveReserveIn,\r\n            _fictiveReserveOut,\r\n            _priceAverageLastTimestamp,\r\n            _priceAverageIn,\r\n            _priceAverageOut,\r\n            _currentTimestamp\r\n        );\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPair\r\n    function mint(\r\n        address _to,\r\n        uint256 _amount0,\r\n        uint256 _amount1,\r\n        address _payer\r\n    ) external override returns (uint256 liquidity_) {\r\n        liquidity_ = _mintBeforeFee(_to, _amount0, _amount1, _payer);\r\n\r\n        // we call feeTo out of the internal locked mint (_mintExt) function to be able to swap fees in here\r\n        _feeToSwap();\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPair\r\n    function burn(address _to) external override returns (uint256 amount0_, uint256 amount1_) {\r\n        (amount0_, amount1_) = _burnBeforeFee(_to);\r\n\r\n        // we call feeTo out of the internal locked burn (_burnExt) function to be able to swap fees in here\r\n        _feeToSwap();\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPair\r\n    function swap(\r\n        address _to,\r\n        bool _zeroForOne,\r\n        int256 _amountSpecified,\r\n        bytes calldata _data\r\n    ) external override lock returns (int256 amount0_, int256 amount1_) {\r\n        require(_amountSpecified != 0, \"SmarDex: ZERO_AMOUNT\");\r\n\r\n        ISmardexPair.SwapParams memory _params = SwapParams({\r\n            amountCalculated: 0,\r\n            fictiveReserveIn: 0,\r\n            fictiveReserveOut: 0,\r\n            priceAverageIn: 0,\r\n            priceAverageOut: 0,\r\n            token0: token0,\r\n            token1: token1,\r\n            balanceIn: 0,\r\n            balanceOut: 0\r\n        });\r\n\r\n        require(_to != _params.token0 && _to != _params.token1, \"SmarDex: INVALID_TO\");\r\n        (\r\n            _params.balanceIn,\r\n            _params.balanceOut,\r\n            _params.fictiveReserveIn,\r\n            _params.fictiveReserveOut,\r\n            _params.priceAverageIn,\r\n            _params.priceAverageOut\r\n        ) = _zeroForOne\r\n            ? (\r\n                IERC20(_params.token0).balanceOf(address(this)) - feeToAmount0,\r\n                IERC20(_params.token1).balanceOf(address(this)) - feeToAmount1,\r\n                fictiveReserve0,\r\n                fictiveReserve1,\r\n                priceAverage0,\r\n                priceAverage1\r\n            )\r\n            : (\r\n                IERC20(_params.token1).balanceOf(address(this)) - feeToAmount1,\r\n                IERC20(_params.token0).balanceOf(address(this)) - feeToAmount0,\r\n                fictiveReserve1,\r\n                fictiveReserve0,\r\n                priceAverage1,\r\n                priceAverage0\r\n            );\r\n\r\n        // compute new price average\r\n        (_params.priceAverageIn, _params.priceAverageOut) = SmardexLibrary.getUpdatedPriceAverage(\r\n            _params.fictiveReserveIn,\r\n            _params.fictiveReserveOut,\r\n            priceAverageLastTimestamp,\r\n            _params.priceAverageIn,\r\n            _params.priceAverageOut,\r\n            block.timestamp\r\n        );\r\n\r\n        // SSTORE new price average\r\n        (priceAverage0, priceAverage1, priceAverageLastTimestamp) = _zeroForOne\r\n            ? (_params.priceAverageIn.toUint128(), _params.priceAverageOut.toUint128(), uint40(block.timestamp))\r\n            : (_params.priceAverageOut.toUint128(), _params.priceAverageIn.toUint128(), uint40(block.timestamp));\r\n\r\n        uint128 _feesPool = feesPool; // caching feesPool to save gas\r\n\r\n        if (_amountSpecified > 0) {\r\n            uint256 _temp;\r\n            (_temp, , , _params.fictiveReserveIn, _params.fictiveReserveOut) = SmardexLibrary.getAmountOut(\r\n                SmardexLibrary.GetAmountParameters({\r\n                    amount: _amountSpecified.toUint256(),\r\n                    reserveIn: _params.balanceIn,\r\n                    reserveOut: _params.balanceOut,\r\n                    fictiveReserveIn: _params.fictiveReserveIn,\r\n                    fictiveReserveOut: _params.fictiveReserveOut,\r\n                    priceAverageIn: _params.priceAverageIn,\r\n                    priceAverageOut: _params.priceAverageOut,\r\n                    feesLP: feesLP,\r\n                    feesPool: _feesPool\r\n                })\r\n            );\r\n            _params.amountCalculated = _temp.toInt256();\r\n        } else {\r\n            uint256 _temp;\r\n            (_temp, , , _params.fictiveReserveIn, _params.fictiveReserveOut) = SmardexLibrary.getAmountIn(\r\n                SmardexLibrary.GetAmountParameters({\r\n                    amount: (-_amountSpecified).toUint256(),\r\n                    reserveIn: _params.balanceIn,\r\n                    reserveOut: _params.balanceOut,\r\n                    fictiveReserveIn: _params.fictiveReserveIn,\r\n                    fictiveReserveOut: _params.fictiveReserveOut,\r\n                    priceAverageIn: _params.priceAverageIn,\r\n                    priceAverageOut: _params.priceAverageOut,\r\n                    feesLP: feesLP,\r\n                    feesPool: _feesPool\r\n                })\r\n            );\r\n            _params.amountCalculated = _temp.toInt256();\r\n        }\r\n\r\n        (amount0_, amount1_) = _zeroForOne\r\n            ? (\r\n                _amountSpecified > 0\r\n                    ? (_amountSpecified, -_params.amountCalculated)\r\n                    : (_params.amountCalculated, _amountSpecified)\r\n            )\r\n            : (\r\n                _amountSpecified > 0\r\n                    ? (-_params.amountCalculated, _amountSpecified)\r\n                    : (_amountSpecified, _params.amountCalculated)\r\n            );\r\n\r\n        if (_zeroForOne) {\r\n            if (amount1_ < 0) {\r\n                TransferHelper.safeTransfer(_params.token1, _to, uint256(-amount1_));\r\n            }\r\n            ISmardexSwapCallback(msg.sender).smardexSwapCallback(amount0_, amount1_, _data);\r\n            uint256 _balanceInBefore = _params.balanceIn;\r\n            _params.balanceIn = IERC20(token0).balanceOf(address(this));\r\n            require(\r\n                _balanceInBefore + feeToAmount0 + (amount0_).toUint256() <= _params.balanceIn,\r\n                \"SmarDex: INSUFFICIENT_TOKEN0_INPUT_AMOUNT\"\r\n            );\r\n            _params.balanceOut = IERC20(token1).balanceOf(address(this));\r\n        } else {\r\n            if (amount0_ < 0) {\r\n                TransferHelper.safeTransfer(_params.token0, _to, uint256(-amount0_));\r\n            }\r\n            ISmardexSwapCallback(msg.sender).smardexSwapCallback(amount0_, amount1_, _data);\r\n            uint256 _balanceInBefore = _params.balanceIn;\r\n            _params.balanceIn = IERC20(token1).balanceOf(address(this));\r\n            require(\r\n                _balanceInBefore + feeToAmount1 + (amount1_).toUint256() <= _params.balanceIn,\r\n                \"SmarDex: INSUFFICIENT_TOKEN1_INPUT_AMOUNT\"\r\n            );\r\n            _params.balanceOut = IERC20(token0).balanceOf(address(this));\r\n        }\r\n\r\n        // update feeTopart\r\n        bool _feeOn = ISmardexOwnableFactory(factory).feeTo() != address(0);\r\n        if (_zeroForOne) {\r\n            if (_feeOn) {\r\n                feeToAmount0 += ((uint256(amount0_) * _feesPool) / SmardexLibrary.FEES_BASE).toUint104();\r\n            }\r\n            _update(\r\n                _params.balanceIn,\r\n                _params.balanceOut,\r\n                _params.fictiveReserveIn,\r\n                _params.fictiveReserveOut,\r\n                _params.priceAverageIn,\r\n                _params.priceAverageOut\r\n            );\r\n        } else {\r\n            if (_feeOn) {\r\n                feeToAmount1 += ((uint256(amount1_) * _feesPool) / SmardexLibrary.FEES_BASE).toUint104();\r\n            }\r\n            _update(\r\n                _params.balanceOut,\r\n                _params.balanceIn,\r\n                _params.fictiveReserveOut,\r\n                _params.fictiveReserveIn,\r\n                _params.priceAverageOut,\r\n                _params.priceAverageIn\r\n            );\r\n        }\r\n\r\n        emit Swap(msg.sender, _to, amount0_, amount1_);\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPair\r\n    function setFees(uint128 _feesLP, uint128 _feesPool) external onlyFactoryOwner {\r\n        _setFees(_feesLP, _feesPool);\r\n    }\r\n\r\n    /**\r\n     * @notice set feesLP and feesPool of the pair\r\n     * @notice sum of new feesLp and feesPool must be <= 100_000\r\n     * @param _feesLP new numerator of fees sent to LP, must be >= 1\r\n     * @param _feesPool new numerator of fees sent to Pool, could be = 0\r\n     */\r\n    function _setFees(uint128 _feesLP, uint128 _feesPool) internal {\r\n        require(_feesLP != 0, \"SmarDex: ZERO_FEES_LP\");\r\n        require(_feesLP + _feesPool <= SmardexLibrary.FEES_MAX, \"SmarDex: FEES_MAX\");\r\n        feesLP = _feesLP;\r\n        feesPool = _feesPool;\r\n\r\n        emit FeesChanged(_feesLP, _feesPool);\r\n    }\r\n\r\n    /**\r\n     * @notice update fictive reserves and emit the Sync event\r\n     * @param _balance0 the new balance of token0\r\n     * @param _balance1 the new balance of token1\r\n     * @param _fictiveReserve0 the new fictive reserves of token0\r\n     * @param _fictiveReserve1 the new fictive reserves of token1\r\n     * @param _priceAverage0 the new priceAverage of token0\r\n     * @param _priceAverage1 the new priceAverage of token1\r\n     */\r\n    function _update(\r\n        uint256 _balance0,\r\n        uint256 _balance1,\r\n        uint256 _fictiveReserve0,\r\n        uint256 _fictiveReserve1,\r\n        uint256 _priceAverage0,\r\n        uint256 _priceAverage1\r\n    ) private {\r\n        require(_fictiveReserve0 != 0 && _fictiveReserve1 != 0, \"SmarDex: FICTIVE_RESERVES_TOO_LOW\");\r\n        require(_fictiveReserve0 <= type(uint128).max && _fictiveReserve1 <= type(uint128).max, \"SmarDex: OVERFLOW\");\r\n        fictiveReserve0 = uint128(_fictiveReserve0);\r\n        fictiveReserve1 = uint128(_fictiveReserve1);\r\n\r\n        emit Sync(\r\n            _balance0 - feeToAmount0,\r\n            _balance1 - feeToAmount1,\r\n            _fictiveReserve0,\r\n            _fictiveReserve1,\r\n            _priceAverage0,\r\n            _priceAverage1\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice transfers feeToAmount of tokens 0 and 1 to feeTo, and reset feeToAmounts\r\n     * @return feeOn_ if part of the fees goes to feeTo\r\n     */\r\n    function _sendFee() private returns (bool feeOn_) {\r\n        address _feeTo = ISmardexFactory(factory).feeTo();\r\n        feeOn_ = _feeTo != address(0);\r\n        if (feeOn_) {\r\n            // gas saving\r\n            uint256 _feeToAmount0 = feeToAmount0;\r\n            uint256 _feeToAmount1 = feeToAmount1;\r\n\r\n            if (_feeToAmount0 != 0) {\r\n                TransferHelper.safeTransfer(token0, _feeTo, _feeToAmount0);\r\n                feeToAmount0 = 0;\r\n            }\r\n            if (_feeToAmount1 != 0) {\r\n                TransferHelper.safeTransfer(token1, _feeTo, _feeToAmount1);\r\n                feeToAmount1 = 0;\r\n            }\r\n        } else {\r\n            feeToAmount0 = 0;\r\n            feeToAmount1 = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Mint lp tokens proportionally of added tokens in balance.\r\n     * @param _to address who will receive minted tokens\r\n     * @param _amount0 amount of token0 to provide\r\n     * @param _amount1 amount of token1 to provide\r\n     * @param _payer address of the payer to provide token for the mint\r\n     * @return liquidity_ amount of lp tokens minted and sent to the address defined in parameter\r\n     */\r\n    function _mintBeforeFee(\r\n        address _to,\r\n        uint256 _amount0,\r\n        uint256 _amount1,\r\n        address _payer\r\n    ) internal lock returns (uint256 liquidity_) {\r\n        _sendFee();\r\n\r\n        uint256 _fictiveReserve0;\r\n        uint256 _fictiveReserve1;\r\n\r\n        // gas saving\r\n        uint256 _balance0 = IERC20(token0).balanceOf(address(this));\r\n        uint256 _balance1 = IERC20(token1).balanceOf(address(this));\r\n        uint256 _totalSupply = totalSupply();\r\n\r\n        ISmardexMintCallback(msg.sender).smardexMintCallback(\r\n            ISmardexMintCallback.MintCallbackData({\r\n                token0: token0,\r\n                token1: token1,\r\n                amount0: _amount0,\r\n                amount1: _amount1,\r\n                payer: _payer\r\n            })\r\n        );\r\n\r\n        // gas savings\r\n        uint256 _balance0after = IERC20(token0).balanceOf(address(this));\r\n        uint256 _balance1after = IERC20(token1).balanceOf(address(this));\r\n\r\n        require(_balance0after >= _balance0 + _amount0, \"SmarDex: INSUFFICIENT_AMOUNT_0\");\r\n        require(_balance1after >= _balance1 + _amount1, \"SmarDex: INSUFFICIENT_AMOUNT_1\");\r\n\r\n        if (_totalSupply == 0) {\r\n            liquidity_ = Math.sqrt(_amount0 * _amount1) - MINIMUM_LIQUIDITY;\r\n            _mint(address(0xdead), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\r\n            _fictiveReserve0 = _balance0after / 2;\r\n            _fictiveReserve1 = _balance1after / 2;\r\n        } else {\r\n            liquidity_ = Math.min((_amount0 * _totalSupply) / _balance0, (_amount1 * _totalSupply) / _balance1);\r\n\r\n            // update proportionally the fictiveReserves\r\n            _fictiveReserve0 = (fictiveReserve0 * (_totalSupply + liquidity_)) / _totalSupply;\r\n            _fictiveReserve1 = (fictiveReserve1 * (_totalSupply + liquidity_)) / _totalSupply;\r\n        }\r\n\r\n        require(liquidity_ != 0, \"SmarDex: INSUFFICIENT_LIQUIDITY_MINTED\");\r\n        _mint(_to, liquidity_);\r\n\r\n        _update(_balance0after, _balance1after, _fictiveReserve0, _fictiveReserve1, priceAverage0, priceAverage1);\r\n\r\n        emit Mint(msg.sender, _to, _amount0, _amount1);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn lp tokens in the balance of the contract. Sends to the defined address the amount of token0 and\r\n     * token1 proportionally of the amount burned.\r\n     * @param _to address who will receive tokens\r\n     * @return amount0_ amount of token0 sent to the address defined in parameter\r\n     * @return amount1_ amount of token0 sent to the address defined in parameter\r\n     */\r\n    function _burnBeforeFee(address _to) internal lock returns (uint256 amount0_, uint256 amount1_) {\r\n        _sendFee();\r\n\r\n        // gas savings\r\n        address _token0 = token0;\r\n        address _token1 = token1;\r\n        uint256 _balance0 = IERC20(_token0).balanceOf(address(this));\r\n        uint256 _balance1 = IERC20(_token1).balanceOf(address(this));\r\n        uint256 _liquidity = balanceOf(address(this));\r\n        uint256 _totalSupply = totalSupply();\r\n\r\n        // pro-rata distribution\r\n        amount0_ = (_liquidity * _balance0) / _totalSupply;\r\n        amount1_ = (_liquidity * _balance1) / _totalSupply;\r\n        require(amount0_ != 0 && amount1_ != 0, \"SmarDex: INSUFFICIENT_LIQUIDITY_BURNED\");\r\n\r\n        // update proportionally the fictiveReserves\r\n        uint256 _fictiveReserve0 = fictiveReserve0;\r\n        uint256 _fictiveReserve1 = fictiveReserve1;\r\n        _fictiveReserve0 -= (_fictiveReserve0 * _liquidity) / _totalSupply;\r\n        _fictiveReserve1 -= (_fictiveReserve1 * _liquidity) / _totalSupply;\r\n\r\n        _burn(address(this), _liquidity);\r\n        TransferHelper.safeTransfer(_token0, _to, amount0_);\r\n        TransferHelper.safeTransfer(_token1, _to, amount1_);\r\n\r\n        _balance0 = IERC20(_token0).balanceOf(address(this));\r\n        _balance1 = IERC20(_token1).balanceOf(address(this));\r\n\r\n        _update(_balance0, _balance1, _fictiveReserve0, _fictiveReserve1, priceAverage0, priceAverage1);\r\n\r\n        emit Burn(msg.sender, _to, amount0_, amount1_);\r\n    }\r\n\r\n    /**\r\n     * @notice execute function \"executeWork(address,address)\" of the feeTo contract. Doesn't revert tx if it reverts\r\n     */\r\n    function _feeToSwap() internal {\r\n        address _feeTo = ISmardexOwnableFactory(factory).feeTo();\r\n\r\n        // call contract destination for handling fees\r\n        // We don't handle return values so it does not revert for LP if something went wrong in feeTo\r\n        // Will swap fees to SDEX and send them. We want this to not revert if the swap failed\r\n        // but to revert if not enough gas\r\n        _feeTo.call(abi.encodeWithSelector(AUTOSWAP_SELECTOR, token0, token1));\r\n\r\n        // After the _feeTo call, we check if gas is not equal to 0. Though seemingly redundant\r\n        // (as running out of gas would fail the transaction anyway), this require prevents the\r\n        // compiler from ignoring a simple gasleft() expression, which it may perceive as\r\n        // useless if not used elsewhere. The aim here is to consume some gas to ensure the\r\n        // transaction isn't out of gas at this point. This acts as a safeguard against potential\r\n        // exploitation where a low gasLimit prevents the _feeTo call from fully executing.\r\n        require(gasleft() != 0, \"\");\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPair\r\n    function skim(address _to) external lock {\r\n        require(totalSupply() == 0, \"SmarDex: ONLY_EMPTY_PAIR\");\r\n\r\n        // gas savings\r\n        address _token0 = token0;\r\n        address _token1 = token1;\r\n        uint256 _balance0 = IERC20(_token0).balanceOf(address(this));\r\n        uint256 _balance1 = IERC20(_token1).balanceOf(address(this));\r\n\r\n        if (_balance0 != 0) {\r\n            TransferHelper.safeTransfer(_token0, _to, _balance0);\r\n        }\r\n        if (_balance1 != 0) {\r\n            TransferHelper.safeTransfer(_token1, _to, _balance1);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/test/coreV1/interfaces/ISmardexFactoryV1.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.8.17;\r\n\r\ninterface ISmardexFactoryV1 {\r\n    /**\r\n     * @notice emitted at each SmardexPair created\r\n     * @param token0 address of the token0\r\n     * @param token1 address of the token1\r\n     * @param pair address of the SmardexPair created\r\n     * @param totalPair number of SmardexPair created so far\r\n     */\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint256 totalPair);\r\n\r\n    /**\r\n     * @notice return which address fees will be transferred\r\n     */\r\n    function feeTo() external view returns (address);\r\n\r\n    /**\r\n     * @notice return which address can update feeTo\r\n     */\r\n    function feeToSetter() external view returns (address);\r\n\r\n    /**\r\n     * @notice return the address of the pair of 2 tokens\r\n     */\r\n    function getPair(address _tokenA, address _tokenB) external view returns (address pair_);\r\n\r\n    /**\r\n     * @notice return the address of the pair at index\r\n     * @param _index index of the pair\r\n     * @return pair_ address of the pair\r\n     */\r\n    function allPairs(uint256 _index) external view returns (address pair_);\r\n\r\n    /**\r\n     * @notice return the quantity of pairs\r\n     * @return quantity in uint256\r\n     */\r\n    function allPairsLength() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice create pair with 2 address\r\n     * @param _tokenA address of tokenA\r\n     * @param _tokenB address of tokenB\r\n     * @return pair_ address of the pair created\r\n     */\r\n    function createPair(address _tokenA, address _tokenB) external returns (address pair_);\r\n\r\n    /**\r\n     * @notice set the address who will receive fees, can only be call by feeToSetter\r\n     * @param _feeTo address to replace\r\n     */\r\n    function setFeeTo(address _feeTo) external;\r\n\r\n    /**\r\n     * @notice set the address who can update feeTo, can only be call by feeToSetter\r\n     * @param _feeToSetter address to replace\r\n     */\r\n    function setFeeToSetter(address _feeToSetter) external;\r\n}\r\n"
    },
    "contracts/core/test/coreV1/interfaces/ISmardexPairV1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity >=0.8.17;\r\n\r\n// interfaces\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\r\n\r\ninterface ISmardexPairV1 is IERC20, IERC20Permit {\r\n    /**\r\n     * @notice emitted at each mint\r\n     * @param sender address calling the mint function (usualy the Router contract)\r\n     * @param to address that receives the LP-tokens\r\n     * @param amount0 amount of token0 to be added in liquidity\r\n     * @param amount1 amount of token1 to be added in liquidity\r\n     * @dev the amount of LP-token sent can be caught using the transfer event of the pair\r\n     */\r\n    event Mint(address indexed sender, address indexed to, uint256 amount0, uint256 amount1);\r\n\r\n    /**\r\n     * @notice emitted at each burn\r\n     * @param sender address calling the burn function (usualy the Router contract)\r\n     * @param to address that receives the tokens\r\n     * @param amount0 amount of token0 to be withdrawn\r\n     * @param amount1 amount of token1 to be withdrawn\r\n     * @dev the amount of LP-token sent can be caught using the transfer event of the pair\r\n     */\r\n    event Burn(address indexed sender, address indexed to, uint256 amount0, uint256 amount1);\r\n\r\n    /**\r\n     * @notice emitted at each swap\r\n     * @param sender address calling the swap function (usualy the Router contract)\r\n     * @param to address that receives the out-tokens\r\n     * @param amount0 amount of token0 to be swapped\r\n     * @param amount1 amount of token1 to be swapped\r\n     * @dev one of the 2 amount is always negative, the other one is always positive. The positive one is the one that\r\n     * the user send to the contract, the negative one is the one that the contract send to the user.\r\n     */\r\n    event Swap(address indexed sender, address indexed to, int256 amount0, int256 amount1);\r\n\r\n    /**\r\n     * @notice emitted each time the fictive reserves are changed (mint, burn, swap)\r\n     * @param reserve0 the new reserve of token0\r\n     * @param reserve1 the new reserve of token1\r\n     * @param fictiveReserve0 the new fictive reserve of token0\r\n     * @param fictiveReserve1 the new fictive reserve of token1\r\n     * @param priceAverage0 the new priceAverage of token0\r\n     * @param priceAverage1 the new priceAverage of token1\r\n     */\r\n    event Sync(\r\n        uint256 reserve0,\r\n        uint256 reserve1,\r\n        uint256 fictiveReserve0,\r\n        uint256 fictiveReserve1,\r\n        uint256 priceAverage0,\r\n        uint256 priceAverage1\r\n    );\r\n\r\n    /**\r\n     * @notice get the factory address\r\n     * @return address of the factory\r\n     */\r\n    function factory() external view returns (address);\r\n\r\n    /**\r\n     * @notice get the token0 address\r\n     * @return address of the token0\r\n     */\r\n    function token0() external view returns (address);\r\n\r\n    /**\r\n     * @notice get the token1 address\r\n     * @return address of the token1\r\n     */\r\n    function token1() external view returns (address);\r\n\r\n    /**\r\n     * @notice called once by the factory at time of deployment\r\n     * @param _token0 address of token0\r\n     * @param _token1 address of token1\r\n     */\r\n    function initialize(address _token0, address _token1) external;\r\n\r\n    /**\r\n     * @notice return current Reserves of both token in the pair,\r\n     *  corresponding to token balance - pending fees\r\n     * @return reserve0_ current reserve of token0 - pending fee0\r\n     * @return reserve1_ current reserve of token1 - pending fee1\r\n     */\r\n    function getReserves() external view returns (uint256 reserve0_, uint256 reserve1_);\r\n\r\n    /**\r\n     * @notice return current Fictives Reserves of both token in the pair\r\n     * @return fictiveReserve0_ current fictive reserve of token0\r\n     * @return fictiveReserve1_ current fictive reserve of token1\r\n     */\r\n    function getFictiveReserves() external view returns (uint256 fictiveReserve0_, uint256 fictiveReserve1_);\r\n\r\n    /**\r\n     * @notice return current pending fees of both token in the pair\r\n     * @return fees0_ current pending fees of token0\r\n     * @return fees1_ current pending fees of token1\r\n     */\r\n    function getFees() external view returns (uint256 fees0_, uint256 fees1_);\r\n\r\n    /**\r\n     * @notice return last updated price average at timestamp of both token in the pair,\r\n     *  read price0Average/price1Average for current price of token0/token1\r\n     * @return priceAverage0_ current price for token0\r\n     * @return priceAverage1_ current price for token1\r\n     * @return blockTimestampLast_ last block timestamp when price was updated\r\n     */\r\n    function getPriceAverage()\r\n        external\r\n        view\r\n        returns (uint256 priceAverage0_, uint256 priceAverage1_, uint256 blockTimestampLast_);\r\n\r\n    /**\r\n     * @notice return current price average of both token in the pair for provided currentTimeStamp\r\n     *  read price0Average/price1Average for current price of token0/token1\r\n     * @param _fictiveReserveIn,\r\n     * @param _fictiveReserveOut,\r\n     * @param _priceAverageLastTimestamp,\r\n     * @param _priceAverageIn current price for token0\r\n     * @param _priceAverageOut current price for token1\r\n     * @param _currentTimestamp block timestamp to get price\r\n     * @return priceAverageIn_ current price for token0\r\n     * @return priceAverageOut_ current price for token1\r\n     */\r\n    function getUpdatedPriceAverage(\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint256 _priceAverageLastTimestamp,\r\n        uint256 _priceAverageIn,\r\n        uint256 _priceAverageOut,\r\n        uint256 _currentTimestamp\r\n    ) external pure returns (uint256 priceAverageIn_, uint256 priceAverageOut_);\r\n\r\n    /**\r\n     * @notice Mint lp tokens proportionally of added tokens in balance. Should be called from a contract\r\n     * that makes safety checks like the SmardexRouter\r\n     * @param _to address who will receive minted tokens\r\n     * @param _amount0 amount of token0 to provide\r\n     * @param _amount1 amount of token1 to provide\r\n     * @return liquidity_ amount of lp tokens minted and sent to the address defined in parameter\r\n     */\r\n    function mint(\r\n        address _to,\r\n        uint256 _amount0,\r\n        uint256 _amount1,\r\n        address _payer\r\n    ) external returns (uint256 liquidity_);\r\n\r\n    /**\r\n     * @notice Burn lp tokens in the balance of the contract. Sends to the defined address the amount of token0 and\r\n     * token1 proportionally of the amount burned. Should be called from a contract that makes safety checks like the\r\n     * SmardexRouter\r\n     * @param _to address who will receive tokens\r\n     * @return amount0_ amount of token0 sent to the address defined in parameter\r\n     * @return amount1_ amount of token0 sent to the address defined in parameter\r\n     */\r\n    function burn(address _to) external returns (uint256 amount0_, uint256 amount1_);\r\n\r\n    /**\r\n     * @notice Swaps tokens. Sends to the defined address the amount of token0 and token1 defined in parameters.\r\n     * Tokens to trade should be already sent in the contract.\r\n     * Swap function will check if the resulted balance is correct with current reserves and reserves fictive.\r\n     * Should be called from a contract that makes safety checks like the SmardexRouter\r\n     * @param _to address who will receive tokens\r\n     * @param _zeroForOne token0 to token1\r\n     * @param _amountSpecified amount of token wanted\r\n     * @param _data used for flash swap, data.length must be 0 for regular swap\r\n     */\r\n    function swap(\r\n        address _to,\r\n        bool _zeroForOne,\r\n        int256 _amountSpecified,\r\n        bytes calldata _data\r\n    ) external returns (int256 amount0_, int256 amount1_);\r\n}\r\n"
    },
    "contracts/core/test/coreV1/interfaces/ISmardexSwapCallbackV1.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.8.17;\r\n\r\ninterface ISmardexSwapCallbackV1 {\r\n    /**\r\n     * @notice callback data for swap\r\n     * @param _amount0Delta amount of token0 for the swap (negative is incoming, positive is required to pay to pair)\r\n     * @param _amount1Delta amount of token1 for the swap (negative is incoming, positive is required to pay to pair)\r\n     * @param _data for Router path and payer for the swap (see router for details)\r\n     */\r\n    function smardexSwapCallback(int256 _amount0Delta, int256 _amount1Delta, bytes calldata _data) external;\r\n}\r\n"
    },
    "contracts/core/test/coreV1/libraries/SmardexLibraryV1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity =0.8.17;\r\n\r\n// libraries\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\n\r\n// interfaces\r\nimport \"../interfaces/ISmardexPairV1.sol\";\r\n\r\nlibrary SmardexLibraryV1 {\r\n    /// @notice amount of fees sent to LP, not in percent but in FEES_BASE\r\n    uint256 public constant FEES_LP = 5;\r\n\r\n    /// @notice amount of fees sent to the pool, not in percent but in FEES_BASE. if feeTo is null, sent to the LP\r\n    uint256 public constant FEES_POOL = 2;\r\n\r\n    /// @notice total amount of fees, not in percent but in FEES_BASE\r\n    uint256 public constant FEES_TOTAL = FEES_LP + FEES_POOL;\r\n\r\n    /// @notice base of the FEES\r\n    uint256 public constant FEES_BASE = 10000;\r\n\r\n    /// @notice ratio of quantity that is send to the user, after removing the fees, not in percent but in FEES_BASE\r\n    uint256 public constant REVERSE_FEES_TOTAL = FEES_BASE - FEES_TOTAL;\r\n\r\n    /// @notice precision for approxEq, not in percent but in APPROX_PRECISION_BASE\r\n    uint256 public constant APPROX_PRECISION = 1;\r\n\r\n    /// @notice base of the APPROX_PRECISION\r\n    uint256 public constant APPROX_PRECISION_BASE = 1_000_000;\r\n\r\n    /// @notice number of seconds to reset priceAverage\r\n    uint256 private constant MAX_BLOCK_DIFF_SECONDS = 300;\r\n\r\n    /**\r\n     * @notice check if 2 numbers are approximatively equal, using APPROX_PRECISION\r\n     * @param _x number to compare\r\n     * @param _y number to compare\r\n     * @return true if numbers are approximatively equal, false otherwise\r\n     */\r\n    function approxEq(uint256 _x, uint256 _y) internal pure returns (bool) {\r\n        if (_x > _y) {\r\n            return _x < (_y + (_y * APPROX_PRECISION) / APPROX_PRECISION_BASE);\r\n        } else {\r\n            return _y < (_x + (_x * APPROX_PRECISION) / APPROX_PRECISION_BASE);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice check if 2 ratio are approximatively equal: _xNum _/ xDen ~= _yNum / _yDen\r\n     * @param _xNum numerator of the first ratio to compare\r\n     * @param _xDen denominator of the first ratio to compare\r\n     * @param _yNum numerator of the second ratio to compare\r\n     * @param _yDen denominator of the second ratio to compare\r\n     * @return true if ratio are approximatively equal, false otherwise\r\n     */\r\n    function ratioApproxEq(uint256 _xNum, uint256 _xDen, uint256 _yNum, uint256 _yDen) internal pure returns (bool) {\r\n        return approxEq(_xNum * _yDen, _xDen * _yNum);\r\n    }\r\n\r\n    /**\r\n     * @notice update priceAverage given old timestamp, new timestamp and prices\r\n     * @param _fictiveReserveIn ratio component of the new price of the in-token\r\n     * @param _fictiveReserveOut ratio component of the new price of the out-token\r\n     * @param _priceAverageLastTimestamp timestamp of the last priceAvregae update (0, if never updated)\r\n     * @param _priceAverageIn ratio component of the last priceAverage of the in-token\r\n     * @param _priceAverageOut ratio component of the last priceAverage of the out-token\r\n     * @param _currentTimestamp timestamp of the priceAverage to update\r\n     * @return newPriceAverageIn_ ratio component of the updated priceAverage of the in-token\r\n     * @return newPriceAverageOut_ ratio component of the updated priceAverage of the out-token\r\n     */\r\n    function getUpdatedPriceAverage(\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint256 _priceAverageLastTimestamp,\r\n        uint256 _priceAverageIn,\r\n        uint256 _priceAverageOut,\r\n        uint256 _currentTimestamp\r\n    ) internal pure returns (uint256 newPriceAverageIn_, uint256 newPriceAverageOut_) {\r\n        require(_currentTimestamp >= _priceAverageLastTimestamp, \"SmardexPair: INVALID_TIMESTAMP\");\r\n\r\n        // very first time\r\n        if (_priceAverageLastTimestamp == 0) {\r\n            newPriceAverageIn_ = _fictiveReserveIn;\r\n            newPriceAverageOut_ = _fictiveReserveOut;\r\n        }\r\n        // another tx has been done in the same block\r\n        else if (_priceAverageLastTimestamp == _currentTimestamp) {\r\n            newPriceAverageIn_ = _priceAverageIn;\r\n            newPriceAverageOut_ = _priceAverageOut;\r\n        }\r\n        // need to compute new linear-average price\r\n        else {\r\n            // compute new price:\r\n            uint256 _timeDiff = Math.min(_currentTimestamp - _priceAverageLastTimestamp, MAX_BLOCK_DIFF_SECONDS);\r\n\r\n            newPriceAverageIn_ = _fictiveReserveIn;\r\n            newPriceAverageOut_ =\r\n                (((MAX_BLOCK_DIFF_SECONDS - _timeDiff) * _priceAverageOut * newPriceAverageIn_) /\r\n                    _priceAverageIn +\r\n                    _timeDiff *\r\n                    _fictiveReserveOut) /\r\n                MAX_BLOCK_DIFF_SECONDS;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice compute the firstTradeAmountIn so that the price reach the price Average\r\n     * @param _amountIn the amountIn requested, it's the maximum possible value for firstAmountIn_\r\n     * @param _fictiveReserveIn fictive reserve of the in-token\r\n     * @param _fictiveReserveOut fictive reserve of the out-token\r\n     * @param _priceAverageIn ratio component of the priceAverage of the in-token\r\n     * @param _priceAverageOut ratio component of the priceAverage of the out-token\r\n     * @return firstAmountIn_ the first amount of in-token\r\n     *\r\n     * @dev if the trade is going in the direction that the price will never reach the priceAverage, or if _amountIn\r\n     * is not big enough to reach the priceAverage or if the price is already equal to the priceAverage, then\r\n     * firstAmountIn_ will be set to _amountIn\r\n     */\r\n    function computeFirstTradeQtyIn(\r\n        uint256 _amountIn,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint256 _priceAverageIn,\r\n        uint256 _priceAverageOut\r\n    ) internal pure returns (uint256 firstAmountIn_) {\r\n        // default value\r\n        firstAmountIn_ = _amountIn;\r\n\r\n        // if trade is in the good direction\r\n        if (_fictiveReserveOut * _priceAverageIn > _fictiveReserveIn * _priceAverageOut) {\r\n            // pre-compute all operands\r\n            uint256 _toSub = _fictiveReserveIn * (FEES_BASE + REVERSE_FEES_TOTAL - FEES_POOL);\r\n            uint256 _toDiv = (REVERSE_FEES_TOTAL + FEES_LP) << 1;\r\n            uint256 _inSqrt = (((_fictiveReserveIn * _fictiveReserveOut) << 2) / _priceAverageOut) *\r\n                _priceAverageIn *\r\n                (REVERSE_FEES_TOTAL * (FEES_BASE - FEES_POOL)) +\r\n                (_fictiveReserveIn * _fictiveReserveIn * (FEES_LP * FEES_LP));\r\n\r\n            // reverse sqrt check to only compute sqrt if really needed\r\n            if (_inSqrt < (_toSub + _amountIn * _toDiv) ** 2) {\r\n                firstAmountIn_ = (Math.sqrt(_inSqrt) - _toSub) / _toDiv;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice compute the firstTradeAmountOut so that the price reach the price Average\r\n     * @param _amountOut the amountOut requested, it's the maximum possible value for firstAmountOut_\r\n     * @param _fictiveReserveIn fictive reserve of the in-token\r\n     * @param _fictiveReserveOut fictive reserve of the out-token\r\n     * @param _priceAverageIn ratio component of the priceAverage of the in-token\r\n     * @param _priceAverageOut ratio component of the priceAverage of the out-token\r\n     * @return firstAmountOut_ the first amount of out-token\r\n     *\r\n     * @dev if the trade is going in the direction that the price will never reach the priceAverage, or if _amountOut\r\n     * is not big enough to reach the priceAverage or if the price is already equal to the priceAverage, then\r\n     * firstAmountOut_ will be set to _amountOut\r\n     */\r\n    function computeFirstTradeQtyOut(\r\n        uint256 _amountOut,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint256 _priceAverageIn,\r\n        uint256 _priceAverageOut\r\n    ) internal pure returns (uint256 firstAmountOut_) {\r\n        // default value\r\n        firstAmountOut_ = _amountOut;\r\n\r\n        // if trade is in the good direction\r\n        if (_fictiveReserveOut * _priceAverageIn > _fictiveReserveIn * _priceAverageOut) {\r\n            // pre-compute all operands\r\n            uint256 _fictiveReserveOutPredFees = (_fictiveReserveIn * FEES_LP * _priceAverageOut) / _priceAverageIn;\r\n            uint256 _toAdd = ((_fictiveReserveOut * REVERSE_FEES_TOTAL) << 1) + _fictiveReserveOutPredFees;\r\n            uint256 _toDiv = REVERSE_FEES_TOTAL << 1;\r\n            uint256 _inSqrt = (((_fictiveReserveOut * _fictiveReserveOutPredFees) << 2) *\r\n                (REVERSE_FEES_TOTAL * (FEES_BASE - FEES_POOL))) /\r\n                FEES_LP +\r\n                _fictiveReserveOutPredFees *\r\n                _fictiveReserveOutPredFees;\r\n\r\n            // reverse sqrt check to only compute sqrt if really needed\r\n            if (_inSqrt > (_toAdd - _amountOut * _toDiv) ** 2) {\r\n                firstAmountOut_ = (_toAdd - Math.sqrt(_inSqrt)) / _toDiv;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice compute fictive reserves\r\n     * @param _reserveIn reserve of the in-token\r\n     * @param _reserveOut reserve of the out-token\r\n     * @param _fictiveReserveIn fictive reserve of the in-token\r\n     * @param _fictiveReserveOut fictive reserve of the out-token\r\n     * @return newFictiveReserveIn_ new fictive reserve of the in-token\r\n     * @return newFictiveReserveOut_ new fictive reserve of the out-token\r\n     */\r\n    function computeFictiveReserves(\r\n        uint256 _reserveIn,\r\n        uint256 _reserveOut,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut\r\n    ) internal pure returns (uint256 newFictiveReserveIn_, uint256 newFictiveReserveOut_) {\r\n        if (_reserveOut * _fictiveReserveIn < _reserveIn * _fictiveReserveOut) {\r\n            uint256 _temp = (((_reserveOut * _reserveOut) / _fictiveReserveOut) * _fictiveReserveIn) / _reserveIn;\r\n            newFictiveReserveIn_ =\r\n                (_temp * _fictiveReserveIn) /\r\n                _fictiveReserveOut +\r\n                (_reserveOut * _fictiveReserveIn) /\r\n                _fictiveReserveOut;\r\n            newFictiveReserveOut_ = _reserveOut + _temp;\r\n        } else {\r\n            newFictiveReserveIn_ = (_fictiveReserveIn * _reserveOut) / _fictiveReserveOut + _reserveIn;\r\n            newFictiveReserveOut_ = (_reserveIn * _fictiveReserveOut) / _fictiveReserveIn + _reserveOut;\r\n        }\r\n\r\n        // div all values by 4\r\n        newFictiveReserveIn_ >>= 2;\r\n        newFictiveReserveOut_ >>= 2;\r\n    }\r\n\r\n    /**\r\n     * @notice apply k const rule using fictive reserve, when the amountIn is specified\r\n     * @param _amountIn qty of token that arrives in the contract\r\n     * @param _reserveIn reserve of the in-token\r\n     * @param _reserveOut reserve of the out-token\r\n     * @param _fictiveReserveIn fictive reserve of the in-token\r\n     * @param _fictiveReserveOut fictive reserve of the out-token\r\n     * @return amountOut_ qty of token that leaves in the contract\r\n     * @return newReserveIn_ new reserve of the in-token after the transaction\r\n     * @return newReserveOut_ new reserve of the out-token after the transaction\r\n     * @return newFictiveReserveIn_ new fictive reserve of the in-token after the transaction\r\n     * @return newFictiveReserveOut_ new fictive reserve of the out-token after the transaction\r\n     */\r\n    function applyKConstRuleOut(\r\n        uint256 _amountIn,\r\n        uint256 _reserveIn,\r\n        uint256 _reserveOut,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 amountOut_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        // k const rule\r\n        uint256 _amountInWithFee = _amountIn * REVERSE_FEES_TOTAL;\r\n        uint256 _numerator = _amountInWithFee * _fictiveReserveOut;\r\n        uint256 _denominator = _fictiveReserveIn * FEES_BASE + _amountInWithFee;\r\n        amountOut_ = _numerator / _denominator;\r\n\r\n        // update new reserves and add lp-fees to pools\r\n        uint256 _amountInWithFeeLp = (_amountInWithFee + (_amountIn * FEES_LP)) / FEES_BASE;\r\n        newReserveIn_ = _reserveIn + _amountInWithFeeLp;\r\n        newFictiveReserveIn_ = _fictiveReserveIn + _amountInWithFeeLp;\r\n        newReserveOut_ = _reserveOut - amountOut_;\r\n        newFictiveReserveOut_ = _fictiveReserveOut - amountOut_;\r\n    }\r\n\r\n    /**\r\n     * @notice apply k const rule using fictive reserve, when the amountOut is specified\r\n     * @param _amountOut qty of token that leaves in the contract\r\n     * @param _reserveIn reserve of the in-token\r\n     * @param _reserveOut reserve of the out-token\r\n     * @param _fictiveReserveIn fictive reserve of the in-token\r\n     * @param _fictiveReserveOut fictive reserve of the out-token\r\n     * @return amountIn_ qty of token that arrives in the contract\r\n     * @return newReserveIn_ new reserve of the in-token after the transaction\r\n     * @return newReserveOut_ new reserve of the out-token after the transaction\r\n     * @return newFictiveReserveIn_ new fictive reserve of the in-token after the transaction\r\n     * @return newFictiveReserveOut_ new fictive reserve of the out-token after the transaction\r\n     */\r\n    function applyKConstRuleIn(\r\n        uint256 _amountOut,\r\n        uint256 _reserveIn,\r\n        uint256 _reserveOut,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 amountIn_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        // k const rule\r\n        uint256 _numerator = _fictiveReserveIn * _amountOut * FEES_BASE;\r\n        uint256 _denominator = (_fictiveReserveOut - _amountOut) * REVERSE_FEES_TOTAL;\r\n        amountIn_ = _numerator / _denominator + 1;\r\n\r\n        // update new reserves\r\n        uint256 _amountInWithFeeLp = (amountIn_ * (REVERSE_FEES_TOTAL + FEES_LP)) / FEES_BASE;\r\n        newReserveIn_ = _reserveIn + _amountInWithFeeLp;\r\n        newFictiveReserveIn_ = _fictiveReserveIn + _amountInWithFeeLp;\r\n        newReserveOut_ = _reserveOut - _amountOut;\r\n        newFictiveReserveOut_ = _fictiveReserveOut - _amountOut;\r\n    }\r\n\r\n    /**\r\n     * @notice return the amount of tokens the user would get by doing a swap\r\n     * @param _amountIn quantity of token the user want to swap (to sell)\r\n     * @param _reserveIn reserves of the selling token (getReserve())\r\n     * @param _reserveOut reserves of the buying token (getReserve())\r\n     * @param _fictiveReserveIn fictive reserve of the selling token (getFictiveReserves())\r\n     * @param _fictiveReserveOut fictive reserve of the buying token (getFictiveReserves())\r\n     * @param _priceAverageIn price average of the selling token\r\n     * @param _priceAverageOut price average of the buying token\r\n     * @return amountOut_ The amount of token the user would receive\r\n     * @return newReserveIn_ reserves of the selling token after the swap\r\n     * @return newReserveOut_ reserves of the buying token after the swap\r\n     * @return newFictiveReserveIn_ fictive reserve of the selling token after the swap\r\n     * @return newFictiveReserveOut_ fictive reserve of the buying token after the swap\r\n     */\r\n    function getAmountOut(\r\n        uint256 _amountIn,\r\n        uint256 _reserveIn,\r\n        uint256 _reserveOut,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint256 _priceAverageIn,\r\n        uint256 _priceAverageOut\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 amountOut_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        require(_amountIn > 0, \"SmarDexLibrary: INSUFFICIENT_INPUT_AMOUNT\");\r\n        require(\r\n            _reserveIn > 0 && _reserveOut > 0 && _fictiveReserveIn > 0 && _fictiveReserveOut > 0,\r\n            \"SmarDexLibrary: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n\r\n        uint256 _amountInWithFees = (_amountIn * REVERSE_FEES_TOTAL) / FEES_BASE;\r\n        uint256 _firstAmountIn = computeFirstTradeQtyIn(\r\n            _amountInWithFees,\r\n            _fictiveReserveIn,\r\n            _fictiveReserveOut,\r\n            _priceAverageIn,\r\n            _priceAverageOut\r\n        );\r\n\r\n        // if there is 2 trade: 1st trade mustn't re-compute fictive reserves, 2nd should\r\n        if (\r\n            _firstAmountIn == _amountInWithFees &&\r\n            ratioApproxEq(_fictiveReserveIn, _fictiveReserveOut, _priceAverageIn, _priceAverageOut)\r\n        ) {\r\n            (_fictiveReserveIn, _fictiveReserveOut) = computeFictiveReserves(\r\n                _reserveIn,\r\n                _reserveOut,\r\n                _fictiveReserveIn,\r\n                _fictiveReserveOut\r\n            );\r\n        }\r\n\r\n        // avoid stack too deep\r\n        {\r\n            uint256 _firstAmountInNoFees = (_firstAmountIn * FEES_BASE) / REVERSE_FEES_TOTAL;\r\n            (\r\n                amountOut_,\r\n                newReserveIn_,\r\n                newReserveOut_,\r\n                newFictiveReserveIn_,\r\n                newFictiveReserveOut_\r\n            ) = applyKConstRuleOut(\r\n                _firstAmountInNoFees,\r\n                _reserveIn,\r\n                _reserveOut,\r\n                _fictiveReserveIn,\r\n                _fictiveReserveOut\r\n            );\r\n\r\n            // update amountIn in case there is a second trade\r\n            _amountIn -= _firstAmountInNoFees;\r\n        }\r\n\r\n        // if we need a second trade\r\n        if (_firstAmountIn < _amountInWithFees) {\r\n            // in the second trade ALWAYS recompute fictive reserves\r\n            (newFictiveReserveIn_, newFictiveReserveOut_) = computeFictiveReserves(\r\n                newReserveIn_,\r\n                newReserveOut_,\r\n                newFictiveReserveIn_,\r\n                newFictiveReserveOut_\r\n            );\r\n\r\n            uint256 _secondAmountOutNoFees;\r\n            (\r\n                _secondAmountOutNoFees,\r\n                newReserveIn_,\r\n                newReserveOut_,\r\n                newFictiveReserveIn_,\r\n                newFictiveReserveOut_\r\n            ) = applyKConstRuleOut(\r\n                _amountIn,\r\n                newReserveIn_,\r\n                newReserveOut_,\r\n                newFictiveReserveIn_,\r\n                newFictiveReserveOut_\r\n            );\r\n            amountOut_ += _secondAmountOutNoFees;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice return the amount of tokens the user should spend by doing a swap\r\n     * @param _amountOut quantity of token the user want to swap (to buy)\r\n     * @param _reserveIn reserves of the selling token (getReserve())\r\n     * @param _reserveOut reserves of the buying token (getReserve())\r\n     * @param _fictiveReserveIn fictive reserve of the selling token (getFictiveReserves())\r\n     * @param _fictiveReserveOut fictive reserve of the buying token (getFictiveReserves())\r\n     * @param _priceAverageIn price average of the selling token\r\n     * @param _priceAverageOut price average of the buying token\r\n     * @return amountIn_ The amount of token the user would spend to receive _amountOut\r\n     * @return newReserveIn_ reserves of the selling token after the swap\r\n     * @return newReserveOut_ reserves of the buying token after the swap\r\n     * @return newFictiveReserveIn_ fictive reserve of the selling token after the swap\r\n     * @return newFictiveReserveOut_ fictive reserve of the buying token after the swap\r\n     */\r\n    function getAmountIn(\r\n        uint256 _amountOut,\r\n        uint256 _reserveIn,\r\n        uint256 _reserveOut,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint256 _priceAverageIn,\r\n        uint256 _priceAverageOut\r\n    )\r\n        internal\r\n        pure\r\n        returns (\r\n            uint256 amountIn_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        require(_amountOut > 0, \"SmarDexLibrary: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n        require(\r\n            _amountOut < _fictiveReserveOut &&\r\n                _reserveIn > 0 &&\r\n                _reserveOut > 0 &&\r\n                _fictiveReserveIn > 0 &&\r\n                _fictiveReserveOut > 0,\r\n            \"SmarDexLibrary: INSUFFICIENT_LIQUIDITY\"\r\n        );\r\n\r\n        uint256 _firstAmountOut = computeFirstTradeQtyOut(\r\n            _amountOut,\r\n            _fictiveReserveIn,\r\n            _fictiveReserveOut,\r\n            _priceAverageIn,\r\n            _priceAverageOut\r\n        );\r\n\r\n        // if there is 2 trade: 1st trade mustn't re-compute fictive reserves, 2nd should\r\n        if (\r\n            _firstAmountOut == _amountOut &&\r\n            ratioApproxEq(_fictiveReserveIn, _fictiveReserveOut, _priceAverageIn, _priceAverageOut)\r\n        ) {\r\n            (_fictiveReserveIn, _fictiveReserveOut) = computeFictiveReserves(\r\n                _reserveIn,\r\n                _reserveOut,\r\n                _fictiveReserveIn,\r\n                _fictiveReserveOut\r\n            );\r\n        }\r\n\r\n        (amountIn_, newReserveIn_, newReserveOut_, newFictiveReserveIn_, newFictiveReserveOut_) = applyKConstRuleIn(\r\n            _firstAmountOut,\r\n            _reserveIn,\r\n            _reserveOut,\r\n            _fictiveReserveIn,\r\n            _fictiveReserveOut\r\n        );\r\n\r\n        // if we need a second trade\r\n        if (_firstAmountOut < _amountOut) {\r\n            // in the second trade ALWAYS recompute fictive reserves\r\n            (newFictiveReserveIn_, newFictiveReserveOut_) = computeFictiveReserves(\r\n                newReserveIn_,\r\n                newReserveOut_,\r\n                newFictiveReserveIn_,\r\n                newFictiveReserveOut_\r\n            );\r\n\r\n            uint256 _secondAmountIn;\r\n            (\r\n                _secondAmountIn,\r\n                newReserveIn_,\r\n                newReserveOut_,\r\n                newFictiveReserveIn_,\r\n                newFictiveReserveOut_\r\n            ) = applyKConstRuleIn(\r\n                _amountOut - _firstAmountOut,\r\n                newReserveIn_,\r\n                newReserveOut_,\r\n                newFictiveReserveIn_,\r\n                newFictiveReserveOut_\r\n            );\r\n            amountIn_ += _secondAmountIn;\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/core/test/coreV1/SmardexFactoryV1.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// contracts\r\nimport \"./SmardexPairV1.sol\";\r\n\r\n// interfaces\r\nimport \"./interfaces/ISmardexFactoryV1.sol\";\r\n\r\n/**\r\n * @title SmardexFactory\r\n * @notice facilitates creation of SmardexPair to swap tokens.\r\n */\r\ncontract SmardexFactoryV1 is ISmardexFactoryV1 {\r\n    address public feeTo;\r\n    address public feeToSetter;\r\n\r\n    mapping(address => mapping(address => address)) public getPair;\r\n    address[] public allPairs;\r\n\r\n    constructor(address _feeToSetter) {\r\n        feeToSetter = _feeToSetter;\r\n    }\r\n\r\n    function allPairsLength() external view returns (uint256) {\r\n        return allPairs.length;\r\n    }\r\n\r\n    function createPair(address _tokenA, address _tokenB) external returns (address pair_) {\r\n        require(_tokenA != _tokenB, \"SmarDex: IDENTICAL_ADDRESSES\");\r\n        (address _token0, address _token1) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\r\n        require(_token0 != address(0), \"SmarDex: ZERO_ADDRESS\");\r\n        require(getPair[_token0][_token1] == address(0), \"SmarDex: PAIR_EXISTS\"); // single check is sufficient\r\n        bytes32 _salt = keccak256(abi.encodePacked(_token0, _token1));\r\n        SmardexPairV1 pair = new SmardexPairV1{ salt: _salt }();\r\n        pair.initialize(_token0, _token1);\r\n        pair_ = address(pair);\r\n        getPair[_token0][_token1] = pair_;\r\n        getPair[_token1][_token0] = pair_; // populate mapping in the reverse direction\r\n        allPairs.push(pair_);\r\n        emit PairCreated(_token0, _token1, pair_, allPairs.length);\r\n    }\r\n\r\n    function setFeeTo(address _feeTo) external {\r\n        require(msg.sender == feeToSetter, \"SmarDex: FORBIDDEN\");\r\n        feeTo = _feeTo;\r\n    }\r\n\r\n    function setFeeToSetter(address _feeToSetter) external {\r\n        require(msg.sender == feeToSetter, \"SmarDex: FORBIDDEN\");\r\n        feeToSetter = _feeToSetter;\r\n    }\r\n}\r\n"
    },
    "contracts/core/test/coreV1/SmardexPairV1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// contracts\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-ERC20Permit.sol\";\r\n\r\n// libraries\r\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\r\nimport \"./libraries/SmardexLibraryV1.sol\";\r\nimport \"../../libraries/TransferHelper.sol\";\r\n\r\n// interfaces\r\nimport \"./interfaces/ISmardexPairV1.sol\";\r\nimport \"./interfaces/ISmardexFactoryV1.sol\";\r\nimport \"./interfaces/ISmardexSwapCallbackV1.sol\";\r\nimport \"../../interfaces/ISmardexMintCallback.sol\";\r\n\r\n/**\r\n * @title SmardexPair\r\n * @notice Pair contract that allows user to swap 2 ERC20-strict tokens in a decentralised and automated way\r\n */\r\ncontract SmardexPairV1 is ISmardexPairV1, ERC20Permit {\r\n    using SafeCast for uint256;\r\n    using SafeCast for int256;\r\n\r\n    /**\r\n     * @notice swap parameters used by function swap\r\n     * @param amountCalculated return amount from getAmountIn/Out is always positive but to avoid too much cast, is int\r\n     * @param fictiveReserveIn fictive reserve of the in-token of the pair\r\n     * @param fictiveReserveOut fictive reserve of the out-token of the pair\r\n     * @param priceAverageIn in-token ratio component of the price average\r\n     * @param priceAverageOut out-token ratio component of the price average\r\n     * @param token0 address of the token0\r\n     * @param token1 address of the token1\r\n     * @param balanceIn contract balance of the in-token\r\n     * @param balanceOut contract balance of the out-token\r\n     */\r\n    struct SwapParams {\r\n        int256 amountCalculated;\r\n        uint256 fictiveReserveIn;\r\n        uint256 fictiveReserveOut;\r\n        uint256 priceAverageIn;\r\n        uint256 priceAverageOut;\r\n        address token0;\r\n        address token1;\r\n        uint256 balanceIn;\r\n        uint256 balanceOut;\r\n    }\r\n\r\n    uint8 private constant CONTRACT_UNLOCKED = 1;\r\n    uint8 private constant CONTRACT_LOCKED = 2;\r\n    uint256 private constant MINIMUM_LIQUIDITY = 10 ** 3;\r\n    bytes4 private constant AUTOSWAP_SELECTOR = bytes4(keccak256(bytes(\"executeWork(address,address)\")));\r\n\r\n    address public factory;\r\n    address public token0;\r\n    address public token1;\r\n\r\n    // smardex new fictive reserves\r\n    uint128 internal fictiveReserve0;\r\n    uint128 internal fictiveReserve1; // accessible via getFictiveReserves()\r\n\r\n    // moving average on the price\r\n    uint128 internal priceAverage0;\r\n    uint128 internal priceAverage1;\r\n    uint40 internal priceAverageLastTimestamp; // accessible via getPriceAverage()\r\n\r\n    // fee for FEE_POOL\r\n    uint104 internal feeToAmount0;\r\n    uint104 internal feeToAmount1; // accessible via getFees()\r\n\r\n    // reentrancy\r\n    uint8 private lockStatus = CONTRACT_UNLOCKED;\r\n\r\n    modifier lock() {\r\n        require(lockStatus == CONTRACT_UNLOCKED, \"SmarDex: LOCKED\");\r\n        lockStatus = CONTRACT_LOCKED;\r\n        _;\r\n        lockStatus = CONTRACT_UNLOCKED;\r\n    }\r\n\r\n    constructor() ERC20(\"SmarDex LP-Token\", \"SDEX-LP\") ERC20Permit(\"SmarDex LP-Token\") {\r\n        factory = msg.sender;\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPairV1\r\n    function initialize(address _token0, address _token1) external override {\r\n        require(msg.sender == factory, \"SmarDex: FORBIDDEN\"); // sufficient check\r\n        token0 = _token0;\r\n        token1 = _token1;\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPairV1\r\n    function getReserves() external view override returns (uint256 reserve0_, uint256 reserve1_) {\r\n        reserve0_ = IERC20(token0).balanceOf(address(this)) - feeToAmount0;\r\n        reserve1_ = IERC20(token1).balanceOf(address(this)) - feeToAmount1;\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPairV1\r\n    function getFictiveReserves() external view override returns (uint256 fictiveReserve0_, uint256 fictiveReserve1_) {\r\n        fictiveReserve0_ = fictiveReserve0;\r\n        fictiveReserve1_ = fictiveReserve1;\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPairV1\r\n    function getFees() external view override returns (uint256 fees0_, uint256 fees1_) {\r\n        fees0_ = feeToAmount0;\r\n        fees1_ = feeToAmount1;\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPairV1\r\n    function getPriceAverage()\r\n        external\r\n        view\r\n        returns (uint256 priceAverage0_, uint256 priceAverage1_, uint256 priceAverageLastTimestamp_)\r\n    {\r\n        priceAverage0_ = priceAverage0;\r\n        priceAverage1_ = priceAverage1;\r\n        priceAverageLastTimestamp_ = priceAverageLastTimestamp;\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPairV1\r\n    function getUpdatedPriceAverage(\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint256 _priceAverageLastTimestamp,\r\n        uint256 _priceAverageIn,\r\n        uint256 _priceAverageOut,\r\n        uint256 _currentTimestamp\r\n    ) public pure returns (uint256 priceAverageIn_, uint256 priceAverageOut_) {\r\n        (priceAverageIn_, priceAverageOut_) = SmardexLibraryV1.getUpdatedPriceAverage(\r\n            _fictiveReserveIn,\r\n            _fictiveReserveOut,\r\n            _priceAverageLastTimestamp,\r\n            _priceAverageIn,\r\n            _priceAverageOut,\r\n            _currentTimestamp\r\n        );\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPairV1\r\n    function mint(\r\n        address _to,\r\n        uint256 _amount0,\r\n        uint256 _amount1,\r\n        address _payer\r\n    ) external override returns (uint256 liquidity_) {\r\n        liquidity_ = _mintBeforeFee(_to, _amount0, _amount1, _payer);\r\n\r\n        // we call feeTo out of the internal locked mint (_mintExt) function to be able to swap fees in here\r\n        _feeToSwap();\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPairV1\r\n    function burn(address _to) external override returns (uint256 amount0_, uint256 amount1_) {\r\n        (amount0_, amount1_) = _burnBeforeFee(_to);\r\n\r\n        // we call feeTo out of the internal locked burn (_burnExt) function to be able to swap fees in here\r\n        _feeToSwap();\r\n    }\r\n\r\n    ///@inheritdoc ISmardexPairV1\r\n    function swap(\r\n        address _to,\r\n        bool _zeroForOne,\r\n        int256 _amountSpecified,\r\n        bytes calldata _data\r\n    ) external override lock returns (int256 amount0_, int256 amount1_) {\r\n        require(_amountSpecified != 0, \"SmarDex: ZERO_AMOUNT\");\r\n\r\n        SwapParams memory _params = SwapParams({\r\n            amountCalculated: 0,\r\n            fictiveReserveIn: 0,\r\n            fictiveReserveOut: 0,\r\n            priceAverageIn: 0,\r\n            priceAverageOut: 0,\r\n            token0: token0,\r\n            token1: token1,\r\n            balanceIn: 0,\r\n            balanceOut: 0\r\n        });\r\n\r\n        (\r\n            _params.balanceIn,\r\n            _params.balanceOut,\r\n            _params.fictiveReserveIn,\r\n            _params.fictiveReserveOut,\r\n            _params.priceAverageIn,\r\n            _params.priceAverageOut\r\n        ) = _zeroForOne\r\n            ? (\r\n                IERC20(_params.token0).balanceOf(address(this)) - feeToAmount0,\r\n                IERC20(_params.token1).balanceOf(address(this)) - feeToAmount1,\r\n                fictiveReserve0,\r\n                fictiveReserve1,\r\n                priceAverage0,\r\n                priceAverage1\r\n            )\r\n            : (\r\n                IERC20(_params.token1).balanceOf(address(this)) - feeToAmount1,\r\n                IERC20(_params.token0).balanceOf(address(this)) - feeToAmount0,\r\n                fictiveReserve1,\r\n                fictiveReserve0,\r\n                priceAverage1,\r\n                priceAverage0\r\n            );\r\n\r\n        // compute new price average\r\n        (_params.priceAverageIn, _params.priceAverageOut) = SmardexLibraryV1.getUpdatedPriceAverage(\r\n            _params.fictiveReserveIn,\r\n            _params.fictiveReserveOut,\r\n            priceAverageLastTimestamp,\r\n            _params.priceAverageIn,\r\n            _params.priceAverageOut,\r\n            block.timestamp\r\n        );\r\n\r\n        // SSTORE new price average\r\n        (priceAverage0, priceAverage1, priceAverageLastTimestamp) = _zeroForOne\r\n            ? (_params.priceAverageIn.toUint128(), _params.priceAverageOut.toUint128(), uint40(block.timestamp))\r\n            : (_params.priceAverageOut.toUint128(), _params.priceAverageIn.toUint128(), uint40(block.timestamp));\r\n\r\n        if (_amountSpecified > 0) {\r\n            uint256 _temp;\r\n            (_temp, , , _params.fictiveReserveIn, _params.fictiveReserveOut) = SmardexLibraryV1.getAmountOut(\r\n                _amountSpecified.toUint256(),\r\n                _params.balanceIn,\r\n                _params.balanceOut,\r\n                _params.fictiveReserveIn,\r\n                _params.fictiveReserveOut,\r\n                _params.priceAverageIn,\r\n                _params.priceAverageOut\r\n            );\r\n            _params.amountCalculated = _temp.toInt256();\r\n        } else {\r\n            uint256 _temp;\r\n            (_temp, , , _params.fictiveReserveIn, _params.fictiveReserveOut) = SmardexLibraryV1.getAmountIn(\r\n                (-_amountSpecified).toUint256(),\r\n                _params.balanceIn,\r\n                _params.balanceOut,\r\n                _params.fictiveReserveIn,\r\n                _params.fictiveReserveOut,\r\n                _params.priceAverageIn,\r\n                _params.priceAverageOut\r\n            );\r\n            _params.amountCalculated = _temp.toInt256();\r\n        }\r\n\r\n        (amount0_, amount1_) = _zeroForOne\r\n            ? (\r\n                _amountSpecified > 0\r\n                    ? (_amountSpecified, -_params.amountCalculated)\r\n                    : (_params.amountCalculated, _amountSpecified)\r\n            )\r\n            : (\r\n                _amountSpecified > 0\r\n                    ? (-_params.amountCalculated, _amountSpecified)\r\n                    : (_amountSpecified, _params.amountCalculated)\r\n            );\r\n\r\n        require(_to != _params.token0 && _to != _params.token1, \"SmarDex: INVALID_TO\");\r\n        if (_zeroForOne) {\r\n            if (amount1_ < 0) {\r\n                TransferHelper.safeTransfer(_params.token1, _to, uint256(-amount1_));\r\n            }\r\n            ISmardexSwapCallbackV1(msg.sender).smardexSwapCallback(amount0_, amount1_, _data);\r\n            uint256 _balanceInBefore = _params.balanceIn;\r\n            _params.balanceIn = IERC20(token0).balanceOf(address(this));\r\n            require(\r\n                _balanceInBefore + feeToAmount0 + (amount0_).toUint256() <= _params.balanceIn,\r\n                \"SmarDex: INSUFFICIENT_TOKEN0_INPUT_AMOUNT\"\r\n            );\r\n            _params.balanceOut = IERC20(token1).balanceOf(address(this));\r\n        } else {\r\n            if (amount0_ < 0) {\r\n                TransferHelper.safeTransfer(_params.token0, _to, uint256(-amount0_));\r\n            }\r\n            ISmardexSwapCallbackV1(msg.sender).smardexSwapCallback(amount0_, amount1_, _data);\r\n            uint256 _balanceInBefore = _params.balanceIn;\r\n            _params.balanceIn = IERC20(token1).balanceOf(address(this));\r\n            require(\r\n                _balanceInBefore + feeToAmount1 + (amount1_).toUint256() <= _params.balanceIn,\r\n                \"SmarDex: INSUFFICIENT_TOKEN1_INPUT_AMOUNT\"\r\n            );\r\n            _params.balanceOut = IERC20(token0).balanceOf(address(this));\r\n        }\r\n\r\n        // update feeTopart\r\n        bool _feeOn = ISmardexFactoryV1(factory).feeTo() != address(0);\r\n        if (_zeroForOne) {\r\n            if (_feeOn) {\r\n                feeToAmount0 += ((uint256(amount0_) * SmardexLibraryV1.FEES_POOL) / SmardexLibraryV1.FEES_BASE)\r\n                    .toUint104();\r\n            }\r\n            _update(\r\n                _params.balanceIn,\r\n                _params.balanceOut,\r\n                _params.fictiveReserveIn,\r\n                _params.fictiveReserveOut,\r\n                _params.priceAverageIn,\r\n                _params.priceAverageOut\r\n            );\r\n        } else {\r\n            if (_feeOn) {\r\n                feeToAmount1 += ((uint256(amount1_) * SmardexLibraryV1.FEES_POOL) / SmardexLibraryV1.FEES_BASE)\r\n                    .toUint104();\r\n            }\r\n            _update(\r\n                _params.balanceOut,\r\n                _params.balanceIn,\r\n                _params.fictiveReserveOut,\r\n                _params.fictiveReserveIn,\r\n                _params.priceAverageOut,\r\n                _params.priceAverageIn\r\n            );\r\n        }\r\n\r\n        emit Swap(msg.sender, _to, amount0_, amount1_);\r\n    }\r\n\r\n    /**\r\n     * @notice update fictive reserves and emit the Sync event\r\n     * @param _balance0 the new balance of token0\r\n     * @param _balance1 the new balance of token1\r\n     * @param _fictiveReserve0 the new fictive reserves of token0\r\n     * @param _fictiveReserve1 the new fictive reserves of token1\r\n     * @param _priceAverage0 the new priceAverage of token0\r\n     * @param _priceAverage1 the new priceAverage of token1\r\n     */\r\n    function _update(\r\n        uint256 _balance0,\r\n        uint256 _balance1,\r\n        uint256 _fictiveReserve0,\r\n        uint256 _fictiveReserve1,\r\n        uint256 _priceAverage0,\r\n        uint256 _priceAverage1\r\n    ) private {\r\n        require(_fictiveReserve0 > 0 && _fictiveReserve1 > 0, \"SmarDex: FICTIVE_RESERVES_TOO_LOW\");\r\n        require(_fictiveReserve0 <= type(uint128).max && _fictiveReserve1 <= type(uint128).max, \"SmarDex: OVERFLOW\");\r\n        fictiveReserve0 = uint128(_fictiveReserve0);\r\n        fictiveReserve1 = uint128(_fictiveReserve1);\r\n\r\n        emit Sync(\r\n            _balance0 - feeToAmount0,\r\n            _balance1 - feeToAmount1,\r\n            _fictiveReserve0,\r\n            _fictiveReserve1,\r\n            _priceAverage0,\r\n            _priceAverage1\r\n        );\r\n    }\r\n\r\n    /**\r\n     * @notice transfers feeToAmount of tokens 0 and 1 to feeTo, and reset feeToAmounts\r\n     * @return feeOn_ if part of the fees goes to feeTo\r\n     */\r\n    function _mintFee() private returns (bool feeOn_) {\r\n        address _feeTo = ISmardexFactoryV1(factory).feeTo();\r\n        feeOn_ = _feeTo != address(0);\r\n        if (feeOn_) {\r\n            // gas saving\r\n            uint256 _feeToAmount0 = feeToAmount0;\r\n            uint256 _feeToAmount1 = feeToAmount1;\r\n\r\n            if (_feeToAmount0 > 0) {\r\n                TransferHelper.safeTransfer(token0, _feeTo, _feeToAmount0);\r\n                feeToAmount0 = 0;\r\n            }\r\n            if (_feeToAmount1 > 0) {\r\n                TransferHelper.safeTransfer(token1, _feeTo, _feeToAmount1);\r\n                feeToAmount1 = 0;\r\n            }\r\n        } else {\r\n            feeToAmount0 = 0;\r\n            feeToAmount1 = 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Mint lp tokens proportionally of added tokens in balance.\r\n     * @param _to address who will receive minted tokens\r\n     * @param _amount0 amount of token0 to provide\r\n     * @param _amount1 amount of token1 to provide\r\n     * @param _payer address of the payer to provide token for the mint\r\n     * @return liquidity_ amount of lp tokens minted and sent to the address defined in parameter\r\n     */\r\n    function _mintBeforeFee(\r\n        address _to,\r\n        uint256 _amount0,\r\n        uint256 _amount1,\r\n        address _payer\r\n    ) internal lock returns (uint256 liquidity_) {\r\n        _mintFee();\r\n\r\n        uint256 _fictiveReserve0;\r\n        uint256 _fictiveReserve1;\r\n\r\n        // gas saving\r\n        uint256 _balance0 = IERC20(token0).balanceOf(address(this));\r\n        uint256 _balance1 = IERC20(token1).balanceOf(address(this));\r\n        uint256 _totalSupply = totalSupply();\r\n\r\n        ISmardexMintCallback(msg.sender).smardexMintCallback(\r\n            ISmardexMintCallback.MintCallbackData({\r\n                token0: token0,\r\n                token1: token1,\r\n                amount0: _amount0,\r\n                amount1: _amount1,\r\n                payer: _payer\r\n            })\r\n        );\r\n\r\n        // gas savings\r\n        uint256 _balance0after = IERC20(token0).balanceOf(address(this));\r\n        uint256 _balance1after = IERC20(token1).balanceOf(address(this));\r\n\r\n        require(_balance0after >= _balance0 + _amount0, \"SmarDex: INSUFFICIENT_AMOUNT_0\");\r\n        require(_balance1after >= _balance1 + _amount1, \"SmarDex: INSUFFICIENT_AMOUNT_1\");\r\n\r\n        if (_totalSupply == 0) {\r\n            liquidity_ = Math.sqrt(_amount0 * _amount1) - MINIMUM_LIQUIDITY;\r\n            _mint(address(0xdead), MINIMUM_LIQUIDITY); // permanently lock the first MINIMUM_LIQUIDITY tokens\r\n            _fictiveReserve0 = _balance0after / 2;\r\n            _fictiveReserve1 = _balance1after / 2;\r\n        } else {\r\n            liquidity_ = Math.min((_amount0 * _totalSupply) / _balance0, (_amount1 * _totalSupply) / _balance1);\r\n\r\n            // update proportionally the fictiveReserves\r\n            _fictiveReserve0 = (fictiveReserve0 * (_totalSupply + liquidity_)) / _totalSupply;\r\n            _fictiveReserve1 = (fictiveReserve1 * (_totalSupply + liquidity_)) / _totalSupply;\r\n        }\r\n\r\n        require(liquidity_ > 0, \"SmarDex: INSUFFICIENT_LIQUIDITY_MINTED\");\r\n        _mint(_to, liquidity_);\r\n\r\n        _update(_balance0after, _balance1after, _fictiveReserve0, _fictiveReserve1, priceAverage0, priceAverage1);\r\n\r\n        emit Mint(msg.sender, _to, _amount0, _amount1);\r\n    }\r\n\r\n    /**\r\n     * @notice Burn lp tokens in the balance of the contract. Sends to the defined address the amount of token0 and\r\n     * token1 proportionally of the amount burned.\r\n     * @param _to address who will receive tokens\r\n     * @return amount0_ amount of token0 sent to the address defined in parameter\r\n     * @return amount1_ amount of token0 sent to the address defined in parameter\r\n     */\r\n    function _burnBeforeFee(address _to) internal lock returns (uint256 amount0_, uint256 amount1_) {\r\n        _mintFee();\r\n\r\n        // gas savings\r\n        address _token0 = token0;\r\n        address _token1 = token1;\r\n        uint256 _balance0 = IERC20(_token0).balanceOf(address(this));\r\n        uint256 _balance1 = IERC20(_token1).balanceOf(address(this));\r\n        uint256 _liquidity = balanceOf(address(this));\r\n        uint256 _totalSupply = totalSupply();\r\n\r\n        // pro-rata distribution\r\n        amount0_ = (_liquidity * _balance0) / _totalSupply;\r\n        amount1_ = (_liquidity * _balance1) / _totalSupply;\r\n        require(amount0_ > 0 && amount1_ > 0, \"SmarDex: INSUFFICIENT_LIQUIDITY_BURNED\");\r\n\r\n        // update proportionally the fictiveReserves\r\n        uint256 _fictiveReserve0 = fictiveReserve0;\r\n        uint256 _fictiveReserve1 = fictiveReserve1;\r\n        _fictiveReserve0 -= (_fictiveReserve0 * _liquidity) / _totalSupply;\r\n        _fictiveReserve1 -= (_fictiveReserve1 * _liquidity) / _totalSupply;\r\n\r\n        _burn(address(this), _liquidity);\r\n        TransferHelper.safeTransfer(_token0, _to, amount0_);\r\n        TransferHelper.safeTransfer(_token1, _to, amount1_);\r\n\r\n        _balance0 = IERC20(_token0).balanceOf(address(this));\r\n        _balance1 = IERC20(_token1).balanceOf(address(this));\r\n\r\n        _update(_balance0, _balance1, _fictiveReserve0, _fictiveReserve1, priceAverage0, priceAverage1);\r\n\r\n        emit Burn(msg.sender, _to, amount0_, amount1_);\r\n    }\r\n\r\n    /**\r\n     * @notice execute function \"executeWork(address,address)\" of the feeTo contract. Doesn't revert tx if it reverts\r\n     */\r\n    function _feeToSwap() internal {\r\n        address _feeTo = ISmardexFactoryV1(factory).feeTo();\r\n\r\n        // call contract destination for handling fees\r\n        // We don't handle return values so it does not revert for LP if something went wrong in feeTo\r\n        _feeTo.call(abi.encodeWithSelector(AUTOSWAP_SELECTOR, token0, token1));\r\n    }\r\n}\r\n"
    },
    "contracts/core/test/coreV1/test/SmardexFactoryTestV1.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// contracts\r\nimport \"../SmardexFactoryV1.sol\";\r\nimport \"./SmardexPairTestV1.sol\";\r\n\r\ncontract SmardexFactoryTestV1 is SmardexFactoryV1 {\r\n    constructor(address owner) SmardexFactoryV1(owner) {}\r\n\r\n    function createPairTest(address _tokenA, address _tokenB) external returns (address pair_) {\r\n        require(_tokenA != _tokenB, \"SmarDex: IDENTICAL_ADDRESSES\");\r\n        (address _token0, address _token1) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\r\n        require(_token0 != address(0), \"SmarDex: ZERO_ADDRESS\");\r\n        require(getPair[_token0][_token1] == address(0), \"SmarDex: PAIR_EXISTS\"); // single check is sufficient\r\n        bytes32 _salt = keccak256(abi.encodePacked(_token0, _token1));\r\n        SmardexPairTestV1 pair = new SmardexPairTestV1{ salt: _salt }();\r\n        pair.initialize(_token0, _token1);\r\n        pair_ = address(pair);\r\n        getPair[_token0][_token1] = pair_;\r\n        getPair[_token1][_token0] = pair_; // populate mapping in the reverse direction\r\n        allPairs.push(pair_);\r\n        emit PairCreated(_token0, _token1, pair_, allPairs.length);\r\n    }\r\n}\r\n"
    },
    "contracts/core/test/coreV1/test/SmardexLibraryTestV1.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity =0.8.17;\r\n\r\n// libraries\r\nimport \"../libraries/SmardexLibraryV1.sol\";\r\n\r\ncontract SmardexLibraryTestV1 {\r\n    function approxEq(uint256 x, uint256 y) internal pure returns (bool) {\r\n        return SmardexLibraryV1.approxEq(x, y);\r\n    }\r\n\r\n    function ratioApproxEq(uint256 _xNum, uint256 _xDen, uint256 _yNum, uint256 _yDen) external pure returns (bool) {\r\n        return SmardexLibraryV1.ratioApproxEq(_xNum, _xDen, _yNum, _yDen);\r\n    }\r\n\r\n    function getUpdatedPriceAverage(\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint256 _priceAverageLastTimestamp,\r\n        uint256 _priceAverageIn,\r\n        uint256 _priceAverageOut,\r\n        uint256 _currentTimestamp\r\n    ) external pure returns (uint256 newPriceAverageIn_, uint256 newPriceAverageOut_) {\r\n        return\r\n            SmardexLibraryV1.getUpdatedPriceAverage(\r\n                _fictiveReserveIn,\r\n                _fictiveReserveOut,\r\n                _priceAverageLastTimestamp,\r\n                _priceAverageIn,\r\n                _priceAverageOut,\r\n                _currentTimestamp\r\n            );\r\n    }\r\n\r\n    function computeFirstTradeQtyIn(\r\n        uint256 _amountIn,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint256 _priceAverageIn,\r\n        uint256 _priceAverageOut\r\n    ) external pure returns (uint256 firstAmountIn_) {\r\n        return\r\n            SmardexLibraryV1.computeFirstTradeQtyIn(\r\n                _amountIn,\r\n                _fictiveReserveIn,\r\n                _fictiveReserveOut,\r\n                _priceAverageIn,\r\n                _priceAverageOut\r\n            );\r\n    }\r\n\r\n    function computeFirstTradeQtyOut(\r\n        uint256 _amountOut,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint256 _priceAverageIn,\r\n        uint256 _priceAverageOut\r\n    ) external pure returns (uint256 firstAmountOut_) {\r\n        return\r\n            SmardexLibraryV1.computeFirstTradeQtyOut(\r\n                _amountOut,\r\n                _fictiveReserveIn,\r\n                _fictiveReserveOut,\r\n                _priceAverageIn,\r\n                _priceAverageOut\r\n            );\r\n    }\r\n\r\n    function computeFictiveReserves(\r\n        uint256 _reserveIn,\r\n        uint256 _reserveOut,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut\r\n    ) external pure returns (uint256 newFictiveReserveIn_, uint256 newFictiveReserveOut_) {\r\n        return SmardexLibraryV1.computeFictiveReserves(_reserveIn, _reserveOut, _fictiveReserveIn, _fictiveReserveOut);\r\n    }\r\n\r\n    function applyKConstRuleOut(\r\n        uint256 _amountIn,\r\n        uint256 _reserveIn,\r\n        uint256 _reserveOut,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut\r\n    )\r\n        external\r\n        pure\r\n        returns (\r\n            uint256 amountOut_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        return\r\n            SmardexLibraryV1.applyKConstRuleOut(\r\n                _amountIn,\r\n                _reserveIn,\r\n                _reserveOut,\r\n                _fictiveReserveIn,\r\n                _fictiveReserveOut\r\n            );\r\n    }\r\n\r\n    function applyKConstRuleIn(\r\n        uint256 _amountOut,\r\n        uint256 _reserveIn,\r\n        uint256 _reserveOut,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut\r\n    )\r\n        external\r\n        pure\r\n        returns (\r\n            uint256 amountIn_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        return\r\n            SmardexLibraryV1.applyKConstRuleIn(\r\n                _amountOut,\r\n                _reserveIn,\r\n                _reserveOut,\r\n                _fictiveReserveIn,\r\n                _fictiveReserveOut\r\n            );\r\n    }\r\n\r\n    function getAmountOut(\r\n        uint256 _amountIn,\r\n        uint256 _reserveIn,\r\n        uint256 _reserveOut,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint256 _priceAverageIn,\r\n        uint256 _priceAverageOut\r\n    )\r\n        external\r\n        pure\r\n        returns (\r\n            uint256 amountOut_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        return\r\n            SmardexLibraryV1.getAmountOut(\r\n                _amountIn,\r\n                _reserveIn,\r\n                _reserveOut,\r\n                _fictiveReserveIn,\r\n                _fictiveReserveOut,\r\n                _priceAverageIn,\r\n                _priceAverageOut\r\n            );\r\n    }\r\n\r\n    function getAmountIn(\r\n        uint256 _amountOut,\r\n        uint256 _reserveIn,\r\n        uint256 _reserveOut,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint256 _priceAverageIn,\r\n        uint256 _priceAverageOut\r\n    )\r\n        external\r\n        pure\r\n        returns (\r\n            uint256 amountIn_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        return\r\n            SmardexLibraryV1.getAmountIn(\r\n                _amountOut,\r\n                _reserveIn,\r\n                _reserveOut,\r\n                _fictiveReserveIn,\r\n                _fictiveReserveOut,\r\n                _priceAverageIn,\r\n                _priceAverageOut\r\n            );\r\n    }\r\n}\r\n"
    },
    "contracts/core/test/coreV1/test/SmardexPairTestV1.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// contracts\r\nimport \"../SmardexPairV1.sol\";\r\n\r\ncontract SmardexPairTestV1 is SmardexPairV1 {\r\n    function setFictivePoolValues(uint128 _fictiveReserve0, uint128 _fictiveReserve1) public {\r\n        (fictiveReserve0, fictiveReserve1) = (_fictiveReserve0, _fictiveReserve1);\r\n    }\r\n\r\n    function setPriceAverage(uint128 _priceAverage0, uint128 _priceAverage1, uint40 _priceAverageLastTimestamp) public {\r\n        (priceAverage0, priceAverage1, priceAverageLastTimestamp) = (\r\n            _priceAverage0,\r\n            _priceAverage1,\r\n            _priceAverageLastTimestamp\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/core/test/ERC20Test.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// contracts\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\r\n\r\ncontract ERC20Test is ERC20Permit {\r\n    constructor(uint256 _totalSupply) ERC20(\"SmarDex LP-Token\", \"SDEX-LP\") ERC20Permit(\"SmarDex LP-Token\") {\r\n        _mint(msg.sender, _totalSupply);\r\n    }\r\n\r\n    function mint(address to, uint256 value) external {\r\n        _mint(to, value);\r\n    }\r\n}\r\n"
    },
    "contracts/core/test/SmardexFactoryTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// contracts\r\nimport \"../SmardexFactory.sol\";\r\nimport \"./SmardexPairTest.sol\";\r\n\r\ncontract SmardexFactoryTest is SmardexFactory {\r\n    function createPairTest(address _tokenA, address _tokenB) external returns (address pair_) {\r\n        require(_tokenA != _tokenB, \"SmarDex: IDENTICAL_ADDRESSES\");\r\n        (address _token0, address _token1) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\r\n        require(_token0 != address(0), \"SmarDex: ZERO_ADDRESS\");\r\n        require(getPair[_token0][_token1] == address(0), \"SmarDex: PAIR_EXISTS\"); // single check is sufficient\r\n        bytes32 _salt = keccak256(abi.encodePacked(_token0, _token1));\r\n        SmardexPairTest pair = new SmardexPairTest{ salt: _salt }();\r\n        pair.initialize(_token0, _token1, feesLP, feesPool);\r\n        pair_ = address(pair);\r\n        getPair[_token0][_token1] = pair_;\r\n        getPair[_token1][_token0] = pair_; // populate mapping in the reverse direction\r\n        allPairs.push(pair_);\r\n        emit PairCreated(_token0, _token1, pair_, allPairs.length);\r\n    }\r\n}\r\n"
    },
    "contracts/core/test/SmardexLibraryTest.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity =0.8.17;\r\n\r\n// libraries\r\nimport \"../libraries/SmardexLibrary.sol\";\r\n\r\ncontract SmardexLibraryTest {\r\n    function approxEq(uint256 _x, uint256 _y) external pure returns (bool) {\r\n        return SmardexLibrary.approxEq(_x, _y);\r\n    }\r\n\r\n    function ratioApproxEq(uint256 _xNum, uint256 _xDen, uint256 _yNum, uint256 _yDen) external pure returns (bool) {\r\n        return SmardexLibrary.ratioApproxEq(_xNum, _xDen, _yNum, _yDen);\r\n    }\r\n\r\n    function getUpdatedPriceAverage(\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint256 _priceAverageLastTimestamp,\r\n        uint256 _priceAverageIn,\r\n        uint256 _priceAverageOut,\r\n        uint256 _currentTimestamp\r\n    ) external pure returns (uint256 newPriceAverageIn_, uint256 newPriceAverageOut_) {\r\n        return\r\n            SmardexLibrary.getUpdatedPriceAverage(\r\n                _fictiveReserveIn,\r\n                _fictiveReserveOut,\r\n                _priceAverageLastTimestamp,\r\n                _priceAverageIn,\r\n                _priceAverageOut,\r\n                _currentTimestamp\r\n            );\r\n    }\r\n\r\n    function computeFirstTradeQtyIn(\r\n        uint256 _amountIn,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint256 _priceAverageIn,\r\n        uint256 _priceAverageOut,\r\n        uint128 _feesLP,\r\n        uint128 _feesPool\r\n    ) external pure returns (uint256 firstAmountIn_) {\r\n        return\r\n            SmardexLibrary.computeFirstTradeQtyIn(\r\n                SmardexLibrary.GetAmountParameters({\r\n                    amount: _amountIn,\r\n                    reserveIn: 0,\r\n                    reserveOut: 0,\r\n                    fictiveReserveIn: _fictiveReserveIn,\r\n                    fictiveReserveOut: _fictiveReserveOut,\r\n                    priceAverageIn: _priceAverageIn,\r\n                    priceAverageOut: _priceAverageOut,\r\n                    feesLP: _feesLP,\r\n                    feesPool: _feesPool\r\n                })\r\n            );\r\n    }\r\n\r\n    function computeFirstTradeQtyOut(\r\n        uint256 _amountOut,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint256 _priceAverageIn,\r\n        uint256 _priceAverageOut,\r\n        uint128 _feesLP,\r\n        uint128 _feesPool\r\n    ) external pure returns (uint256 firstAmountOut_) {\r\n        return\r\n            SmardexLibrary.computeFirstTradeQtyOut(\r\n                SmardexLibrary.GetAmountParameters({\r\n                    amount: _amountOut,\r\n                    reserveIn: 0,\r\n                    reserveOut: 0,\r\n                    fictiveReserveIn: _fictiveReserveIn,\r\n                    fictiveReserveOut: _fictiveReserveOut,\r\n                    priceAverageIn: _priceAverageIn,\r\n                    priceAverageOut: _priceAverageOut,\r\n                    feesLP: _feesLP,\r\n                    feesPool: _feesPool\r\n                })\r\n            );\r\n    }\r\n\r\n    function computeFictiveReserves(\r\n        uint256 _reserveIn,\r\n        uint256 _reserveOut,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut\r\n    ) external pure returns (uint256 newFictiveReserveIn_, uint256 newFictiveReserveOut_) {\r\n        return SmardexLibrary.computeFictiveReserves(_reserveIn, _reserveOut, _fictiveReserveIn, _fictiveReserveOut);\r\n    }\r\n\r\n    function applyKConstRuleOut(\r\n        uint256 _amountIn,\r\n        uint256 _reserveIn,\r\n        uint256 _reserveOut,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint128 _feesLP,\r\n        uint128 _feesPool\r\n    )\r\n        external\r\n        pure\r\n        returns (\r\n            uint256 amountOut_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        return\r\n            SmardexLibrary.applyKConstRuleOut(\r\n                SmardexLibrary.GetAmountParameters({\r\n                    amount: _amountIn,\r\n                    reserveIn: _reserveIn,\r\n                    reserveOut: _reserveOut,\r\n                    fictiveReserveIn: _fictiveReserveIn,\r\n                    fictiveReserveOut: _fictiveReserveOut,\r\n                    priceAverageIn: 0,\r\n                    priceAverageOut: 0,\r\n                    feesLP: _feesLP,\r\n                    feesPool: _feesPool\r\n                })\r\n            );\r\n    }\r\n\r\n    function applyKConstRuleIn(\r\n        uint256 _amountOut,\r\n        uint256 _reserveIn,\r\n        uint256 _reserveOut,\r\n        uint256 _fictiveReserveIn,\r\n        uint256 _fictiveReserveOut,\r\n        uint128 _feesLP,\r\n        uint128 _feesPool\r\n    )\r\n        external\r\n        pure\r\n        returns (\r\n            uint256 amountIn_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        return\r\n            SmardexLibrary.applyKConstRuleIn(\r\n                SmardexLibrary.GetAmountParameters({\r\n                    amount: _amountOut,\r\n                    reserveIn: _reserveIn,\r\n                    reserveOut: _reserveOut,\r\n                    fictiveReserveIn: _fictiveReserveIn,\r\n                    fictiveReserveOut: _fictiveReserveOut,\r\n                    priceAverageIn: 0,\r\n                    priceAverageOut: 0,\r\n                    feesLP: _feesLP,\r\n                    feesPool: _feesPool\r\n                })\r\n            );\r\n    }\r\n\r\n    function getAmountOut(\r\n        SmardexLibrary.GetAmountParameters memory _param\r\n    )\r\n        external\r\n        pure\r\n        returns (\r\n            uint256 amountOut_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        return SmardexLibrary.getAmountOut(_param);\r\n    }\r\n\r\n    function getAmountIn(\r\n        SmardexLibrary.GetAmountParameters memory _param\r\n    )\r\n        external\r\n        pure\r\n        returns (\r\n            uint256 amountIn_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        return SmardexLibrary.getAmountIn(_param);\r\n    }\r\n}\r\n"
    },
    "contracts/core/test/SmardexPairTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// contracts\r\nimport \"../SmardexPair.sol\";\r\n\r\ncontract SmardexPairTest is SmardexPair {\r\n    function setFictivePoolValues(uint128 _fictiveReserve0, uint128 _fictiveReserve1) public {\r\n        (fictiveReserve0, fictiveReserve1) = (_fictiveReserve0, _fictiveReserve1);\r\n    }\r\n\r\n    function setPriceAverage(uint128 _priceAverage0, uint128 _priceAverage1, uint40 _priceAverageLastTimestamp) public {\r\n        (priceAverage0, priceAverage1, priceAverageLastTimestamp) = (\r\n            _priceAverage0,\r\n            _priceAverage1,\r\n            _priceAverageLastTimestamp\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/interfaces/ISmardexRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity >=0.8.17;\r\n\r\n// interfaces\r\nimport \"../../core/interfaces/ISmardexSwapCallback.sol\";\r\nimport \"../../core/interfaces/ISmardexMintCallback.sol\";\r\nimport \"../../core/libraries/SmardexLibrary.sol\";\r\n\r\ninterface ISmardexRouter is ISmardexSwapCallback, ISmardexMintCallback {\r\n    /**\r\n     * @notice parameters used by the addLiquidity function\r\n     * @param tokenA address of the first token in the pair\r\n     * @param tokenB address of the second token in the pair\r\n     * @param amountADesired The amount of tokenA to add as liquidity\r\n     * if the B/A price is <= amountBDesired/amountADesired\r\n     * @param amountBDesired The amount of tokenB to add as liquidity\r\n     * if the A/B price is <= amountADesired/amountBDesired\r\n     * @param amountAMin Bounds the extent to which the B/A price can go up before the transaction reverts.\r\n     * Must be <= amountADesired.\r\n     * @param amountBMin Bounds the extent to which the A/B price can go up before the transaction reverts.\r\n     * Must be <= amountBDesired.\r\n     * @param fictiveReserveB The fictive reserve of tokenB at time of submission\r\n     * @param fictiveReserveAMin The minimum fictive reserve of tokenA indicating the extent to which the A/B price can\r\n     * go down\r\n     * @param fictiveReserveAMax The maximum fictive reserve of tokenA indicating the extent to which the A/B price can\r\n     * go up\r\n     */\r\n    struct AddLiquidityParams {\r\n        address tokenA;\r\n        address tokenB;\r\n        uint256 amountADesired;\r\n        uint256 amountBDesired;\r\n        uint256 amountAMin;\r\n        uint256 amountBMin;\r\n        uint128 fictiveReserveB;\r\n        uint128 fictiveReserveAMin;\r\n        uint128 fictiveReserveAMax;\r\n    }\r\n\r\n    /**\r\n     * @notice parameters used by the addLiquidityETH function\r\n     * @param token A pool token.\r\n     * @param amountTokenDesired The amount of token to add as liquidity if the WETH/token price\r\n     * is <= msg.value/amountTokenDesired (token depreciates).\r\n     * @param amountTokenMin Bounds the extent to which the WETH/token price can go up before the transaction reverts.\r\n     * Must be <= amountTokenDesired.\r\n     * @param amountETHMin Bounds the extent to which the token/WETH price can go up before the transaction reverts.\r\n     * Must be <= msg.value.\r\n     * @param fictiveReserveETH The fictive reserve of wETH at time of submission\r\n     * @param fictiveReserveTokenMin The minimum fictive reserve of the token indicating the extent to which the token\r\n     * price can go up\r\n     * @param fictiveReserveTokenMax The maximum fictive reserve of the token indicating the extent to which the token\r\n     * price can go down\r\n     */\r\n    struct AddLiquidityETHParams {\r\n        address token;\r\n        uint256 amountTokenDesired;\r\n        uint256 amountTokenMin;\r\n        uint256 amountETHMin;\r\n        uint128 fictiveReserveETH;\r\n        uint128 fictiveReserveTokenMin;\r\n        uint128 fictiveReserveTokenMax;\r\n    }\r\n\r\n    /**\r\n     * @notice emitted when a pair is added to the whitelist\r\n     * @param tokenA address of one of the token of the pair\r\n     * @param tokenB address of the other token of the pair\r\n     * @param pair whitelisted pair address\r\n     */\r\n    event PairWhitelisted(address tokenA, address tokenB, address pair);\r\n\r\n    /**\r\n     * @notice get the factory address\r\n     * @return address of the factory\r\n     */\r\n    function factory() external view returns (address);\r\n\r\n    /**\r\n     * @notice get WETH address\r\n     * @return address of the WETH token (Wrapped Ether)\r\n     */\r\n    function WETH() external view returns (address);\r\n\r\n    /**\r\n     * @notice Add pair to the whitelist if it's also present in the factory whitelist\r\n     * @dev this function is callable by anyone, only the pairs also whitelisted by the factory will be accepted.\r\n     * @param _tokenA address of the first token in the pair\r\n     * @param _tokenB address of the second token in the pair\r\n     * @return pair_ address of the created pair\r\n     */\r\n    function addPairToWhitelist(address _tokenA, address _tokenB) external returns (address pair_);\r\n\r\n    /**\r\n     * @notice Add liquidity to an ERC-20=ERC-20 pool. Receive liquidity token to materialize shares in the pool\r\n     * @param _params all the parameters required to add liquidity from struct AddLiquidityParams\r\n     * @param _to Recipient of the liquidity tokens.\r\n     * @param _deadline Unix timestamp after which the transaction will revert.\r\n     * @return amountA_ The amount of tokenA sent to the pool.\r\n     * @return amountB_ The amount of tokenB sent to the pool.\r\n     * @return liquidity_ The amount of liquidity tokens minted.\r\n     */\r\n    function addLiquidity(\r\n        AddLiquidityParams calldata _params,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 amountA_, uint256 amountB_, uint256 liquidity_);\r\n\r\n    /**\r\n     * @notice Adds liquidity to an ERC-20=WETH pool with ETH. msg.value is the amount of ETH to add as liquidity.\r\n     * if the token/WETH price is <= amountTokenDesired/msg.value (WETH depreciates).\r\n     * @param _params all the parameters required to add liquidity from struct AddLiquidityETHParams\r\n     * @param _to Recipient of the liquidity tokens.\r\n     * @param _deadline Unix timestamp after which the transaction will revert.\r\n     * @return amountToken_ The amount of token sent to the pool.\r\n     * @return amountETH_ The amount of ETH converted to WETH and sent to the pool.\r\n     * @return liquidity_ The amount of liquidity tokens minted.\r\n     */\r\n    function addLiquidityETH(\r\n        AddLiquidityETHParams calldata _params,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable returns (uint256 amountToken_, uint256 amountETH_, uint256 liquidity_);\r\n\r\n    /**\r\n     * @notice Removes liquidity from an ERC-20=ERC-20 pool.\r\n     * @param _tokenA A pool token.\r\n     * @param _tokenB A pool token.\r\n     * @param _liquidity The amount of liquidity tokens to remove.\r\n     * @param _amountAMin The minimum amount of tokenA that must be received for the transaction not to revert.\r\n     * @param _amountBMin The minimum amount of tokenB that must be received for the transaction not to revert.\r\n     * @param _to Recipient of the liquidity tokens.\r\n     * @param _deadline Unix timestamp after which the transaction will revert.\r\n     * @return amountA_ The amount of tokenA received.\r\n     * @return amountB_ The amount of tokenB received.\r\n     */\r\n    function removeLiquidity(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _liquidity,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 amountA_, uint256 amountB_);\r\n\r\n    /**\r\n     * @notice Removes liquidity from an ERC-20=WETH pool and receive ETH.\r\n     * @param _token A pool token.\r\n     * @param _liquidity The amount of liquidity tokens to remove.\r\n     * @param _amountTokenMin The minimum amount of token that must be received for the transaction not to revert.\r\n     * @param _amountETHMin The minimum amount of ETH that must be received for the transaction not to revert.\r\n     * @param _to Recipient of the liquidity tokens.\r\n     * @param _deadline Unix timestamp after which the transaction will revert.\r\n     * @return amountToken_ The amount of token received.\r\n     * @return amountETH_ The amount of ETH received.\r\n     */\r\n    function removeLiquidityETH(\r\n        address _token,\r\n        uint256 _liquidity,\r\n        uint256 _amountTokenMin,\r\n        uint256 _amountETHMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 amountToken_, uint256 amountETH_);\r\n\r\n    /**\r\n     * @notice Removes liquidity from an ERC-20=WETH pool and receive ETH.\r\n     * @param _tokenA A pool token.\r\n     * @param _tokenB A pool token.\r\n     * @param _liquidity The amount of liquidity tokens to remove.\r\n     * @param _amountAMin The minimum amount of tokenA that must be received for the transaction not to revert.\r\n     * @param _amountBMin The minimum amount of tokenB that must be received for the transaction not to revert.\r\n     * @param _to Recipient of the liquidity tokens.\r\n     * @param _deadline Unix timestamp after which the transaction will revert.\r\n     * @param _approveMax Whether or not the approval amount in the signature is for liquidity or uint(-1).\r\n     * @param _v The v component of the permit signature.\r\n     * @param _r The r component of the permit signature.\r\n     * @param _s The s component of the permit signature.\r\n     * @return amountA_ The amount of tokenA received.\r\n     * @return amountB_ The amount of tokenB received.\r\n     */\r\n    function removeLiquidityWithPermit(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _liquidity,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256 amountA_, uint256 amountB_);\r\n\r\n    /**\r\n     * @notice Removes liquidity from an ERC-20=WETH pool and receive ETH without pre-approval\r\n     * @param _token A pool token.\r\n     * @param _liquidity The amount of liquidity tokens to remove.\r\n     * @param _amountTokenMin The minimum amount of token that must be received for the transaction not to revert.\r\n     * @param _amountETHMin The minimum amount of ETH that must be received for the transaction not to revert.\r\n     * @param _to Recipient of the liquidity tokens.\r\n     * @param _deadline Unix timestamp after which the transaction will revert.\r\n     * @param _approveMax Whether or not the approval amount in the signature is for liquidity or uint(-1).\r\n     * @param _v The v component of the permit signature.\r\n     * @param _r The r component of the permit signature.\r\n     * @param _s The s component of the permit signature.\r\n     * @return amountToken_ The amount of token received.\r\n     * @return amountETH_ The amount of ETH received.\r\n     */\r\n    function removeLiquidityETHWithPermit(\r\n        address _token,\r\n        uint256 _liquidity,\r\n        uint256 _amountTokenMin,\r\n        uint256 _amountETHMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256 amountToken_, uint256 amountETH_);\r\n\r\n    /**\r\n     * @notice Swaps an exact amount of input tokens for as many output tokens as possible, along the route determined\r\n     * by the path. The first element of path is the input token, the last is the output token, and any intermediate\r\n     * elements represent intermediate pairs to trade through (if, for example, a direct pair does not exist).\r\n     * @param _amountIn The amount of input tokens to send.\r\n     * @param _amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\r\n     * @param _path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses\r\n     * must exist and have liquidity.\r\n     * @param _to Recipient of the output tokens.\r\n     * @param _deadline Unix timestamp after which the transaction will revert.\r\n     * @return amountOut_ The output token amount.\r\n     */\r\n    function swapExactTokensForTokens(\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 amountOut_);\r\n\r\n    /**\r\n     * @notice Receive an exact amount of output tokens for as few input tokens as possible, along the route determined\r\n     * by the path. The first element of path is the input token, the last is the output token, and any intermediate\r\n     * elements represent intermediate tokens to trade through (if, for example, a direct pair does not exist).\r\n     * @param _amountOut The amount of output tokens to receive.\r\n     * @param _amountInMax The maximum amount of input tokens that can be required before the transaction reverts.\r\n     * @param _path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses\r\n     * must exist and have liquidity.\r\n     * @param _to Recipient of the output tokens.\r\n     * @param _deadline Unix timestamp after which the transaction will revert.\r\n     * @return amountIn_ The input token amount.\r\n     */\r\n    function swapTokensForExactTokens(\r\n        uint256 _amountOut,\r\n        uint256 _amountInMax,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 amountIn_);\r\n\r\n    /**\r\n     * @notice Swaps an exact amount of ETH for as many output tokens as possible, along the route determined by the\r\n     * path. The first element of path must be WETH, the last is the output token, and any intermediate elements\r\n     * represent intermediate pairs to trade through (if, for example, a direct pair does not exist).\r\n     * @param _amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\r\n     * @param _path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses\r\n     * must exist and have liquidity.\r\n     * @param _to Recipient of the output tokens.\r\n     * @param _deadline Unix timestamp after which the transaction will revert.\r\n     * @return amountOut_ The input token amount.\r\n     */\r\n    function swapExactETHForTokens(\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable returns (uint256 amountOut_);\r\n\r\n    /**\r\n     * @notice Receive an exact amount of ETH for as few input tokens as possible, along the route determined by the\r\n     * path. The first element of path is the input token, the last must be WETH, and any intermediate elements\r\n     * represent intermediate pairs to trade through (if, for example, a direct pair does not exist).\r\n     * @param _amountOut The amount of ETH to receive.\r\n     * @param _amountInMax The maximum amount of input tokens that can be required before the transaction reverts.\r\n     * @param _path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses\r\n     * must exist and have liquidity.\r\n     * @param _to Recipient of ETH.\r\n     * @param _deadline Unix timestamp after which the transaction will revert.\r\n     * @return amountIn_ The input token amount.\r\n     */\r\n    function swapTokensForExactETH(\r\n        uint256 _amountOut,\r\n        uint256 _amountInMax,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 amountIn_);\r\n\r\n    /**\r\n     * @notice Swaps an exact amount of tokens for as much ETH as possible, along the route determined by the path.\r\n     * The first element of path is the input token, the last must be WETH, and any intermediate elements represent\r\n     * intermediate pairs to trade through (if, for example, a direct pair does not exist).\r\n     * @param _amountIn The amount of input tokens to send.\r\n     * @param _amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\r\n     * @param _path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses\r\n     * must exist and have liquidity.\r\n     * @param _to Recipient of ETH.\r\n     * @param _deadline Unix timestamp after which the transaction will revert.\r\n     * @return amountOut_ The input token amount.\r\n     */\r\n    function swapExactTokensForETH(\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 amountOut_);\r\n\r\n    /**\r\n     * @notice Receive an exact amount of tokens for as little ETH as possible, along the route determined by the path.\r\n     * The first element of path must be WETH, the last is the output token and any intermediate elements represent\r\n     * intermediate pairs to trade through (if, for example, a direct pair does not exist).\r\n     * msg.value The maximum amount of ETH that can be required before the transaction reverts.\r\n     * @param _amountOut The amount of tokens to receive.\r\n     * @param _path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses\r\n     * must exist and have liquidity.\r\n     * @param _to Recipient of output tokens.\r\n     * @param _deadline Unix timestamp after which the transaction will revert.\r\n     * @return amountIn_ The input token amount.\r\n     */\r\n    function swapETHForExactTokens(\r\n        uint256 _amountOut,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable returns (uint256 amountIn_);\r\n\r\n    /**\r\n     * @notice Given some asset amount and reserves, returns an amount of the other asset representing equivalent value.\r\n     */\r\n    function quote(\r\n        uint256 _amountA,\r\n        uint256 _fictiveReserveA,\r\n        uint256 _fictiveReserveB\r\n    ) external pure returns (uint256 amountB_);\r\n\r\n    /**\r\n     * @notice return the amount of tokens the user would get by doing a swap\r\n     * @param _param all the parameters required to get amount from struct GetAmountParameters\r\n     * @return amountOut_ The amount of token the user would receive\r\n     * @return newReserveIn_ reserves of the selling token after the swap\r\n     * @return newReserveOut_ reserves of the buying token after the swap\r\n     * @return newFictiveReserveIn_ fictive reserve of the selling token after the swap\r\n     * @return newFictiveReserveOut_ fictive reserve of the buying token after the swap\r\n     */\r\n    function getAmountOut(\r\n        SmardexLibrary.GetAmountParameters memory _param\r\n    )\r\n        external\r\n        pure\r\n        returns (\r\n            uint256 amountOut_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        );\r\n\r\n    /**\r\n     * @notice return the amount of tokens the user should spend by doing a swap\r\n     * @param _param all the parameters required to get amount from struct GetAmountParameters\r\n     * @return amountIn_ The amount of token the user would spend to receive _amountOut\r\n     * @return newReserveIn_ reserves of the selling token after the swap\r\n     * @return newReserveOut_ reserves of the buying token after the swap\r\n     * @return newFictiveReserveIn_ fictive reserve of the selling token after the swap\r\n     * @return newFictiveReserveOut_ fictive reserve of the buying token after the swap\r\n     */\r\n    function getAmountIn(\r\n        SmardexLibrary.GetAmountParameters memory _param\r\n    )\r\n        external\r\n        pure\r\n        returns (\r\n            uint256 amountIn_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        );\r\n\r\n    /**\r\n     * @notice return the amount of tokens the user should spend by doing a swap by directly\r\n     *              fetching data from the pair tokenIn/tokenOut\r\n     * @param _amountIn quantity of token the user want to swap (to buy)\r\n     * @param _tokenIn address of the token the user want to sell\r\n     * @param _tokenOut address of the token the user want to buy\r\n     * @return amountOut_ The amount of token the user would receive\r\n     * @return newReserveIn_ reserves of the selling token after the swap\r\n     * @return newReserveOut_ reserves of the buying token after the swap\r\n     * @return newFictiveReserveIn_ fictive reserve of the selling token after the swap\r\n     * @return newFictiveReserveOut_ fictive reserve of the buying token after the swap\r\n     */\r\n    function getAmountOutFromPair(\r\n        uint256 _amountIn,\r\n        address _tokenIn,\r\n        address _tokenOut\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 amountOut_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        );\r\n\r\n    /**\r\n     * @notice return the amount of tokens the user should spend by doing a swap by directly\r\n     *              fetching data from the pair tokenIn/tokenOut\r\n     * @param _amountOut quantity of token the user want to swap (to sell)\r\n     * @param _tokenIn address of the token the user want to sell\r\n     * @param _tokenOut address of the token the user want to buy\r\n     * @return amountIn_ The amount of token the user would spend to receive _amountOut\r\n     * @return newReserveIn_ reserves of the selling token after the swap\r\n     * @return newReserveOut_ reserves of the buying token after the swap\r\n     * @return newFictiveReserveIn_ fictive reserve of the selling token after the swap\r\n     * @return newFictiveReserveOut_ fictive reserve of the buying token after the swap\r\n     */\r\n    function getAmountInFromPair(\r\n        uint256 _amountOut,\r\n        address _tokenIn,\r\n        address _tokenOut\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 amountIn_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        );\r\n\r\n    /**\r\n     * @notice perform a swapExactTokensForTokens with a permit for the entry token\r\n     * @param _amountIn The amount of input tokens to send.\r\n     * @param _amountOutMin The minimum amount of output tokens that must be received for the transaction not to revert.\r\n     * @param _path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses\r\n     * must exist and have liquidity.\r\n     * @param _to Recipient of the output tokens.\r\n     * @param _deadline unix timestamp after which the transaction will revert\r\n     * @param _approveMax Whether the approval amount in the signature is for uint(-1) (true) or _amountIn (false).\r\n     * @param _v The v component of the permit signature.\r\n     * @param _r The r component of the permit signature.\r\n     * @param _s The s component of the permit signature.\r\n     * @return amountOut_ The output token amount.\r\n     */\r\n    function swapExactTokensForTokensWithPermit(\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256 amountOut_);\r\n\r\n    /**\r\n     * @notice Perform a swapTokensForExactTokens with a permit for the entry token\r\n     * @param _amountOut The amount of output tokens to receive.\r\n     * @param _amountInMax The maximum amount of input tokens that can be required before the transaction reverts.\r\n     * @param _path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses\r\n     * must exist and have liquidity.\r\n     * @param _to Recipient of the output tokens.\r\n     * @param _deadline Unix timestamp after which the transaction will revert\r\n     * @param _approveMax Whether the approval amount in the signature is for uint(-1) (true) or _amountInMax (false).\r\n     * @param _v The v component of the permit signature.\r\n     * @param _r The r component of the permit signature.\r\n     * @param _s The s component of the permit signature.\r\n     * @return amountIn_ The input token amount.\r\n     */\r\n    function swapTokensForExactTokensWithPermit(\r\n        uint256 _amountOut,\r\n        uint256 _amountInMax,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256 amountIn_);\r\n\r\n    /**\r\n     * @notice Perform a swapTokensForExactETH with a permit for the entry token\r\n     * @param _amountOut The amount of output tokens to receive.\r\n     * @param _amountInMax The maximum amount of input tokens that can be required before the transaction reverts.\r\n     * @param _path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses\r\n     * must exist and have liquidity.\r\n     * @param _to Recipient of the output tokens.\r\n     * @param _deadline Unix timestamp after which the transaction will revert\r\n     * @param _approveMax Whether the approval amount in the signature is for uint(-1) (true) or _amountInMax (false).\r\n     * @param _v The v component of the permit signature.\r\n     * @param _r The r component of the permit signature.\r\n     * @param _s The s component of the permit signature.\r\n     * @return amountIn_ The input token amount.\r\n     */\r\n    function swapTokensForExactETHWithPermit(\r\n        uint256 _amountOut,\r\n        uint256 _amountInMax,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256 amountIn_);\r\n\r\n    /**\r\n     * @notice Perform a swapExactTokensForETH with a permit for the entry token\r\n     * @param _amountIn The amount of input tokens to send.\r\n     * @param _amountOutMin The minimum amount of output ETH that must be received for the transaction not to revert.\r\n     * @param _path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses\r\n     * must exist and have liquidity.\r\n     * @param _to Recipient of the output tokens.\r\n     * @param _deadline Unix timestamp after which the transaction will revert\r\n     * @param _approveMax Whether the approval amount in the signature is for uint(-1) (true) or _amountIn (false).\r\n     * @param _v The v component of the permit signature.\r\n     * @param _r The r component of the permit signature.\r\n     * @param _s The s component of the permit signature.\r\n     * @return amountOut_ The output token amount.\r\n     */\r\n    function swapExactTokensForETHWithPermit(\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external returns (uint256 amountOut_);\r\n}\r\n"
    },
    "contracts/periphery/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n// Copyright (C) 2015, 2016, 2017 Dapphub\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity >=0.8.17;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n\r\n    function transfer(address to, uint256 value) external returns (bool);\r\n\r\n    function withdraw(uint256) external;\r\n}\r\n"
    },
    "contracts/periphery/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity ^0.8.17;\r\n\r\n/**\r\n * @title Solidity Bytes Arrays Utils\r\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\r\n * @custom:url https://github.com/GNSPS/solidity-bytes-utils/blob/master/contracts/BytesLib.sol\r\n *\r\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\r\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\r\n */\r\nlibrary BytesLib {\r\n    function slice(bytes memory _bytes, uint256 _start, uint256 _length) internal pure returns (bytes memory) {\r\n        require(_length + 31 >= _length, \"slice_overflow\");\r\n        require(_start + _length >= _start, \"slice_overflow\");\r\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\r\n\r\n        bytes memory tempBytes;\r\n\r\n        assembly {\r\n            switch iszero(_length)\r\n            case 0 {\r\n                // Get a location of some free memory and store it in tempBytes as\r\n                // Solidity does for memory variables.\r\n                tempBytes := mload(0x40)\r\n\r\n                // The first word of the slice result is potentially a partial\r\n                // word read from the original array. To read it, we calculate\r\n                // the length of that partial word and start copying that many\r\n                // bytes into the array. The first word we copy will start with\r\n                // data we don't care about, but the last `lengthmod` bytes will\r\n                // land at the beginning of the contents of the new array. When\r\n                // we're done copying, we overwrite the full first word with\r\n                // the actual length of the slice.\r\n                let lengthmod := and(_length, 31)\r\n\r\n                // The multiplication in the next line is necessary\r\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\r\n                // the following copy loop was copying the origin's length\r\n                // and then ending prematurely not copying everything it should.\r\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\r\n                let end := add(mc, _length)\r\n\r\n                for {\r\n                    // The multiplication in the next line has the same exact purpose\r\n                    // as the one above.\r\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\r\n                } lt(mc, end) {\r\n                    mc := add(mc, 0x20)\r\n                    cc := add(cc, 0x20)\r\n                } {\r\n                    mstore(mc, mload(cc))\r\n                }\r\n\r\n                mstore(tempBytes, _length)\r\n\r\n                //update free-memory pointer\r\n                //allocating the array padded to 32 bytes like the compiler does now\r\n                mstore(0x40, and(add(mc, 31), not(31)))\r\n            }\r\n            //if we want a zero-length slice let's just return a zero-length array\r\n            default {\r\n                tempBytes := mload(0x40)\r\n                //zero out the 32 bytes slice we are about to return\r\n                //we need to do it because Solidity does not garbage collect\r\n                mstore(tempBytes, 0)\r\n\r\n                mstore(0x40, add(tempBytes, 0x20))\r\n            }\r\n        }\r\n\r\n        return tempBytes;\r\n    }\r\n\r\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\r\n        require(_start + 20 >= _start, \"toAddress_overflow\");\r\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\r\n        address tempAddress;\r\n\r\n        assembly {\r\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\r\n        }\r\n\r\n        return tempAddress;\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/libraries/Path.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity ^0.8.17;\r\n\r\n// libraries\r\nimport \"./BytesLib.sol\";\r\n\r\n/**\r\n * @title Functions for manipulating path data for multihop swaps\r\n * @custom:from UniswapV3\r\n * @custom:url https://github.com/Uniswap/v3-periphery/blob/main/contracts/libraries/Path.sol\r\n * @custom:editor SmarDex team\r\n */\r\nlibrary Path {\r\n    using BytesLib for bytes;\r\n\r\n    /// @dev The length of the bytes encoded address\r\n    uint256 private constant ADDR_SIZE = 20;\r\n\r\n    /// @dev The offset of a single token address\r\n    uint256 private constant NEXT_OFFSET = ADDR_SIZE;\r\n    /// @dev The offset of an encoded pool key\r\n    uint256 private constant POP_OFFSET = NEXT_OFFSET + ADDR_SIZE;\r\n    /// @dev The minimum length of an encoding that contains 2 or more pools\r\n    uint256 private constant MULTIPLE_POOLS_MIN_LENGTH = POP_OFFSET + NEXT_OFFSET;\r\n\r\n    /// @notice Returns true if the path contains two or more pools\r\n    /// @param path The encoded swap path\r\n    /// @return True if path contains two or more pools, otherwise false\r\n    function hasMultiplePools(bytes memory path) internal pure returns (bool) {\r\n        return path.length >= MULTIPLE_POOLS_MIN_LENGTH;\r\n    }\r\n\r\n    /// @notice Returns the number of pools in the path\r\n    /// @param _path The encoded swap path\r\n    /// @return The number of pools in the path\r\n    function numPools(bytes memory _path) internal pure returns (uint256) {\r\n        return ((_path.length - ADDR_SIZE) / NEXT_OFFSET);\r\n    }\r\n\r\n    /// @notice Decodes the first pool in path\r\n    /// @param _path The bytes encoded swap path\r\n    /// @return tokenA_ The first token of the given pool\r\n    /// @return tokenB_ The second token of the given pool\r\n    function decodeFirstPool(bytes memory _path) internal pure returns (address tokenA_, address tokenB_) {\r\n        tokenA_ = _path.toAddress(0);\r\n        tokenB_ = _path.toAddress(NEXT_OFFSET);\r\n    }\r\n\r\n    /// @notice Gets the segment corresponding to the first pool in the path\r\n    /// @param _path The bytes encoded swap path\r\n    /// @return The segment containing all data necessary to target the first pool in the path\r\n    function getFirstPool(bytes memory _path) internal pure returns (bytes memory) {\r\n        return _path.slice(0, POP_OFFSET);\r\n    }\r\n\r\n    /// @notice Skips a token from the buffer and returns the remainder\r\n    /// @param _path The swap path\r\n    /// @return The remaining token elements in the path\r\n    function skipToken(bytes memory _path) internal pure returns (bytes memory) {\r\n        return _path.slice(NEXT_OFFSET, _path.length - NEXT_OFFSET);\r\n    }\r\n\r\n    /// @notice Returns the _path addresses concatenated as a packed bytes array\r\n    /// @param _path The swap path\r\n    /// @return encoded_ The bytes array containing the packed addresses\r\n    function encodeTightlyPacked(address[] calldata _path) internal pure returns (bytes memory encoded_) {\r\n        uint256 len = _path.length;\r\n        for (uint256 i; i != len; ) {\r\n            encoded_ = bytes.concat(encoded_, abi.encodePacked(_path[i]));\r\n            unchecked {\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @notice Returns the _path addresses concatenated in a reversed order as a packed bytes array\r\n    /// @param _path The swap path\r\n    /// @return encoded_ The bytes array containing the packed addresses\r\n    function encodeTightlyPackedReversed(address[] calldata _path) internal pure returns (bytes memory encoded_) {\r\n        uint256 len = _path.length;\r\n        for (uint256 i = len; i != 0; ) {\r\n            encoded_ = bytes.concat(encoded_, abi.encodePacked(_path[i - 1]));\r\n            unchecked {\r\n                --i;\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/libraries/PoolAddress.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// libraries\r\nimport \"./PoolHelpers.sol\";\r\n\r\n// interfaces\r\nimport \"../../core/interfaces/ISmardexFactory.sol\";\r\n\r\nlibrary PoolAddress {\r\n    /**\r\n     * @notice Deterministically computes the pool address given the factory and PoolKey. Also check the whitelist first.\r\n     * @param _factory The SmarDex factory contract address\r\n     * @param _tokenA The first token of the pool\r\n     * @param _tokenB The second token of the pool\r\n     * @param _whitelist storage mapping with the pair address as value\r\n     * @return pair_ The contract address of the SmardexPair\r\n     */\r\n    function pairFor(\r\n        address _factory,\r\n        address _tokenA,\r\n        address _tokenB,\r\n        mapping(bytes32 => address) storage _whitelist\r\n    ) internal view returns (address pair_) {\r\n        // get hash, used to check the whitelist AND compute the pair address with init hash\r\n        bytes32 _hash = getTokenHash(_factory, _tokenA, _tokenB);\r\n\r\n        // check the whitelist (1 SLOAD)\r\n        pair_ = _whitelist[_hash];\r\n        if (pair_ == address(0)) {\r\n            pair_ = address(uint160(uint256(_hash)));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Deterministically computes the pool address given the factory and PoolKey\r\n     * @param _factory The SmarDex factory contract address\r\n     * @param _tokenA The first token of the pool\r\n     * @param _tokenB The second token of the pool\r\n     * @return hash_ The hash of the pair\r\n     */\r\n    function getTokenHash(address _factory, address _tokenA, address _tokenB) internal pure returns (bytes32 hash_) {\r\n        (address _token0, address _token1) = PoolHelpers.sortTokens(_tokenA, _tokenB);\r\n        hash_ = keccak256(\r\n            abi.encodePacked(\r\n                hex\"ff\",\r\n                _factory,\r\n                keccak256(abi.encodePacked(_token0, _token1)),\r\n                hex\"c762a0f9885cc92b9fd8eef224b75997682b634460611bc0f2138986e20b653f\" // init code hash\r\n            )\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/libraries/PoolHelpers.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// libraries\r\nimport \"./PoolAddress.sol\";\r\nimport \"../../core/libraries/SmardexLibrary.sol\";\r\n\r\n// interfaces\r\nimport \"../../core/interfaces/ISmardexPair.sol\";\r\n\r\nlibrary PoolHelpers {\r\n    /**\r\n     * @notice sort token addresses, used to handle return values from pairs sorted in this order\r\n     * @param _tokenA token to sort\r\n     * @param _tokenB token to sort\r\n     * @return token0_ token0 sorted\r\n     * @return token1_ token1 sorted\r\n     */\r\n    function sortTokens(address _tokenA, address _tokenB) internal pure returns (address token0_, address token1_) {\r\n        require(_tokenA != _tokenB, \"SmardexHelper: IDENTICAL_ADDRESSES\");\r\n        (token0_, token1_) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\r\n        require(token0_ != address(0), \"SmardexHelper: ZERO_ADDRESS\");\r\n    }\r\n\r\n    /**\r\n     * @notice fetches the reserves for a pair\r\n     * @param _factory the factory address\r\n     * @param _tokenA token to fetch reserves\r\n     * @param _tokenB token to fetch reserves\r\n     * @param _whitelist storage mapping with the pair address as value\r\n     * @return reserveA_ reserves of tokenA in the pair tokenA/TokenB\r\n     * @return reserveB_ reserves of tokenB in the pair tokenA/TokenB\r\n     */\r\n    function getReserves(\r\n        address _factory,\r\n        address _tokenA,\r\n        address _tokenB,\r\n        mapping(bytes32 => address) storage _whitelist\r\n    ) internal view returns (uint256 reserveA_, uint256 reserveB_) {\r\n        (address _token0, ) = sortTokens(_tokenA, _tokenB);\r\n        (uint256 _reserve0, uint256 _reserve1) = ISmardexPair(\r\n            PoolAddress.pairFor(_factory, _tokenA, _tokenB, _whitelist)\r\n        ).getReserves();\r\n        (reserveA_, reserveB_) = _tokenA == _token0 ? (_reserve0, _reserve1) : (_reserve1, _reserve0);\r\n    }\r\n\r\n    /**\r\n     * @notice fetches the fictive reserves for a pair\r\n     * @param _factory the factory address\r\n     * @param _tokenA token to fetch fictive reserves\r\n     * @param _tokenB token to fetch fictive reserves\r\n     * @param _whitelist storage mapping with the pair address as value\r\n     * @return fictiveReserveA_ fictive reserves of tokenA in the pair tokenA/TokenB\r\n     * @return fictiveReserveB_ fictive reserves of tokenB in the pair tokenA/TokenB\r\n     */\r\n    function getFictiveReserves(\r\n        address _factory,\r\n        address _tokenA,\r\n        address _tokenB,\r\n        mapping(bytes32 => address) storage _whitelist\r\n    ) internal view returns (uint256 fictiveReserveA_, uint256 fictiveReserveB_) {\r\n        (address _token0, ) = sortTokens(_tokenA, _tokenB);\r\n        (uint256 _fictiveReserve0, uint256 _fictiveReserve1) = ISmardexPair(\r\n            PoolAddress.pairFor(_factory, _tokenA, _tokenB, _whitelist)\r\n        ).getFictiveReserves();\r\n        (fictiveReserveA_, fictiveReserveB_) = _tokenA == _token0\r\n            ? (_fictiveReserve0, _fictiveReserve1)\r\n            : (_fictiveReserve1, _fictiveReserve0);\r\n    }\r\n\r\n    /**\r\n     * @notice fetches the real and fictive reserves for a pair\r\n     * @param _factory the factory address\r\n     * @param _tokenA token to fetch fictive reserves\r\n     * @param _tokenB token to fetch fictive reserves\r\n     * @param _whitelist storage mapping with the pair address as value\r\n     * @return reserveA_ reserves of tokenA in the pair tokenA/TokenB\r\n     * @return reserveB_ reserves of tokenB in the pair tokenA/TokenB\r\n     * @return fictiveReserveA_ fictive reserves of tokenA in the pair tokenA/TokenB\r\n     * @return fictiveReserveB_ fictive reserves of tokenB in the pair tokenA/TokenB\r\n     */\r\n    function getAllReserves(\r\n        address _factory,\r\n        address _tokenA,\r\n        address _tokenB,\r\n        mapping(bytes32 => address) storage _whitelist\r\n    ) internal view returns (uint256 reserveA_, uint256 reserveB_, uint256 fictiveReserveA_, uint256 fictiveReserveB_) {\r\n        (address _token0, ) = sortTokens(_tokenA, _tokenB);\r\n        ISmardexPair _pair = ISmardexPair(PoolAddress.pairFor(_factory, _tokenA, _tokenB, _whitelist));\r\n        (uint256 _reserve0, uint256 _reserve1) = _pair.getReserves();\r\n        (uint256 _fictiveReserve0, uint256 _fictiveReserve1) = _pair.getFictiveReserves();\r\n        (reserveA_, reserveB_, fictiveReserveA_, fictiveReserveB_) = _tokenA == _token0\r\n            ? (_reserve0, _reserve1, _fictiveReserve0, _fictiveReserve1)\r\n            : (_reserve1, _reserve0, _fictiveReserve1, _fictiveReserve0);\r\n    }\r\n\r\n    /**\r\n     * @notice fetches the priceAverage for a pair\r\n     * @param _factory the factory address\r\n     * @param _tokenA token to fetch priceAverage\r\n     * @param _tokenB token to fetch priceAverage\r\n     * @param _whitelist storage mapping with the pair address as value\r\n     * @return priceAverageA_ priceAverage of tokenA in the pair tokenA/TokenB\r\n     * @return priceAverageB_ priceAverage of tokenB in the pair tokenA/TokenB\r\n     */\r\n    function getPriceAverage(\r\n        address _factory,\r\n        address _tokenA,\r\n        address _tokenB,\r\n        mapping(bytes32 => address) storage _whitelist\r\n    ) internal view returns (uint256 priceAverageA_, uint256 priceAverageB_) {\r\n        (address _token0, ) = sortTokens(_tokenA, _tokenB);\r\n        (uint256 _priceAverage0, uint256 _priceAverage1, ) = ISmardexPair(\r\n            PoolAddress.pairFor(_factory, _tokenA, _tokenB, _whitelist)\r\n        ).getPriceAverage();\r\n        (priceAverageA_, priceAverageB_) = _tokenA == _token0\r\n            ? (_priceAverage0, _priceAverage1)\r\n            : (_priceAverage1, _priceAverage0);\r\n    }\r\n\r\n    /**\r\n     * @notice given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n     * @param _amountA amount of asset A\r\n     * @param _reserveA reserve of asset A\r\n     * @param _reserveB reserve of asset B\r\n     * @return amountB_ equivalent amount of asset B\r\n     */\r\n    function quote(uint256 _amountA, uint256 _reserveA, uint256 _reserveB) internal pure returns (uint256 amountB_) {\r\n        require(_amountA != 0, \"SmardexHelper: INSUFFICIENT_AMOUNT\");\r\n        require(_reserveA != 0 && _reserveB != 0, \"SmardexHelper: INSUFFICIENT_LIQUIDITY\");\r\n        amountB_ = (_amountA * _reserveB) / _reserveA;\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/SmardexRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// libraries\r\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\r\nimport \"../core/libraries/TransferHelper.sol\";\r\nimport \"./libraries/PoolAddress.sol\";\r\nimport \"./libraries/Path.sol\";\r\n\r\n// interfaces\r\nimport \"../core/interfaces/ISmardexFactory.sol\";\r\nimport \"../core/interfaces/ISmardexPair.sol\";\r\nimport \"./interfaces/ISmardexRouter.sol\";\r\nimport \"./interfaces/IWETH.sol\";\r\n\r\n/**\r\n * @title SmardexRouter\r\n * @notice Router for execution of swaps and liquidity management on SmardexPair\r\n */\r\ncontract SmardexRouter is ISmardexRouter {\r\n    using Path for bytes;\r\n    using Path for address[];\r\n    using SafeCast for uint256;\r\n    using SafeCast for int256;\r\n\r\n    address public immutable factory;\r\n    address public immutable WETH;\r\n\r\n    mapping(bytes32 => address) whitelist;\r\n\r\n    /// @dev Used as the placeholder value for amountInCached, because the computed amount in for an exact output swap\r\n    /// can never actually be this value\r\n    uint256 private constant DEFAULT_AMOUNT_IN_CACHED = type(uint256).max;\r\n\r\n    /// @dev Transient storage variable used for returning the computed amount in for an exact output swap.\r\n    uint256 private amountInCached = DEFAULT_AMOUNT_IN_CACHED;\r\n\r\n    modifier ensure(uint256 deadline) {\r\n        require(deadline >= block.timestamp, \"SmarDexRouter: EXPIRED\");\r\n        _;\r\n    }\r\n\r\n    /**\r\n     * @param _factory address of the factory used to get pair address\r\n     * @param _WETH address of the WETH token\r\n     */\r\n    constructor(address _factory, address _WETH) {\r\n        factory = _factory;\r\n        WETH = _WETH;\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function addPairToWhitelist(address _tokenA, address _tokenB) external virtual override returns (address pair_) {\r\n        // gas savings\r\n        address _factory = factory;\r\n\r\n        // calculate the pair address if created by the current factory\r\n        bytes32 _tokenHash = PoolAddress.getTokenHash(_factory, _tokenA, _tokenB);\r\n        // get the effective pair address\r\n        pair_ = ISmardexFactory(_factory).getPair(_tokenA, _tokenB);\r\n        // check that the pair exists in the factory\r\n        require(pair_ != address(0), \"SmardexRouter: PAIR_MISSING\");\r\n        // check that the pair was added to the whitelist and is not a new pair\r\n        require(address(uint160(uint256(_tokenHash))) != pair_, \"SmardexRouter: NOT_WHITELISTABLE\");\r\n\r\n        // use the pair from the factory, to ensure the same pair is used for the same tokens\r\n        whitelist[_tokenHash] = pair_;\r\n\r\n        emit PairWhitelisted(_tokenA, _tokenB, pair_);\r\n    }\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    /// @inheritdoc ISmardexSwapCallback\r\n    function smardexSwapCallback(int256 _amount0Delta, int256 _amount1Delta, bytes calldata _data) external override {\r\n        require(_amount0Delta > 0 || _amount1Delta > 0, \"SmardexRouter: Callback Invalid amount\");\r\n\r\n        SwapCallbackData memory _decodedData = abi.decode(_data, (SwapCallbackData));\r\n        (address _tokenIn, address _tokenOut) = _decodedData.path.decodeFirstPool();\r\n\r\n        // ensure that msg.sender is a pair\r\n        require(\r\n            msg.sender == PoolAddress.pairFor(factory, _tokenIn, _tokenOut, whitelist),\r\n            \"SmarDexRouter: INVALID_PAIR\"\r\n        );\r\n\r\n        (bool _isExactInput, uint256 _amountToPay) = _amount0Delta > 0\r\n            ? (_tokenIn < _tokenOut, uint256(_amount0Delta))\r\n            : (_tokenOut < _tokenIn, uint256(_amount1Delta));\r\n\r\n        if (_isExactInput) {\r\n            _pay(_tokenIn, _decodedData.payer, msg.sender, _amountToPay);\r\n        } else if (_decodedData.path.hasMultiplePools()) {\r\n            _decodedData.path = _decodedData.path.skipToken();\r\n            _swapExactOut(_amountToPay, msg.sender, _decodedData);\r\n        } else {\r\n            amountInCached = _amountToPay;\r\n            _tokenIn = _tokenOut; // swap in/out because exact output swaps are reversed\r\n            _pay(_tokenIn, _decodedData.payer, msg.sender, _amountToPay);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice send tokens to a user. Handle transfer/transferFrom and WETH / ETH or any ERC20 token\r\n     * @param _token The token to pay\r\n     * @param _payer The entity that must pay\r\n     * @param _to The entity that will receive payment\r\n     * @param _value The amount to pay\r\n     *\r\n     * @custom:from UniV3 PeripheryPayments.sol\r\n     * @custom:url https://github.com/Uniswap/v3-periphery/blob/v1.3.0/contracts/base/PeripheryPayments.sol\r\n     */\r\n    function _pay(address _token, address _payer, address _to, uint256 _value) internal {\r\n        if (_token == WETH && address(this).balance >= _value) {\r\n            // pay with WETH\r\n            IWETH(WETH).deposit{ value: _value }(); // wrap only what is needed to pay\r\n            IWETH(WETH).transfer(_to, _value);\r\n            //refund dust eth, if any ?\r\n        } else if (_payer == address(this)) {\r\n            // pay with tokens already in the contract (for the exact input multihop case)\r\n            TransferHelper.safeTransfer(_token, _to, _value);\r\n        } else {\r\n            // pull payment\r\n            TransferHelper.safeTransferFrom(_token, _payer, _to, _value);\r\n        }\r\n    }\r\n\r\n    ///@inheritdoc ISmardexMintCallback\r\n    function smardexMintCallback(MintCallbackData calldata _data) external override {\r\n        // ensure that msg.sender is a pair\r\n        require(\r\n            msg.sender == PoolAddress.pairFor(factory, _data.token0, _data.token1, whitelist),\r\n            \"SmarDexRouter: INVALID_PAIR\"\r\n        );\r\n        require(_data.amount0 != 0 || _data.amount1 != 0, \"SmardexRouter: Callback Invalid amount\");\r\n\r\n        _pay(_data.token0, _data.payer, msg.sender, _data.amount0);\r\n        _pay(_data.token1, _data.payer, msg.sender, _data.amount1);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function addLiquidity(\r\n        AddLiquidityParams calldata _params,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external virtual override ensure(_deadline) returns (uint256 amountA_, uint256 amountB_, uint256 liquidity_) {\r\n        address _pair;\r\n        (amountA_, amountB_, _pair) = _addLiquidity(_params);\r\n        bool _orderedPair = _params.tokenA < _params.tokenB;\r\n        liquidity_ = ISmardexPair(_pair).mint(\r\n            _to,\r\n            _orderedPair ? amountA_ : amountB_,\r\n            _orderedPair ? amountB_ : amountA_,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function addLiquidityETH(\r\n        AddLiquidityETHParams calldata _params,\r\n        address _to,\r\n        uint256 _deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        override\r\n        ensure(_deadline)\r\n        returns (uint256 amountToken_, uint256 amountETH_, uint256 liquidity_)\r\n    {\r\n        AddLiquidityParams memory _p = AddLiquidityParams({\r\n            tokenA: _params.token,\r\n            tokenB: WETH,\r\n            amountADesired: _params.amountTokenDesired,\r\n            amountBDesired: msg.value,\r\n            amountAMin: _params.amountTokenMin,\r\n            amountBMin: _params.amountETHMin,\r\n            fictiveReserveB: _params.fictiveReserveETH,\r\n            fictiveReserveAMin: _params.fictiveReserveTokenMin,\r\n            fictiveReserveAMax: _params.fictiveReserveTokenMax\r\n        });\r\n        address _pair;\r\n        (amountToken_, amountETH_, _pair) = _addLiquidity(_p);\r\n\r\n        bool _orderedPair = _params.token < WETH;\r\n        liquidity_ = ISmardexPair(_pair).mint(\r\n            _to,\r\n            _orderedPair ? amountToken_ : amountETH_,\r\n            _orderedPair ? amountETH_ : amountToken_,\r\n            msg.sender\r\n        );\r\n\r\n        // refund dust eth, if any\r\n        if (msg.value > amountETH_) {\r\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH_);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function removeLiquidity(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _liquidity,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public virtual override ensure(_deadline) returns (uint256 amountA_, uint256 amountB_) {\r\n        address _pair = PoolAddress.pairFor(factory, _tokenA, _tokenB, whitelist);\r\n        ISmardexPair(_pair).transferFrom(msg.sender, _pair, _liquidity); // send liquidity to pair\r\n\r\n        (uint256 _amount0, uint256 _amount1) = ISmardexPair(_pair).burn(_to);\r\n        (address _token0, ) = PoolHelpers.sortTokens(_tokenA, _tokenB);\r\n        (amountA_, amountB_) = _tokenA == _token0 ? (_amount0, _amount1) : (_amount1, _amount0);\r\n\r\n        require(amountA_ >= _amountAMin, \"SmarDexRouter: INSUFFICIENT_A_AMOUNT\");\r\n        require(amountB_ >= _amountBMin, \"SmarDexRouter: INSUFFICIENT_B_AMOUNT\");\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function removeLiquidityETH(\r\n        address _token,\r\n        uint256 _liquidity,\r\n        uint256 _amountTokenMin,\r\n        uint256 _amountETHMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public virtual override ensure(_deadline) returns (uint256 amountToken_, uint256 amountETH_) {\r\n        (amountToken_, amountETH_) = removeLiquidity(\r\n            _token,\r\n            WETH,\r\n            _liquidity,\r\n            _amountTokenMin,\r\n            _amountETHMin,\r\n            address(this),\r\n            _deadline\r\n        );\r\n        TransferHelper.safeTransfer(_token, _to, amountToken_);\r\n        IWETH(WETH).withdraw(amountETH_);\r\n        TransferHelper.safeTransferETH(_to, amountETH_);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function removeLiquidityWithPermit(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _liquidity,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external virtual override returns (uint256 amountA_, uint256 amountB_) {\r\n        address _pair = PoolAddress.pairFor(factory, _tokenA, _tokenB, whitelist);\r\n        uint256 _value = _approveMax ? type(uint256).max : _liquidity;\r\n        // Check and execute permit. In case of failure, we don't want to revert because it's a vector for griefing.\r\n        // transferFrom call will revert in case allowance is not sufficient.\r\n        try ISmardexPair(_pair).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s) {} catch {}\r\n\r\n        (amountA_, amountB_) = removeLiquidity(_tokenA, _tokenB, _liquidity, _amountAMin, _amountBMin, _to, _deadline);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function removeLiquidityETHWithPermit(\r\n        address _token,\r\n        uint256 _liquidity,\r\n        uint256 _amountTokenMin,\r\n        uint256 _amountETHMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external virtual override returns (uint256 amountToken_, uint256 amountETH_) {\r\n        address _pair = PoolAddress.pairFor(factory, _token, WETH, whitelist);\r\n        uint256 _value = _approveMax ? type(uint256).max : _liquidity;\r\n        // Check and execute permit. In case of failure, we don't want to revert because it's a vector for griefing.\r\n        // transferFrom call will revert in case allowance is not sufficient.\r\n        try ISmardexPair(_pair).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s) {} catch {}\r\n        (amountToken_, amountETH_) = removeLiquidityETH(\r\n            _token,\r\n            _liquidity,\r\n            _amountTokenMin,\r\n            _amountETHMin,\r\n            _to,\r\n            _deadline\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function swapExactTokensForTokens(\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public virtual override ensure(_deadline) returns (uint256 amountOut_) {\r\n        address _payer = msg.sender; // msg.sender pays for the first hop\r\n\r\n        bytes memory _bytesPath = _path.encodeTightlyPacked(); //could be done in the caller function\r\n        while (true) {\r\n            bool _hasMultiplePools = _bytesPath.hasMultiplePools();\r\n\r\n            // the outputs of prior swaps become the inputs to subsequent ones\r\n            _amountIn = _swapExactIn(\r\n                _amountIn,\r\n                // for intermediate swaps, this contract custodies\r\n                _hasMultiplePools ? address(this) : _to,\r\n                // only the first pool in the path is necessary\r\n                SwapCallbackData({ path: _bytesPath.getFirstPool(), payer: _payer })\r\n            );\r\n\r\n            // decide whether to continue or terminate\r\n            if (_hasMultiplePools) {\r\n                _payer = address(this); // at this point, the caller has paid\r\n                _bytesPath = _bytesPath.skipToken();\r\n            } else {\r\n                // amountOut of the final swap is the last amountIn captured in the loop\r\n                amountOut_ = _amountIn;\r\n                break;\r\n            }\r\n        }\r\n        require(amountOut_ >= _amountOutMin, \"SmarDexRouter: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function swapExactTokensForTokensWithPermit(\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external virtual override returns (uint256 amountOut_) {\r\n        uint256 _value = _approveMax ? type(uint256).max : _amountIn;\r\n        // Check and execute permit. In case of failure, we don't want to revert because it's a vector for griefing.\r\n        // transferFrom call will revert in case allowance is not sufficient.\r\n        try IERC20Permit(_path[0]).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s) {} catch {}\r\n\r\n        return swapExactTokensForTokens(_amountIn, _amountOutMin, _path, _to, _deadline);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function swapTokensForExactTokens(\r\n        uint256 _amountOut,\r\n        uint256 _amountInMax,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public virtual override ensure(_deadline) returns (uint256 amountIn_) {\r\n        // Path needs to be reversed as to get the amountIn that we will ask from next pair hop\r\n        bytes memory _reversedPath = _path.encodeTightlyPackedReversed();\r\n        amountIn_ = _swapExactOut(_amountOut, _to, SwapCallbackData({ path: _reversedPath, payer: msg.sender }));\r\n        // amount In is only the right one for one Hop, otherwise we need cached amountIn from callback\r\n        if (_path.length > 2) amountIn_ = amountInCached;\r\n        require(amountIn_ <= _amountInMax, \"SmarDexRouter: EXCESSIVE_INPUT_AMOUNT\");\r\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function swapTokensForExactTokensWithPermit(\r\n        uint256 _amountOut,\r\n        uint256 _amountInMax,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external virtual override returns (uint256 amountIn_) {\r\n        uint256 _value = _approveMax ? type(uint256).max : _amountInMax;\r\n        // Check and execute permit. In case of failure, we don't want to revert because it's a vector for griefing.\r\n        // transferFrom call will revert in case allowance is not sufficient.\r\n        try IERC20Permit(_path[0]).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s) {} catch {}\r\n\r\n        return swapTokensForExactTokens(_amountOut, _amountInMax, _path, _to, _deadline);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function swapTokensForExactETH(\r\n        uint256 _amountOut,\r\n        uint256 _amountInMax,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public virtual override ensure(_deadline) returns (uint256 amountIn_) {\r\n        require(_path[_path.length - 1] == WETH, \"SmarDexRouter: INVALID_PATH\");\r\n        amountIn_ = swapTokensForExactTokens(_amountOut, _amountInMax, _path, address(this), _deadline);\r\n        _unwrapWETH(_amountOut, _to);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function swapTokensForExactETHWithPermit(\r\n        uint256 _amountOut,\r\n        uint256 _amountInMax,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external virtual override returns (uint256 amountIn_) {\r\n        uint256 _value = _approveMax ? type(uint256).max : _amountInMax;\r\n        // Check and execute permit. In case of failure, we don't want to revert because it's a vector for griefing.\r\n        // transferFrom call will revert in case allowance is not sufficient.\r\n        try IERC20Permit(_path[0]).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s) {} catch {}\r\n\r\n        return swapTokensForExactETH(_amountOut, _amountInMax, _path, _to, _deadline);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function swapETHForExactTokens(\r\n        uint256 _amountOut,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable virtual override ensure(_deadline) returns (uint256 amountIn_) {\r\n        require(_path[0] == WETH, \"SmarDexRouter: INVALID_PATH\");\r\n        amountIn_ = swapTokensForExactTokens(_amountOut, msg.value, _path, _to, _deadline);\r\n\r\n        // Refund unused ETH\r\n        _refundETH(msg.sender);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function swapExactETHForTokens(\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable virtual override ensure(_deadline) returns (uint256 amountOut_) {\r\n        require(_path[0] == WETH, \"SmarDexRouter: INVALID_PATH\");\r\n        amountOut_ = swapExactTokensForTokens(msg.value, _amountOutMin, _path, _to, _deadline);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function swapExactTokensForETH(\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public virtual override ensure(_deadline) returns (uint256 amountOut_) {\r\n        require(_path[_path.length - 1] == WETH, \"SmarDexRouter: INVALID_PATH\");\r\n        amountOut_ = swapExactTokensForTokens(_amountIn, _amountOutMin, _path, address(this), _deadline);\r\n        _unwrapWETH(amountOut_, _to);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function swapExactTokensForETHWithPermit(\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external virtual override returns (uint256 amountOut_) {\r\n        uint256 _value = _approveMax ? type(uint256).max : _amountIn;\r\n        // Check and execute permit. In case of failure, we don't want to revert because it's a vector for griefing.\r\n        // transferFrom call will revert in case allowance is not sufficient.\r\n        try IERC20Permit(_path[0]).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s) {} catch {}\r\n\r\n        return swapExactTokensForETH(_amountIn, _amountOutMin, _path, _to, _deadline);\r\n    }\r\n\r\n    /**\r\n     * @notice internal function to unwrap WETH to ETH after swap\r\n     * @param _amountMinimum minimum amount of WETH that the contract should have\r\n     * @param _to address that will receive the ETH unwrapped\r\n     *\r\n     * @custom:from UniV3 PeripheryPayments.sol\r\n     * @custom:url https://github.com/Uniswap/v3-periphery/blob/v1.3.0/contracts/base/PeripheryPayments.sol\r\n     */\r\n    function _unwrapWETH(uint256 _amountMinimum, address _to) internal {\r\n        uint256 _balanceWETH = IERC20(WETH).balanceOf(address(this));\r\n        require(_balanceWETH >= _amountMinimum, \"Insufficient WETH\");\r\n\r\n        if (_balanceWETH != 0) {\r\n            IWETH(WETH).withdraw(_balanceWETH);\r\n            TransferHelper.safeTransferETH(_to, _balanceWETH);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice internal function to send all ETH of the contract. Do not fail if the contract does not have any ETH\r\n     * @param _to address that will receive the ETH\r\n     *\r\n     * @custom:from UniV3 PeripheryPayments.sol\r\n     * @custom:url https://github.com/Uniswap/v3-periphery/blob/v1.3.0/contracts/base/PeripheryPayments.sol\r\n     */\r\n    function _refundETH(address _to) private {\r\n        if (address(this).balance != 0) {\r\n            TransferHelper.safeTransferETH(_to, address(this).balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice internal function to swap quantity of token to receive a determined quantity\r\n     * @param _amountOut quantity to receive\r\n     * @param _to address that will receive the token\r\n     * @param _data SwapCallbackData data of the swap to transmit\r\n     * @return amountIn_ amount of token to pay\r\n     */\r\n    function _swapExactOut(\r\n        uint256 _amountOut,\r\n        address _to,\r\n        SwapCallbackData memory _data\r\n    ) private returns (uint256 amountIn_) {\r\n        require(_to != address(0), \"SmarDexRouter: INVALID_RECIPIENT\");\r\n\r\n        (address _tokenOut, address _tokenIn) = _data.path.decodeFirstPool();\r\n        bool _zeroForOne = _tokenIn < _tokenOut;\r\n\r\n        (int256 _amount0, int256 _amount1) = ISmardexPair(PoolAddress.pairFor(factory, _tokenOut, _tokenIn, whitelist))\r\n            .swap(_to, _zeroForOne, -_amountOut.toInt256(), abi.encode(_data));\r\n\r\n        amountIn_ = _zeroForOne ? uint256(_amount0) : uint256(_amount1);\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to an ERC-20=ERC-20 pool. Receive liquidity token to materialize shares in the pool\r\n     * @param _params parameters of the liquidity to add\r\n     * @return amountA_ The amount of tokenA sent to the pool.\r\n     * @return amountB_ The amount of tokenB sent to the pool.\r\n     * @return pair_ The address of the pool where the liquidity was added.\r\n     */\r\n    function _addLiquidity(\r\n        AddLiquidityParams memory _params\r\n    ) internal virtual returns (uint256 amountA_, uint256 amountB_, address pair_) {\r\n        // create the pair if it doesn't exist yet\r\n        pair_ = ISmardexFactory(factory).getPair(_params.tokenA, _params.tokenB);\r\n        if (pair_ == address(0)) {\r\n            pair_ = ISmardexFactory(factory).createPair(_params.tokenA, _params.tokenB);\r\n        }\r\n        if (ISmardexPair(pair_).totalSupply() == 0) {\r\n            ISmardexPair(pair_).skim(msg.sender); // in case some tokens are already on the pair\r\n        }\r\n        (uint256 _reserveA, uint256 _reserveB, uint256 _reserveAFic, uint256 _reserveBFic) = PoolHelpers.getAllReserves(\r\n            factory,\r\n            _params.tokenA,\r\n            _params.tokenB,\r\n            whitelist\r\n        );\r\n        if (_reserveA == 0 && _reserveB == 0) {\r\n            (amountA_, amountB_) = (_params.amountADesired, _params.amountBDesired);\r\n        } else {\r\n            // price slippage check\r\n            // the current price is _reserveAFic / _reserveBFic\r\n            // the max price that the user accepts is _params.fictiveReserveAMax / _params.fictiveReserveB\r\n            // the min price that the user accepts is _params.fictiveReserveAMin / _params.fictiveReserveB\r\n            uint256 _product = _reserveAFic * _params.fictiveReserveB;\r\n            require(_product <= _params.fictiveReserveAMax * _reserveBFic, \"SmarDexRouter: PRICE_TOO_HIGH\");\r\n            require(_product >= _params.fictiveReserveAMin * _reserveBFic, \"SmarDexRouter: PRICE_TOO_LOW\");\r\n\r\n            // real reserves slippage check\r\n            uint256 _amountBOptimal = PoolHelpers.quote(_params.amountADesired, _reserveA, _reserveB);\r\n            if (_amountBOptimal <= _params.amountBDesired) {\r\n                require(_amountBOptimal >= _params.amountBMin, \"SmarDexRouter: INSUFFICIENT_B_AMOUNT\");\r\n                (amountA_, amountB_) = (_params.amountADesired, _amountBOptimal);\r\n            } else {\r\n                uint256 _amountAOptimal = PoolHelpers.quote(_params.amountBDesired, _reserveB, _reserveA);\r\n                assert(_amountAOptimal <= _params.amountADesired);\r\n                require(_amountAOptimal >= _params.amountAMin, \"SmarDexRouter: INSUFFICIENT_A_AMOUNT\");\r\n                (amountA_, amountB_) = (_amountAOptimal, _params.amountBDesired);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice internal function to swap a determined quantity of token\r\n     * @param _amountIn quantity to swap\r\n     * @param _to address that will receive the token\r\n     * @param _data SwapCallbackData data of the swap to transmit\r\n     * @return amountOut_ amount of token that _to will receive\r\n     */\r\n    function _swapExactIn(\r\n        uint256 _amountIn,\r\n        address _to,\r\n        SwapCallbackData memory _data\r\n    ) internal returns (uint256 amountOut_) {\r\n        // allow swapping to the router address with address 0\r\n        if (_to == address(0)) {\r\n            _to = address(this);\r\n        }\r\n\r\n        (address _tokenIn, address _tokenOut) = _data.path.decodeFirstPool();\r\n        bool _zeroForOne = _tokenIn < _tokenOut;\r\n        (int256 _amount0, int256 _amount1) = ISmardexPair(PoolAddress.pairFor(factory, _tokenIn, _tokenOut, whitelist))\r\n            .swap(_to, _zeroForOne, _amountIn.toInt256(), abi.encode(_data));\r\n\r\n        amountOut_ = (_zeroForOne ? -_amount1 : -_amount0).toUint256();\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function quote(\r\n        uint256 _amountA,\r\n        uint256 _reserveA,\r\n        uint256 _reserveB\r\n    ) public pure virtual override returns (uint256 amountB_) {\r\n        return PoolHelpers.quote(_amountA, _reserveA, _reserveB);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function getAmountOut(\r\n        SmardexLibrary.GetAmountParameters memory _param\r\n    )\r\n        external\r\n        pure\r\n        returns (\r\n            uint256 amountOut_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        /// @dev The values _priceAverageIn and _priceAverageOut are not directly fetched from the pair,\r\n        ///      and therefore, they may not necessarily be up to date with the most recent data. In\r\n        ///      order to yield a _amountOut that represents the most current value, it is crucial that\r\n        ///      the args _priceAverageIn and _priceAverageOut reflects the latest, updated data.\r\n        (amountOut_, newReserveIn_, newReserveOut_, newFictiveReserveIn_, newFictiveReserveOut_) = SmardexLibrary\r\n            .getAmountOut(_param);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function getAmountIn(\r\n        SmardexLibrary.GetAmountParameters memory _param\r\n    )\r\n        external\r\n        pure\r\n        returns (\r\n            uint256 amountIn_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        (amountIn_, newReserveIn_, newReserveOut_, newFictiveReserveIn_, newFictiveReserveOut_) = SmardexLibrary\r\n            .getAmountIn(_param);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function getAmountOutFromPair(\r\n        uint256 _amountIn,\r\n        address _tokenIn,\r\n        address _tokenOut\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 amountOut_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        SmardexLibrary.GetAmountParameters memory _param;\r\n        _param.amount = _amountIn;\r\n\r\n        ISmardexPair _pair = ISmardexPair(ISmardexFactory(factory).getPair(_tokenIn, _tokenOut));\r\n        require(address(_pair) != address(0), \"SmarDexRouter: INVALID_TOKENS\");\r\n        uint256 _priceAverageLastTimestamp;\r\n\r\n        // fetch data\r\n        if (_tokenIn == _pair.token0()) {\r\n            (_param.reserveIn, _param.reserveOut) = _pair.getReserves();\r\n            (_param.fictiveReserveIn, _param.fictiveReserveOut) = _pair.getFictiveReserves();\r\n            (_param.priceAverageIn, _param.priceAverageOut, _priceAverageLastTimestamp) = _pair.getPriceAverage();\r\n        } else {\r\n            (_param.reserveOut, _param.reserveIn) = _pair.getReserves();\r\n            (_param.fictiveReserveOut, _param.fictiveReserveIn) = _pair.getFictiveReserves();\r\n            (_param.priceAverageOut, _param.priceAverageIn, _priceAverageLastTimestamp) = _pair.getPriceAverage();\r\n        }\r\n\r\n        // update price average\r\n        (_param.priceAverageIn, _param.priceAverageOut) = _pair.getUpdatedPriceAverage(\r\n            _param.fictiveReserveIn,\r\n            _param.fictiveReserveOut,\r\n            _priceAverageLastTimestamp,\r\n            _param.priceAverageIn,\r\n            _param.priceAverageOut,\r\n            block.timestamp\r\n        );\r\n\r\n        // get pair fees\r\n        (_param.feesLP, _param.feesPool) = _pair.getPairFees();\r\n\r\n        (amountOut_, newReserveIn_, newReserveOut_, newFictiveReserveIn_, newFictiveReserveOut_) = SmardexLibrary\r\n            .getAmountOut(_param);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function getAmountInFromPair(\r\n        uint256 _amountOut,\r\n        address _tokenIn,\r\n        address _tokenOut\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 amountIn_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        SmardexLibrary.GetAmountParameters memory _param;\r\n        _param.amount = _amountOut;\r\n\r\n        ISmardexPair _pair = ISmardexPair(ISmardexFactory(factory).getPair(_tokenIn, _tokenOut));\r\n        require(address(_pair) != address(0), \"SmarDexRouter: INVALID_TOKENS\");\r\n        uint256 _priceAverageLastTimestamp;\r\n\r\n        // fetch data\r\n        if (_tokenIn == _pair.token0()) {\r\n            (_param.reserveIn, _param.reserveOut) = _pair.getReserves();\r\n            (_param.fictiveReserveIn, _param.fictiveReserveOut) = _pair.getFictiveReserves();\r\n            (_param.priceAverageIn, _param.priceAverageOut, _priceAverageLastTimestamp) = _pair.getPriceAverage();\r\n        } else {\r\n            (_param.reserveOut, _param.reserveIn) = _pair.getReserves();\r\n            (_param.fictiveReserveOut, _param.fictiveReserveIn) = _pair.getFictiveReserves();\r\n            (_param.priceAverageOut, _param.priceAverageIn, _priceAverageLastTimestamp) = _pair.getPriceAverage();\r\n        }\r\n\r\n        // update price average\r\n        (_param.priceAverageIn, _param.priceAverageOut) = _pair.getUpdatedPriceAverage(\r\n            _param.fictiveReserveIn,\r\n            _param.fictiveReserveOut,\r\n            _priceAverageLastTimestamp,\r\n            _param.priceAverageIn,\r\n            _param.priceAverageOut,\r\n            block.timestamp\r\n        );\r\n\r\n        // get pair fees\r\n        (_param.feesLP, _param.feesPool) = _pair.getPairFees();\r\n\r\n        (amountIn_, newReserveIn_, newReserveOut_, newFictiveReserveIn_, newFictiveReserveOut_) = SmardexLibrary\r\n            .getAmountIn(_param);\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/test/CallbackTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity =0.8.17;\r\n\r\n//libraries\r\nimport \"../../core/libraries/TransferHelper.sol\";\r\nimport \"../libraries/PoolAddress.sol\";\r\n//interfaces\r\nimport \"../interfaces/ISmardexRouter.sol\";\r\nimport \"../libraries/Path.sol\";\r\n\r\ncontract CallbackTest {\r\n    using Path for bytes;\r\n\r\n    address public immutable factory;\r\n    address public immutable WETH;\r\n    bool public isToken0ToLower;\r\n\r\n    constructor(address _factory, address _weth) {\r\n        factory = _factory;\r\n        WETH = _weth;\r\n    }\r\n\r\n    struct SwapCallbackData {\r\n        bytes path;\r\n        address payer;\r\n    }\r\n\r\n    function setIsToken0ToLower(bool _isToken0ToLower) external {\r\n        isToken0ToLower = _isToken0ToLower;\r\n    }\r\n\r\n    // From UniV3 PeripheryPayments.sol\r\n    // https://github.com/Uniswap/v3-periphery/blob/v1.3.0/contracts/base/PeripheryPayments.sol\r\n    /// @param _token The token to pay\r\n    /// @param _payer The entity that must pay\r\n    /// @param _to The entity that will receive payment\r\n    /// @param _value The amount to pay\r\n    function pay(address _token, address _payer, address _to, uint256 _value) internal {\r\n        // pull payment\r\n        TransferHelper.safeTransferFrom(_token, _payer, _to, _value);\r\n    }\r\n\r\n    function smardexMintCallback(ISmardexMintCallback.MintCallbackData calldata _data) external {\r\n        require(_data.amount0 > 0 || _data.amount1 > 0, \"SmardexRouter: Callback Invalid amount\");\r\n        require(\r\n            msg.sender == ISmardexFactory(factory).getPair(_data.token0, _data.token1),\r\n            \"SmarDexRouter: INVALID_PAIR\"\r\n        ); // ensure that msg.sender is a pair\r\n        pay(_data.token0, _data.payer, msg.sender, isToken0ToLower ? _data.amount0 - 1 : _data.amount0);\r\n        // we send less token 1 than expected\r\n        pay(_data.token1, _data.payer, msg.sender, isToken0ToLower ? _data.amount1 : _data.amount1 - 1);\r\n    }\r\n\r\n    function smardexSwapCallback(int256 _amount0Delta, int256 _amount1Delta, bytes calldata _data) external {\r\n        require(_amount0Delta > 0 || _amount1Delta > 0, \"SmardexRouter: Callback Invalid amount\");\r\n        SwapCallbackData memory _decodedData = abi.decode(_data, (SwapCallbackData));\r\n        (address _tokenIn, address _tokenOut) = _decodedData.path.decodeFirstPool();\r\n        require(msg.sender == ISmardexFactory(factory).getPair(_tokenIn, _tokenOut), \"SmarDexRouter: INVALID_PAIR\"); // ensure that msg.sender is a pair\r\n        (bool _isExactInput, uint256 _amountToPay) = _amount0Delta > 0\r\n            ? (_tokenIn < _tokenOut, uint256(_amount0Delta))\r\n            : (_tokenOut < _tokenIn, uint256(_amount1Delta));\r\n        _amountToPay -= 1;\r\n        if (_isExactInput) {\r\n            pay(_tokenIn, _decodedData.payer, msg.sender, _amountToPay);\r\n        } else {\r\n            _tokenIn = _tokenOut; // swap in/out because exact output swaps are reversed\r\n            pay(_tokenIn, _decodedData.payer, msg.sender, _amountToPay);\r\n        }\r\n    }\r\n\r\n    function addLiquidity(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _amountADesired,\r\n        uint256 _amountBDesired,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 liquidity_) {\r\n        require(_deadline >= block.timestamp, \"SmardexRouter: EXPIRED\");\r\n        address _pair = ISmardexFactory(factory).getPair(_tokenA, _tokenB);\r\n        bool _orderedPair = _tokenA < _tokenB;\r\n        liquidity_ = ISmardexPair(_pair).mint(\r\n            _to,\r\n            _orderedPair ? _amountADesired : _amountBDesired,\r\n            _orderedPair ? _amountBDesired : _amountADesired,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    function swap(address _pair, address _to, bool _zeroForOne, int256 _amountSpecified, bytes calldata _path) public {\r\n        ISmardexPair(_pair).swap(_to, _zeroForOne, _amountSpecified, _path);\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/test/DoubleSwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// libraries\r\nimport \"../../core/libraries/TransferHelper.sol\";\r\n\r\n//interfaces\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../interfaces/ISmardexRouter.sol\";\r\n\r\ncontract DoubleSwapRouter {\r\n    function doubleSwapExactInExactOut(\r\n        ISmardexRouter router,\r\n        uint256 amountIn,\r\n        uint256 maxAmountIn,\r\n        address[] calldata path\r\n    ) external {\r\n        address[] memory pathReversed = new address[](2);\r\n        (pathReversed[0], pathReversed[1]) = (path[1], path[0]);\r\n        TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), amountIn);\r\n        TransferHelper.safeApprove(path[0], address(router), amountIn);\r\n        router.swapExactTokensForTokens(amountIn, 1, path, msg.sender, block.timestamp);\r\n\r\n        TransferHelper.safeTransferFrom(path[1], msg.sender, address(this), maxAmountIn);\r\n        TransferHelper.safeApprove(path[1], address(router), maxAmountIn);\r\n        router.swapTokensForExactTokens(amountIn, maxAmountIn, pathReversed, msg.sender, block.timestamp);\r\n\r\n        TransferHelper.safeTransfer(path[0], msg.sender, IERC20(path[0]).balanceOf(address(this)));\r\n        TransferHelper.safeTransfer(path[1], msg.sender, IERC20(path[1]).balanceOf(address(this)));\r\n    }\r\n\r\n    function doubleSwapExactOutExactIn(\r\n        ISmardexRouter router,\r\n        uint256 amountOut,\r\n        uint256 maxAmountIn,\r\n        address[] calldata path\r\n    ) external {\r\n        address[] memory pathReversed = new address[](2);\r\n        (pathReversed[0], pathReversed[1]) = (path[1], path[0]);\r\n        TransferHelper.safeTransferFrom(path[0], msg.sender, address(this), maxAmountIn);\r\n        TransferHelper.safeApprove(path[0], address(router), maxAmountIn);\r\n        router.swapTokensForExactTokens(amountOut, maxAmountIn, path, msg.sender, block.timestamp);\r\n\r\n        TransferHelper.safeTransferFrom(path[1], msg.sender, address(this), amountOut);\r\n        TransferHelper.safeApprove(path[1], address(router), maxAmountIn);\r\n        router.swapExactTokensForTokens(amountOut, 1, pathReversed, msg.sender, block.timestamp);\r\n\r\n        TransferHelper.safeTransfer(path[0], msg.sender, IERC20(path[0]).balanceOf(address(this)));\r\n        TransferHelper.safeTransfer(path[1], msg.sender, IERC20(path[1]).balanceOf(address(this)));\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/test/FakeERC20reentrancy.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.8.17;\r\n\r\n//contracts\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n//libraries\r\nimport \"../libraries/PoolAddress.sol\";\r\n\r\n//interfaces\r\nimport \"../interfaces/ISmardexRouter.sol\";\r\nimport \"../../core/interfaces/ISmardexFactory.sol\";\r\n\r\ncontract FakeERC20reentrancy is ERC20 {\r\n    address public immutable factory;\r\n    address public immutable WETH;\r\n\r\n    bool private active = false;\r\n\r\n    error PairNotFound(address token0, address token1);\r\n\r\n    constructor(address _factory, address _weth) ERC20(\"FakeERC20reentrancy\", \"FRE\") {\r\n        factory = _factory;\r\n        WETH = _weth;\r\n        _mint(msg.sender, 100_000_000 ether);\r\n    }\r\n\r\n    function activate() external {\r\n        active = !active;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        if (active && recipient == ISmardexFactory(factory).getPair(address(this), WETH)) {\r\n            active = false;\r\n            //try to reentrancy add liquidity\r\n            ISmardexPair(recipient).mint(address(this), 100, 100, address(this));\r\n        }\r\n        return super.transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    struct SwapCallbackData {\r\n        address payer;\r\n        bytes path;\r\n    }\r\n\r\n    // From UniV3 PeripheryPayments.sol\r\n    // https://github.com/Uniswap/v3-periphery/blob/v1.3.0/contracts/base/PeripheryPayments.sol\r\n    /// @param _token The token to pay\r\n    /// @param _payer The entity that must pay\r\n    /// @param _to The entity that will receive payment\r\n    /// @param _value The amount to pay\r\n    function pay(address _token, address _payer, address _to, uint256 _value) internal {\r\n        // pull payment\r\n        if (_token == address(this)) transferFrom(_payer, _to, _value);\r\n        else IERC20(_token).transferFrom(_payer, _to, _value);\r\n    }\r\n\r\n    function smardexMintCallback(ISmardexMintCallback.MintCallbackData calldata _data) external {\r\n        require(_data.amount0 > 0 || _data.amount1 > 0, \"SmardexRouter: Callback Invalid amount\");\r\n        require(\r\n            msg.sender == ISmardexFactory(factory).getPair(_data.token0, _data.token1),\r\n            \"SmarDexRouter: INVALID_PAIR\"\r\n        ); // ensure that msg.sender is a pair\r\n        // ISmardexPair(msg.sender).mint(address(this), 1, 1, _data.payer);\r\n        pay(_data.token0, _data.payer, msg.sender, _data.amount0);\r\n        pay(_data.token1, _data.payer, msg.sender, _data.amount1);\r\n    }\r\n\r\n    function addLiquidity(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _amountADesired,\r\n        uint256 _amountBDesired,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public returns (uint256 liquidity_) {\r\n        require(_deadline >= block.timestamp, \"SmardexRouter: EXPIRED\");\r\n        address _pair = ISmardexFactory(factory).getPair(_tokenA, _tokenB);\r\n        if (_pair == address(0)) {\r\n            revert PairNotFound(_tokenA, _tokenB);\r\n        }\r\n        bool _orderedPair = _tokenA < _tokenB;\r\n        liquidity_ = ISmardexPair(_pair).mint(\r\n            _to,\r\n            _orderedPair ? _amountADesired : _amountBDesired,\r\n            _orderedPair ? _amountBDesired : _amountADesired,\r\n            msg.sender\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/test/peripheryV2WithV1/libraries/PoolAddressV1.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// libraries\r\nimport \"./PoolHelpersV1.sol\";\r\n\r\n// interfaces\r\nimport \"../../../../core/interfaces/ISmardexFactory.sol\";\r\n\r\nlibrary PoolAddressV1 {\r\n    /**\r\n     * @notice Deterministically computes the pool address given the factory and PoolKey\r\n     * @param _factory The SmarDex factory contract address\r\n     * @param _tokenA The first token of the pool\r\n     * @param _tokenB The second token of the pool\r\n     * @return pair_ The contract address of the SmardexPair\r\n     */\r\n    function pairFor(address _factory, address _tokenA, address _tokenB) internal pure returns (address pair_) {\r\n        (address token0, address token1) = PoolHelpersV1.sortTokens(_tokenA, _tokenB);\r\n        pair_ = address(\r\n            uint160(\r\n                uint256(\r\n                    keccak256(\r\n                        abi.encodePacked(\r\n                            hex\"ff\",\r\n                            _factory,\r\n                            keccak256(abi.encodePacked(token0, token1)),\r\n                            hex\"6d32bf72ec5cc02d3e64eaf60f63b064ca3cd98c7661d933bab660a552327576\" // init code hash\r\n                        )\r\n                    )\r\n                )\r\n            )\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/test/peripheryV2WithV1/libraries/PoolHelpersV1.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// libraries\r\nimport \"./PoolAddressV1.sol\";\r\nimport \"../../../../core/test/coreV1/libraries/SmardexLibraryV1.sol\";\r\n\r\n// interfaces\r\nimport \"../../../../core/test/coreV1/interfaces/ISmardexPairV1.sol\";\r\n\r\nlibrary PoolHelpersV1 {\r\n    /**\r\n     * @notice sort token addresses, used to handle return values from pairs sorted in this order\r\n     * @param _tokenA token to sort\r\n     * @param _tokenB token to sort\r\n     * @return token0_ token0 sorted\r\n     * @return token1_ token1 sorted\r\n     */\r\n    function sortTokens(address _tokenA, address _tokenB) internal pure returns (address token0_, address token1_) {\r\n        require(_tokenA != _tokenB, \"SmardexHelper: IDENTICAL_ADDRESSES\");\r\n        (token0_, token1_) = _tokenA < _tokenB ? (_tokenA, _tokenB) : (_tokenB, _tokenA);\r\n        require(token0_ != address(0), \"SmardexHelper: ZERO_ADDRESS\");\r\n    }\r\n\r\n    /**\r\n     * @notice fetches the reserves for a pair\r\n     * @param _factory the factory address\r\n     * @param _tokenA token to fetch reserves\r\n     * @param _tokenB token to fetch reserves\r\n     * @return reserveA_ reserves of tokenA in the pair tokenA/TokenB\r\n     * @return reserveB_ reserves of tokenB in the pair tokenA/TokenB\r\n     */\r\n    function getReserves(\r\n        address _factory,\r\n        address _tokenA,\r\n        address _tokenB\r\n    ) internal view returns (uint256 reserveA_, uint256 reserveB_) {\r\n        (address _token0, ) = sortTokens(_tokenA, _tokenB);\r\n        (uint256 _reserve0, uint256 _reserve1) = ISmardexPairV1(PoolAddressV1.pairFor(_factory, _tokenA, _tokenB))\r\n            .getReserves();\r\n        (reserveA_, reserveB_) = _tokenA == _token0 ? (_reserve0, _reserve1) : (_reserve1, _reserve0);\r\n    }\r\n\r\n    /**\r\n     * @notice fetches the fictive reserves for a pair\r\n     * @param _factory the factory address\r\n     * @param _tokenA token to fetch fictive reserves\r\n     * @param _tokenB token to fetch fictive reserves\r\n     * @return fictiveReserveA_ fictive reserves of tokenA in the pair tokenA/TokenB\r\n     * @return fictiveReserveB_ fictive reserves of tokenB in the pair tokenA/TokenB\r\n     */\r\n    function getFictiveReserves(\r\n        address _factory,\r\n        address _tokenA,\r\n        address _tokenB\r\n    ) internal view returns (uint256 fictiveReserveA_, uint256 fictiveReserveB_) {\r\n        (address _token0, ) = sortTokens(_tokenA, _tokenB);\r\n        (uint256 _fictiveReserve0, uint256 _fictiveReserve1) = ISmardexPairV1(\r\n            PoolAddressV1.pairFor(_factory, _tokenA, _tokenB)\r\n        ).getFictiveReserves();\r\n        (fictiveReserveA_, fictiveReserveB_) = _tokenA == _token0\r\n            ? (_fictiveReserve0, _fictiveReserve1)\r\n            : (_fictiveReserve1, _fictiveReserve0);\r\n    }\r\n\r\n    /**\r\n     * @notice fetches the real and fictive reserves for a pair\r\n     * @param _factory the factory address\r\n     * @param _tokenA token to fetch fictive reserves\r\n     * @param _tokenB token to fetch fictive reserves\r\n     * @return reserveA_ reserves of tokenA in the pair tokenA/TokenB\r\n     * @return reserveB_ reserves of tokenB in the pair tokenA/TokenB\r\n     * @return fictiveReserveA_ fictive reserves of tokenA in the pair tokenA/TokenB\r\n     * @return fictiveReserveB_ fictive reserves of tokenB in the pair tokenA/TokenB\r\n     */\r\n    function getAllReserves(\r\n        address _factory,\r\n        address _tokenA,\r\n        address _tokenB\r\n    ) internal view returns (uint256 reserveA_, uint256 reserveB_, uint256 fictiveReserveA_, uint256 fictiveReserveB_) {\r\n        (address _token0, ) = sortTokens(_tokenA, _tokenB);\r\n        ISmardexPairV1 _pair = ISmardexPairV1(PoolAddressV1.pairFor(_factory, _tokenA, _tokenB));\r\n        (uint256 _reserve0, uint256 _reserve1) = _pair.getReserves();\r\n        (uint256 _fictiveReserve0, uint256 _fictiveReserve1) = _pair.getFictiveReserves();\r\n        (reserveA_, reserveB_, fictiveReserveA_, fictiveReserveB_) = _tokenA == _token0\r\n            ? (_reserve0, _reserve1, _fictiveReserve0, _fictiveReserve1)\r\n            : (_reserve1, _reserve0, _fictiveReserve1, _fictiveReserve0);\r\n    }\r\n\r\n    /**\r\n     * @notice fetches the priceAverage for a pair\r\n     * @param _factory the factory address\r\n     * @param _tokenA token to fetch priceAverage\r\n     * @param _tokenB token to fetch priceAverage\r\n     * @return priceAverageA_ priceAverage of tokenA in the pair tokenA/TokenB\r\n     * @return priceAverageB_ priceAverage of tokenB in the pair tokenA/TokenB\r\n     */\r\n    function getPriceAverage(\r\n        address _factory,\r\n        address _tokenA,\r\n        address _tokenB\r\n    ) internal view returns (uint256 priceAverageA_, uint256 priceAverageB_) {\r\n        (address _token0, ) = sortTokens(_tokenA, _tokenB);\r\n        (uint256 _priceAverage0, uint256 _priceAverage1, ) = ISmardexPairV1(\r\n            PoolAddressV1.pairFor(_factory, _tokenA, _tokenB)\r\n        ).getPriceAverage();\r\n        (priceAverageA_, priceAverageB_) = _tokenA == _token0\r\n            ? (_priceAverage0, _priceAverage1)\r\n            : (_priceAverage1, _priceAverage0);\r\n    }\r\n\r\n    /**\r\n     * @notice given some amount of an asset and pair reserves, returns an equivalent amount of the other asset\r\n     * @param _amountA amount of asset A\r\n     * @param _reserveA reserve of asset A\r\n     * @param _reserveB reserve of asset B\r\n     * @return amountB_ equivalent amount of asset B\r\n     */\r\n    function quote(uint256 _amountA, uint256 _reserveA, uint256 _reserveB) internal pure returns (uint256 amountB_) {\r\n        require(_amountA != 0, \"SmardexHelper: INSUFFICIENT_AMOUNT\");\r\n        require(_reserveA != 0 && _reserveB != 0, \"SmardexHelper: INSUFFICIENT_LIQUIDITY\");\r\n        amountB_ = (_amountA * _reserveB) / _reserveA;\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/test/peripheryV2WithV1/SmardexRouterV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// libraries\r\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\r\nimport \"../../../core/libraries/TransferHelper.sol\";\r\nimport \"./libraries/PoolAddressV1.sol\";\r\nimport \"../../libraries/Path.sol\";\r\n\r\n// interfaces\r\nimport \"../../../core/interfaces/ISmardexOwnableFactory.sol\";\r\nimport \"../../../core/interfaces/ISmardexPair.sol\";\r\nimport \"../../interfaces/ISmardexRouter.sol\";\r\nimport \"../../interfaces/IWETH.sol\";\r\n\r\n/**\r\n * @title SmardexRouter\r\n * @notice Router for execution of swaps and liquidity management on SmardexPair\r\n */\r\ncontract SmardexRouterV2 is ISmardexRouter {\r\n    using Path for bytes;\r\n    using Path for address[];\r\n    using SafeCast for uint256;\r\n    using SafeCast for int256;\r\n\r\n    address public immutable factory;\r\n    address public immutable WETH;\r\n\r\n    /// @dev Used as the placeholder value for amountInCached, because the computed amount in for an exact output swap\r\n    /// can never actually be this value\r\n    uint256 private constant DEFAULT_AMOUNT_IN_CACHED = type(uint256).max;\r\n\r\n    /// @dev Transient storage variable used for returning the computed amount in for an exact output swap.\r\n    uint256 private amountInCached = DEFAULT_AMOUNT_IN_CACHED;\r\n\r\n    modifier ensure(uint256 deadline) {\r\n        require(deadline >= block.timestamp, \"SmarDexRouter: EXPIRED\");\r\n        _;\r\n    }\r\n\r\n    constructor(address _factory, address _WETH) {\r\n        factory = _factory;\r\n        WETH = _WETH;\r\n    }\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == WETH); // only accept ETH via fallback from the WETH contract\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function addPairToWhitelist(address, address) external virtual override returns (address) {}\r\n\r\n    /// @inheritdoc ISmardexSwapCallback\r\n    function smardexSwapCallback(int256 _amount0Delta, int256 _amount1Delta, bytes calldata _data) external override {\r\n        require(_amount0Delta > 0 || _amount1Delta > 0, \"SmardexRouter: Callback Invalid amount\");\r\n\r\n        SwapCallbackData memory _decodedData = abi.decode(_data, (SwapCallbackData));\r\n        (address _tokenIn, address _tokenOut) = _decodedData.path.decodeFirstPool();\r\n\r\n        // ensure that msg.sender is a pair\r\n        require(msg.sender == PoolAddressV1.pairFor(factory, _tokenIn, _tokenOut), \"SmarDexRouter: INVALID_PAIR\");\r\n\r\n        (bool _isExactInput, uint256 _amountToPay) = _amount0Delta > 0\r\n            ? (_tokenIn < _tokenOut, uint256(_amount0Delta))\r\n            : (_tokenOut < _tokenIn, uint256(_amount1Delta));\r\n\r\n        if (_isExactInput) {\r\n            pay(_tokenIn, _decodedData.payer, msg.sender, _amountToPay);\r\n        } else if (_decodedData.path.hasMultiplePools()) {\r\n            _decodedData.path = _decodedData.path.skipToken();\r\n            _swapExactOut(_amountToPay, msg.sender, _decodedData);\r\n        } else {\r\n            amountInCached = _amountToPay;\r\n            _tokenIn = _tokenOut; // swap in/out because exact output swaps are reversed\r\n            pay(_tokenIn, _decodedData.payer, msg.sender, _amountToPay);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice send tokens to a user. Handle transfer/transferFrom and WETH / ETH or any ERC20 token\r\n     * @param _token The token to pay\r\n     * @param _payer The entity that must pay\r\n     * @param _to The entity that will receive payment\r\n     * @param _value The amount to pay\r\n     *\r\n     * @custom:from UniV3 PeripheryPayments.sol\r\n     * @custom:url https://github.com/Uniswap/v3-periphery/blob/v1.3.0/contracts/base/PeripheryPayments.sol\r\n     */\r\n    function pay(address _token, address _payer, address _to, uint256 _value) internal {\r\n        if (_token == WETH && address(this).balance >= _value) {\r\n            // pay with WETH\r\n            IWETH(WETH).deposit{ value: _value }(); // wrap only what is needed to pay\r\n            IWETH(WETH).transfer(_to, _value);\r\n            //refund dust eth, if any ?\r\n        } else if (_payer == address(this)) {\r\n            // pay with tokens already in the contract (for the exact input multihop case)\r\n            TransferHelper.safeTransfer(_token, _to, _value);\r\n        } else {\r\n            // pull payment\r\n            TransferHelper.safeTransferFrom(_token, _payer, _to, _value);\r\n        }\r\n    }\r\n\r\n    ///@inheritdoc ISmardexMintCallback\r\n    function smardexMintCallback(MintCallbackData calldata _data) external override {\r\n        // ensure that msg.sender is a pair\r\n        require(\r\n            msg.sender == PoolAddressV1.pairFor(factory, _data.token0, _data.token1),\r\n            \"SmarDexRouter: INVALID_PAIR\"\r\n        );\r\n\r\n        require(_data.amount0 != 0 || _data.amount1 != 0, \"SmardexRouter: Callback Invalid amount\");\r\n\r\n        pay(_data.token0, _data.payer, msg.sender, _data.amount0);\r\n        pay(_data.token1, _data.payer, msg.sender, _data.amount1);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function addLiquidity(\r\n        AddLiquidityParams calldata _params,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external virtual override ensure(_deadline) returns (uint256 amountA_, uint256 amountB_, uint256 liquidity_) {\r\n        (amountA_, amountB_) = _addLiquidity(_params);\r\n        address _pair = PoolAddressV1.pairFor(factory, _params.tokenA, _params.tokenB);\r\n        bool _orderedPair = _params.tokenA < _params.tokenB;\r\n        liquidity_ = ISmardexPair(_pair).mint(\r\n            _to,\r\n            _orderedPair ? amountA_ : amountB_,\r\n            _orderedPair ? amountB_ : amountA_,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function addLiquidityETH(\r\n        AddLiquidityETHParams calldata _params,\r\n        address _to,\r\n        uint256 _deadline\r\n    )\r\n        external\r\n        payable\r\n        virtual\r\n        override\r\n        ensure(_deadline)\r\n        returns (uint256 amountToken_, uint256 amountETH_, uint256 liquidity_)\r\n    {\r\n        AddLiquidityParams memory _p = AddLiquidityParams({\r\n            tokenA: _params.token,\r\n            tokenB: WETH,\r\n            amountADesired: _params.amountTokenDesired,\r\n            amountBDesired: msg.value,\r\n            amountAMin: _params.amountTokenMin,\r\n            amountBMin: _params.amountETHMin,\r\n            fictiveReserveB: _params.fictiveReserveETH,\r\n            fictiveReserveAMin: _params.fictiveReserveTokenMin,\r\n            fictiveReserveAMax: _params.fictiveReserveTokenMax\r\n        });\r\n        (amountToken_, amountETH_) = _addLiquidity(_p);\r\n\r\n        address _pair = PoolAddressV1.pairFor(factory, _params.token, WETH);\r\n        bool _orderedPair = _params.token < WETH;\r\n\r\n        liquidity_ = ISmardexPair(_pair).mint(\r\n            _to,\r\n            _orderedPair ? amountToken_ : amountETH_,\r\n            _orderedPair ? amountETH_ : amountToken_,\r\n            msg.sender\r\n        );\r\n\r\n        // refund dust eth, if any\r\n        if (msg.value > amountETH_) {\r\n            TransferHelper.safeTransferETH(msg.sender, msg.value - amountETH_);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function removeLiquidity(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _liquidity,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public virtual override ensure(_deadline) returns (uint256 amountA_, uint256 amountB_) {\r\n        address _pair = PoolAddressV1.pairFor(factory, _tokenA, _tokenB);\r\n        ISmardexPair(_pair).transferFrom(msg.sender, _pair, _liquidity); // send liquidity to pair\r\n\r\n        (uint256 _amount0, uint256 _amount1) = ISmardexPair(_pair).burn(_to);\r\n        (address _token0, ) = PoolHelpersV1.sortTokens(_tokenA, _tokenB);\r\n        (amountA_, amountB_) = _tokenA == _token0 ? (_amount0, _amount1) : (_amount1, _amount0);\r\n\r\n        require(amountA_ >= _amountAMin, \"SmarDexRouter: INSUFFICIENT_A_AMOUNT\");\r\n        require(amountB_ >= _amountBMin, \"SmarDexRouter: INSUFFICIENT_B_AMOUNT\");\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function removeLiquidityETH(\r\n        address _token,\r\n        uint256 _liquidity,\r\n        uint256 _amountTokenMin,\r\n        uint256 _amountETHMin,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public virtual override ensure(_deadline) returns (uint256 amountToken_, uint256 amountETH_) {\r\n        (amountToken_, amountETH_) = removeLiquidity(\r\n            _token,\r\n            WETH,\r\n            _liquidity,\r\n            _amountTokenMin,\r\n            _amountETHMin,\r\n            address(this),\r\n            _deadline\r\n        );\r\n        TransferHelper.safeTransfer(_token, _to, amountToken_);\r\n        IWETH(WETH).withdraw(amountETH_);\r\n        TransferHelper.safeTransferETH(_to, amountETH_);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function removeLiquidityWithPermit(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _liquidity,\r\n        uint256 _amountAMin,\r\n        uint256 _amountBMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external virtual override returns (uint256 amountA_, uint256 amountB_) {\r\n        address _pair = PoolAddressV1.pairFor(factory, _tokenA, _tokenB);\r\n        uint256 _value = _approveMax ? type(uint256).max : _liquidity;\r\n        // Check and execute permit. In case of failure, we don't want to revert because it's a vector for griefing.\r\n        // transferFrom call will revert in case allowance is not sufficient.\r\n        try ISmardexPair(_pair).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s) {} catch {}\r\n        (amountA_, amountB_) = removeLiquidity(_tokenA, _tokenB, _liquidity, _amountAMin, _amountBMin, _to, _deadline);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function removeLiquidityETHWithPermit(\r\n        address _token,\r\n        uint256 _liquidity,\r\n        uint256 _amountTokenMin,\r\n        uint256 _amountETHMin,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external virtual override returns (uint256 amountToken_, uint256 amountETH_) {\r\n        address _pair = PoolAddressV1.pairFor(factory, _token, WETH);\r\n        uint256 _value = _approveMax ? type(uint256).max : _liquidity;\r\n        // Check and execute permit. In case of failure, we don't want to revert because it's a vector for griefing.\r\n        // transferFrom call will revert in case allowance is not sufficient.\r\n        try ISmardexPair(_pair).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s) {} catch {}\r\n        (amountToken_, amountETH_) = removeLiquidityETH(\r\n            _token,\r\n            _liquidity,\r\n            _amountTokenMin,\r\n            _amountETHMin,\r\n            _to,\r\n            _deadline\r\n        );\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function swapExactTokensForTokens(\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public virtual override ensure(_deadline) returns (uint256 amountOut_) {\r\n        address _payer = msg.sender; // msg.sender pays for the first hop\r\n\r\n        bytes memory _bytesPath = _path.encodeTightlyPacked(); //could be done in the caller function\r\n        while (true) {\r\n            bool _hasMultiplePools = _bytesPath.hasMultiplePools();\r\n\r\n            // the outputs of prior swaps become the inputs to subsequent ones\r\n            _amountIn = _swapExactIn(\r\n                _amountIn,\r\n                // for intermediate swaps, this contract custodies\r\n                _hasMultiplePools ? address(this) : _to,\r\n                // only the first pool in the path is necessary\r\n                SwapCallbackData({ path: _bytesPath.getFirstPool(), payer: _payer })\r\n            );\r\n\r\n            // decide whether to continue or terminate\r\n            if (_hasMultiplePools) {\r\n                _payer = address(this); // at this point, the caller has paid\r\n                _bytesPath = _bytesPath.skipToken();\r\n            } else {\r\n                // amountOut of the final swap is the last amountIn captured in the loop\r\n                amountOut_ = _amountIn;\r\n                break;\r\n            }\r\n        }\r\n        require(amountOut_ >= _amountOutMin, \"SmarDexRouter: INSUFFICIENT_OUTPUT_AMOUNT\");\r\n    }\r\n\r\n    function swapExactTokensForTokensWithPermit(\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external virtual override returns (uint256 amountOut_) {\r\n        uint256 _value = _approveMax ? type(uint256).max : _amountIn;\r\n        // Check and execute permit. In case of failure, we don't want to revert because it's a vector for griefing.\r\n        // transferFrom call will revert in case allowance is not sufficient.\r\n        try IERC20Permit(_path[0]).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s) {} catch {}\r\n\r\n        return swapExactTokensForTokens(_amountIn, _amountOutMin, _path, _to, _deadline);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function swapTokensForExactTokens(\r\n        uint256 _amountOut,\r\n        uint256 _amountInMax,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public virtual override ensure(_deadline) returns (uint256 amountIn_) {\r\n        // Path needs to be reversed as to get the amountIn that we will ask from next pair hop\r\n        bytes memory _reversedPath = _path.encodeTightlyPackedReversed();\r\n        amountIn_ = _swapExactOut(_amountOut, _to, SwapCallbackData({ path: _reversedPath, payer: msg.sender }));\r\n        // amount In is only the right one for one Hop, otherwise we need cached amountIn from callback\r\n        if (_path.length > 2) amountIn_ = amountInCached;\r\n        require(amountIn_ <= _amountInMax, \"SmarDexRouter: EXCESSIVE_INPUT_AMOUNT\");\r\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\r\n    }\r\n\r\n    function swapTokensForExactTokensWithPermit(\r\n        uint256 _amountOut,\r\n        uint256 _amountInMax,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external virtual override returns (uint256 amountIn_) {\r\n        uint256 _value = _approveMax ? type(uint256).max : _amountInMax;\r\n        // Check and execute permit. In case of failure, we don't want to revert because it's a vector for griefing.\r\n        // transferFrom call will revert in case allowance is not sufficient.\r\n        try IERC20Permit(_path[0]).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s) {} catch {}\r\n\r\n        return swapTokensForExactTokens(_amountOut, _amountInMax, _path, _to, _deadline);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function swapTokensForExactETH(\r\n        uint256 _amountOut,\r\n        uint256 _amountInMax,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public virtual override ensure(_deadline) returns (uint256 amountIn_) {\r\n        require(_path[_path.length - 1] == WETH, \"SmarDexRouter: INVALID_PATH\");\r\n        amountIn_ = swapTokensForExactTokens(_amountOut, _amountInMax, _path, address(this), _deadline);\r\n        _unwrapWETH(_amountOut, _to);\r\n    }\r\n\r\n    function swapTokensForExactETHWithPermit(\r\n        uint256 _amountOut,\r\n        uint256 _amountInMax,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external virtual override returns (uint256 amountIn_) {\r\n        uint256 _value = _approveMax ? type(uint256).max : _amountInMax;\r\n        // Check and execute permit. In case of failure, we don't want to revert because it's a vector for griefing.\r\n        // transferFrom call will revert in case allowance is not sufficient.\r\n        try IERC20Permit(_path[0]).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s) {} catch {}\r\n\r\n        return swapTokensForExactETH(_amountOut, _amountInMax, _path, _to, _deadline);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function swapETHForExactTokens(\r\n        uint256 _amountOut,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable virtual override ensure(_deadline) returns (uint256 amountIn_) {\r\n        require(_path[0] == WETH, \"SmarDexRouter: INVALID_PATH\");\r\n        amountIn_ = swapTokensForExactTokens(_amountOut, msg.value, _path, _to, _deadline);\r\n\r\n        // Refund unused ETH\r\n        _refundETH(msg.sender);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function swapExactETHForTokens(\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable virtual override ensure(_deadline) returns (uint256 amountOut_) {\r\n        require(_path[0] == WETH, \"SmarDexRouter: INVALID_PATH\");\r\n        amountOut_ = swapExactTokensForTokens(msg.value, _amountOutMin, _path, _to, _deadline);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function swapExactTokensForETH(\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public virtual override ensure(_deadline) returns (uint256 amountOut_) {\r\n        require(_path[_path.length - 1] == WETH, \"SmarDexRouter: INVALID_PATH\");\r\n        amountOut_ = swapExactTokensForTokens(_amountIn, _amountOutMin, _path, address(this), _deadline);\r\n        _unwrapWETH(amountOut_, _to);\r\n    }\r\n\r\n    function swapExactTokensForETHWithPermit(\r\n        uint256 _amountIn,\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline,\r\n        bool _approveMax,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external virtual override returns (uint256 amountOut_) {\r\n        uint256 _value = _approveMax ? type(uint256).max : _amountIn;\r\n        // Check and execute permit. In case of failure, we don't want to revert because it's a vector for griefing.\r\n        // transferFrom call will revert in case allowance is not sufficient.\r\n        try IERC20Permit(_path[0]).permit(msg.sender, address(this), _value, _deadline, _v, _r, _s) {} catch {}\r\n\r\n        return swapExactTokensForETH(_amountIn, _amountOutMin, _path, _to, _deadline);\r\n    }\r\n\r\n    /**\r\n     * @notice internal function to unwrap WETH to ETH after swap\r\n     * @param _amountMinimum minimum amount of WETH that the contract should have\r\n     * @param _to address that will receive the ETH unwrapped\r\n     *\r\n     * @custom:from UniV3 PeripheryPayments.sol\r\n     * @custom:url https://github.com/Uniswap/v3-periphery/blob/v1.3.0/contracts/base/PeripheryPayments.sol\r\n     */\r\n    function _unwrapWETH(uint256 _amountMinimum, address _to) internal {\r\n        uint256 _balanceWETH = IERC20(WETH).balanceOf(address(this));\r\n        require(_balanceWETH >= _amountMinimum, \"Insufficient WETH\");\r\n\r\n        if (_balanceWETH != 0) {\r\n            IWETH(WETH).withdraw(_balanceWETH);\r\n            TransferHelper.safeTransferETH(_to, _balanceWETH);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice internal function to send all ETH of the contract. Do not fail if the contract does not have any ETH\r\n     * @param _to address that will receive the ETH\r\n     *\r\n     * @custom:from UniV3 PeripheryPayments.sol\r\n     * @custom:url https://github.com/Uniswap/v3-periphery/blob/v1.3.0/contracts/base/PeripheryPayments.sol\r\n     */\r\n    function _refundETH(address _to) private {\r\n        if (address(this).balance != 0) {\r\n            TransferHelper.safeTransferETH(_to, address(this).balance);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice internal function to swap quantity of token to receive a determined quantity\r\n     * @param _amountOut quantity to receive\r\n     * @param _to address that will receive the token\r\n     * @param _data SwapCallbackData data of the swap to transmit\r\n     * @return amountIn_ amount of token to pay\r\n     */\r\n    function _swapExactOut(\r\n        uint256 _amountOut,\r\n        address _to,\r\n        SwapCallbackData memory _data\r\n    ) private returns (uint256 amountIn_) {\r\n        require(_to != address(0), \"SmarDexRouter: INVALID_RECIPIENT\");\r\n\r\n        (address _tokenOut, address _tokenIn) = _data.path.decodeFirstPool();\r\n        bool _zeroForOne = _tokenIn < _tokenOut;\r\n\r\n        // do the swap\r\n        (int256 _amount0, int256 _amount1) = ISmardexPair(PoolAddressV1.pairFor(factory, _tokenIn, _tokenOut)).swap(\r\n            _to,\r\n            _zeroForOne,\r\n            -_amountOut.toInt256(),\r\n            abi.encode(_data)\r\n        );\r\n\r\n        amountIn_ = _zeroForOne ? uint256(_amount0) : uint256(_amount1);\r\n    }\r\n\r\n    /**\r\n     * @notice Add liquidity to an ERC-20=ERC-20 pool. Receive liquidity token to materialize shares in the pool\r\n     * @param _params parameters of the liquidity to add\r\n     * @return amountA_ The amount of tokenA sent to the pool.\r\n     * @return amountB_ The amount of tokenB sent to the pool.\r\n     */\r\n    function _addLiquidity(\r\n        AddLiquidityParams memory _params\r\n    ) internal virtual returns (uint256 amountA_, uint256 amountB_) {\r\n        // create the pair if it doesn't exist yet\r\n        if (ISmardexFactory(factory).getPair(_params.tokenA, _params.tokenB) == address(0)) {\r\n            ISmardexFactory(factory).createPair(_params.tokenA, _params.tokenB);\r\n        }\r\n        (uint256 _reserveA, uint256 _reserveB, uint256 _reserveAFic, uint256 _reserveBFic) = PoolHelpersV1\r\n            .getAllReserves(factory, _params.tokenA, _params.tokenB);\r\n        if (_reserveA == 0 && _reserveB == 0) {\r\n            (amountA_, amountB_) = (_params.amountADesired, _params.amountBDesired);\r\n        } else {\r\n            // price slippage check\r\n            // the current price is _reserveAFic / _reserveBFic\r\n            // the max price that the user accepts is _params.fictiveReserveAMax / _params.fictiveReserveB\r\n            // the min price that the user accepts is _params.fictiveReserveAMin / _params.fictiveReserveB\r\n            uint256 _product = _reserveAFic * _params.fictiveReserveB;\r\n            require(_product <= _params.fictiveReserveAMax * _reserveBFic, \"SmarDexRouter: PRICE_TOO_HIGH\");\r\n            require(_product >= _params.fictiveReserveAMin * _reserveBFic, \"SmarDexRouter: PRICE_TOO_LOW\");\r\n\r\n            // real reserves slippage check\r\n            uint256 _amountBOptimal = PoolHelpersV1.quote(_params.amountADesired, _reserveA, _reserveB);\r\n            if (_amountBOptimal <= _params.amountBDesired) {\r\n                require(_amountBOptimal >= _params.amountBMin, \"SmarDexRouter: INSUFFICIENT_B_AMOUNT\");\r\n                (amountA_, amountB_) = (_params.amountADesired, _amountBOptimal);\r\n            } else {\r\n                uint256 _amountAOptimal = PoolHelpersV1.quote(_params.amountBDesired, _reserveB, _reserveA);\r\n                assert(_amountAOptimal <= _params.amountADesired);\r\n                require(_amountAOptimal >= _params.amountAMin, \"SmarDexRouter: INSUFFICIENT_A_AMOUNT\");\r\n                (amountA_, amountB_) = (_amountAOptimal, _params.amountBDesired);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice internal function to swap a determined quantity of token\r\n     * @param _amountIn quantity to swap\r\n     * @param _to address that will receive the token\r\n     * @param _data SwapCallbackData data of the swap to transmit\r\n     * @return amountOut_ amount of token that _to will receive\r\n     */\r\n    function _swapExactIn(\r\n        uint256 _amountIn,\r\n        address _to,\r\n        SwapCallbackData memory _data\r\n    ) internal returns (uint256 amountOut_) {\r\n        // allow swapping to the router address with address 0\r\n        if (_to == address(0)) {\r\n            _to = address(this);\r\n        }\r\n\r\n        (address _tokenIn, address _tokenOut) = _data.path.decodeFirstPool();\r\n        bool _zeroForOne = _tokenIn < _tokenOut;\r\n        (int256 _amount0, int256 _amount1) = ISmardexPair(PoolAddressV1.pairFor(factory, _tokenIn, _tokenOut)).swap(\r\n            _to,\r\n            _zeroForOne,\r\n            _amountIn.toInt256(),\r\n            abi.encode(_data)\r\n        );\r\n\r\n        amountOut_ = (_zeroForOne ? -_amount1 : -_amount0).toUint256();\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function quote(\r\n        uint256 _amountA,\r\n        uint256 _reserveA,\r\n        uint256 _reserveB\r\n    ) public pure virtual override returns (uint256 amountB_) {\r\n        return PoolHelpersV1.quote(_amountA, _reserveA, _reserveB);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function getAmountOut(\r\n        SmardexLibrary.GetAmountParameters memory _param\r\n    )\r\n        external\r\n        pure\r\n        returns (\r\n            uint256 amountOut_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        /// @dev The values _priceAverageIn and _priceAverageOut are not directly fetched from the pair,\r\n        ///      and therefore, they may not necessarily be up to date with the most recent data. In\r\n        ///      order to yield a _amountOut that represents the most current value, it is crucial that\r\n        ///      the args _priceAverageIn and _priceAverageOut reflects the latest, updated data.\r\n        (amountOut_, newReserveIn_, newReserveOut_, newFictiveReserveIn_, newFictiveReserveOut_) = SmardexLibrary\r\n            .getAmountOut(_param);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function getAmountIn(\r\n        SmardexLibrary.GetAmountParameters memory _param\r\n    )\r\n        external\r\n        pure\r\n        returns (\r\n            uint256 amountIn_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        (amountIn_, newReserveIn_, newReserveOut_, newFictiveReserveIn_, newFictiveReserveOut_) = SmardexLibrary\r\n            .getAmountIn(_param);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function getAmountOutFromPair(\r\n        uint256 _amountIn,\r\n        address _tokenIn,\r\n        address _tokenOut\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 amountOut_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        SmardexLibrary.GetAmountParameters memory _param;\r\n        _param.amount = _amountIn;\r\n\r\n        ISmardexPair _pair = ISmardexPair(ISmardexFactory(factory).getPair(_tokenIn, _tokenOut));\r\n        require(address(_pair) != address(0), \"SmarDexRouter: INVALID_TOKENS\");\r\n        uint256 _priceAverageLastTimestamp;\r\n\r\n        // fetch data\r\n        if (_tokenIn == _pair.token0()) {\r\n            (_param.reserveIn, _param.reserveOut) = _pair.getReserves();\r\n            (_param.fictiveReserveIn, _param.fictiveReserveOut) = _pair.getFictiveReserves();\r\n            (_param.priceAverageIn, _param.priceAverageOut, _priceAverageLastTimestamp) = _pair.getPriceAverage();\r\n        } else {\r\n            (_param.reserveOut, _param.reserveIn) = _pair.getReserves();\r\n            (_param.fictiveReserveOut, _param.fictiveReserveIn) = _pair.getFictiveReserves();\r\n            (_param.priceAverageOut, _param.priceAverageIn, _priceAverageLastTimestamp) = _pair.getPriceAverage();\r\n        }\r\n\r\n        // update price average\r\n        (_param.priceAverageIn, _param.priceAverageOut) = _pair.getUpdatedPriceAverage(\r\n            _param.fictiveReserveIn,\r\n            _param.fictiveReserveOut,\r\n            _priceAverageLastTimestamp,\r\n            _param.priceAverageIn,\r\n            _param.priceAverageOut,\r\n            block.timestamp\r\n        );\r\n\r\n        // get pair fees\r\n        (_param.feesLP, _param.feesPool) = _pair.getPairFees();\r\n\r\n        (amountOut_, newReserveIn_, newReserveOut_, newFictiveReserveIn_, newFictiveReserveOut_) = SmardexLibrary\r\n            .getAmountOut(_param);\r\n    }\r\n\r\n    /// @inheritdoc ISmardexRouter\r\n    function getAmountInFromPair(\r\n        uint256 _amountOut,\r\n        address _tokenIn,\r\n        address _tokenOut\r\n    )\r\n        external\r\n        view\r\n        returns (\r\n            uint256 amountIn_,\r\n            uint256 newReserveIn_,\r\n            uint256 newReserveOut_,\r\n            uint256 newFictiveReserveIn_,\r\n            uint256 newFictiveReserveOut_\r\n        )\r\n    {\r\n        SmardexLibrary.GetAmountParameters memory _param;\r\n        _param.amount = _amountOut;\r\n\r\n        ISmardexPair _pair = ISmardexPair(ISmardexFactory(factory).getPair(_tokenIn, _tokenOut));\r\n        require(address(_pair) != address(0), \"SmarDexRouter: INVALID_TOKENS\");\r\n        uint256 _priceAverageLastTimestamp;\r\n\r\n        // fetch data\r\n        if (_tokenIn == _pair.token0()) {\r\n            (_param.reserveIn, _param.reserveOut) = _pair.getReserves();\r\n            (_param.fictiveReserveIn, _param.fictiveReserveOut) = _pair.getFictiveReserves();\r\n            (_param.priceAverageIn, _param.priceAverageOut, _priceAverageLastTimestamp) = _pair.getPriceAverage();\r\n        } else {\r\n            (_param.reserveOut, _param.reserveIn) = _pair.getReserves();\r\n            (_param.fictiveReserveOut, _param.fictiveReserveIn) = _pair.getFictiveReserves();\r\n            (_param.priceAverageOut, _param.priceAverageIn, _priceAverageLastTimestamp) = _pair.getPriceAverage();\r\n        }\r\n\r\n        // update price average\r\n        (_param.priceAverageIn, _param.priceAverageOut) = _pair.getUpdatedPriceAverage(\r\n            _param.fictiveReserveIn,\r\n            _param.fictiveReserveOut,\r\n            _priceAverageLastTimestamp,\r\n            _param.priceAverageIn,\r\n            _param.priceAverageOut,\r\n            block.timestamp\r\n        );\r\n\r\n        // get pair fees\r\n        (_param.feesLP, _param.feesPool) = _pair.getPairFees();\r\n\r\n        (amountIn_, newReserveIn_, newReserveOut_, newFictiveReserveIn_, newFictiveReserveOut_) = SmardexLibrary\r\n            .getAmountIn(_param);\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/test/peripheryV2WithV1/test/CallbackTestV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\npragma solidity =0.8.17;\r\n\r\n//libraries\r\nimport \"../../../../core/libraries/TransferHelper.sol\";\r\nimport \"../libraries/PoolAddressV1.sol\";\r\n//interfaces\r\nimport \"../../../interfaces/ISmardexRouter.sol\";\r\nimport \"../../../libraries/Path.sol\";\r\n\r\ncontract CallbackTestV2 {\r\n    using Path for bytes;\r\n\r\n    address public immutable factory;\r\n    address public immutable WETH;\r\n    bool public isToken0ToLower;\r\n\r\n    constructor(address _factory, address _weth) {\r\n        factory = _factory;\r\n        WETH = _weth;\r\n    }\r\n\r\n    struct SwapCallbackData {\r\n        bytes path;\r\n        address payer;\r\n    }\r\n\r\n    function setIsToken0ToLower(bool _isToken0ToLower) external {\r\n        isToken0ToLower = _isToken0ToLower;\r\n    }\r\n\r\n    // From UniV3 PeripheryPayments.sol\r\n    // https://github.com/Uniswap/v3-periphery/blob/v1.3.0/contracts/base/PeripheryPayments.sol\r\n    /// @param _token The token to pay\r\n    /// @param _payer The entity that must pay\r\n    /// @param _to The entity that will receive payment\r\n    /// @param _value The amount to pay\r\n    function pay(address _token, address _payer, address _to, uint256 _value) internal {\r\n        // pull payment\r\n        TransferHelper.safeTransferFrom(_token, _payer, _to, _value);\r\n    }\r\n\r\n    function smardexMintCallback(ISmardexMintCallback.MintCallbackData calldata _data) external {\r\n        require(_data.amount0 > 0 || _data.amount1 > 0, \"SmardexRouter: Callback Invalid amount\");\r\n        require(\r\n            msg.sender == PoolAddressV1.pairFor(factory, _data.token0, _data.token1),\r\n            \"SmarDexRouter: INVALID_PAIR\"\r\n        ); // ensure that msg.sender is a pair\r\n        pay(_data.token0, _data.payer, msg.sender, isToken0ToLower ? _data.amount0 - 1 : _data.amount0);\r\n        // we send less token 1 than expected\r\n        pay(_data.token1, _data.payer, msg.sender, isToken0ToLower ? _data.amount1 : _data.amount1 - 1);\r\n    }\r\n\r\n    function smardexSwapCallback(int256 _amount0Delta, int256 _amount1Delta, bytes calldata _data) external {\r\n        require(_amount0Delta > 0 || _amount1Delta > 0, \"SmardexRouter: Callback Invalid amount\");\r\n        SwapCallbackData memory _decodedData = abi.decode(_data, (SwapCallbackData));\r\n        (address _tokenIn, address _tokenOut) = _decodedData.path.decodeFirstPool();\r\n\r\n        require(msg.sender == PoolAddressV1.pairFor(factory, _tokenIn, _tokenOut), \"SmarDexRouter: INVALID_PAIR\"); // ensure that msg.sender is a pair\r\n\r\n        (bool _isExactInput, uint256 _amountToPay) = _amount0Delta > 0\r\n            ? (_tokenIn < _tokenOut, uint256(_amount0Delta))\r\n            : (_tokenOut < _tokenIn, uint256(_amount1Delta));\r\n        _amountToPay -= 1;\r\n        if (_isExactInput) {\r\n            pay(_tokenIn, _decodedData.payer, msg.sender, _amountToPay);\r\n        } else {\r\n            _tokenIn = _tokenOut; // swap in/out because exact output swaps are reversed\r\n            pay(_tokenIn, _decodedData.payer, msg.sender, _amountToPay);\r\n        }\r\n    }\r\n\r\n    function addLiquidity(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _amountADesired,\r\n        uint256 _amountBDesired,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external returns (uint256 liquidity_) {\r\n        require(_deadline >= block.timestamp, \"SmardexRouter: EXPIRED\");\r\n        address _pair = PoolAddressV1.pairFor(factory, _tokenA, _tokenB);\r\n        bool _orderedPair = _tokenA < _tokenB;\r\n        liquidity_ = ISmardexPair(_pair).mint(\r\n            _to,\r\n            _orderedPair ? _amountADesired : _amountBDesired,\r\n            _orderedPair ? _amountBDesired : _amountADesired,\r\n            msg.sender\r\n        );\r\n    }\r\n\r\n    function swap(address _pair, address _to, bool _zeroForOne, int256 _amountSpecified, bytes calldata _path) public {\r\n        ISmardexPair(_pair).swap(_to, _zeroForOne, _amountSpecified, _path);\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/test/peripheryV2WithV1/test/FakeERC20reentrancyV2.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\npragma solidity =0.8.17;\r\n\r\n//contracts\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n//libraries\r\nimport \"../libraries/PoolAddressV1.sol\";\r\n\r\n//interfaces\r\nimport \"../../../interfaces/ISmardexRouter.sol\";\r\nimport \"../../../../core/interfaces/ISmardexFactory.sol\";\r\n\r\ncontract FakeERC20reentrancyV2 is ERC20 {\r\n    address public immutable factory;\r\n    address public immutable WETH;\r\n\r\n    bool private active = false;\r\n\r\n    error PairNotFound(address token0, address token1);\r\n\r\n    constructor(address _factory, address _weth) ERC20(\"FakeERC20reentrancy\", \"FRE\") {\r\n        factory = _factory;\r\n        WETH = _weth;\r\n        _mint(msg.sender, 100_000_000 ether);\r\n    }\r\n\r\n    function activate() external {\r\n        active = !active;\r\n    }\r\n\r\n    function transferFrom(address sender, address recipient, uint256 amount) public override returns (bool) {\r\n        if (active && recipient == PoolAddressV1.pairFor(factory, address(this), WETH)) {\r\n            active = false;\r\n            //try to reentrancy add liquidity\r\n            ISmardexPair(recipient).mint(address(this), 100, 100, address(this));\r\n        }\r\n        return super.transferFrom(sender, recipient, amount);\r\n    }\r\n\r\n    struct SwapCallbackData {\r\n        address payer;\r\n        bytes path;\r\n    }\r\n\r\n    // From UniV3 PeripheryPayments.sol\r\n    // https://github.com/Uniswap/v3-periphery/blob/v1.3.0/contracts/base/PeripheryPayments.sol\r\n    /// @param _token The token to pay\r\n    /// @param _payer The entity that must pay\r\n    /// @param _to The entity that will receive payment\r\n    /// @param _value The amount to pay\r\n    function pay(address _token, address _payer, address _to, uint256 _value) internal {\r\n        // pull payment\r\n        if (_token == address(this)) transferFrom(_payer, _to, _value);\r\n        else IERC20(_token).transferFrom(_payer, _to, _value);\r\n    }\r\n\r\n    function smardexMintCallback(ISmardexMintCallback.MintCallbackData calldata _data) external {\r\n        require(_data.amount0 > 0 || _data.amount1 > 0, \"SmardexRouter: Callback Invalid amount\");\r\n\r\n        require(\r\n            msg.sender == PoolAddressV1.pairFor(factory, _data.token0, _data.token1),\r\n            \"SmarDexRouter: INVALID_PAIR\"\r\n        ); // ensure that msg.sender is a pair\r\n\r\n        // ISmardexPair(msg.sender).mint(address(this), 1, 1, _data.payer);\r\n        pay(_data.token0, _data.payer, msg.sender, _data.amount0);\r\n        pay(_data.token1, _data.payer, msg.sender, _data.amount1);\r\n    }\r\n\r\n    function addLiquidity(\r\n        address _tokenA,\r\n        address _tokenB,\r\n        uint256 _amountADesired,\r\n        uint256 _amountBDesired,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) public returns (uint256 liquidity_) {\r\n        require(_deadline >= block.timestamp, \"SmardexRouter: EXPIRED\");\r\n        address _pair = ISmardexFactory(factory).getPair(_tokenA, _tokenB);\r\n        if (_pair == address(0)) {\r\n            revert PairNotFound(_tokenA, _tokenB);\r\n        }\r\n        bool _orderedPair = _tokenA < _tokenB;\r\n        liquidity_ = ISmardexPair(_pair).mint(\r\n            _to,\r\n            _orderedPair ? _amountADesired : _amountBDesired,\r\n            _orderedPair ? _amountBDesired : _amountADesired,\r\n            msg.sender\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/test/peripheryV2WithV1/test/RouterForPairTestV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// libraries\r\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\r\nimport \"../../../../core/libraries/SmardexLibrary.sol\";\r\nimport \"../libraries/PoolAddressV1.sol\";\r\nimport \"../SmardexRouterV2.sol\";\r\nimport \"../../../libraries/Path.sol\";\r\n\r\ncontract RouterForPairTestV2 {\r\n    using Path for bytes;\r\n    using Path for address[];\r\n    using SafeCast for uint256;\r\n    using SafeCast for int256;\r\n\r\n    struct SwapCallbackData {\r\n        bytes path;\r\n        address payer;\r\n    }\r\n\r\n    address public immutable factory;\r\n    address public immutable WETH;\r\n    uint256 private constant DEFAULT_AMOUNT_IN_CACHED = type(uint256).max;\r\n    uint256 private amountInCached = DEFAULT_AMOUNT_IN_CACHED;\r\n\r\n    constructor(address _factory, address _WETH) {\r\n        factory = _factory;\r\n        WETH = _WETH;\r\n    }\r\n\r\n    function mint(address _pair, address _to, uint256 _amount0, uint256 _amount1, address _payer) public payable {\r\n        ISmardexPair(_pair).mint(_to, _amount0, _amount1, _payer);\r\n    }\r\n\r\n    function swap(address _pair, address _to, bool _zeroForOne, int256 _amountSpecified, bytes calldata _data) public {\r\n        ISmardexPair(_pair).swap(_to, _zeroForOne, _amountSpecified, _data);\r\n    }\r\n\r\n    function pay(address _token, address _payer, address _to, uint256 _value) internal {\r\n        if (_token == WETH && address(this).balance >= _value) {\r\n            // pay with WETH\r\n            IWETH(WETH).deposit{ value: _value }(); // wrap only what is needed to pay\r\n            IWETH(WETH).transfer(_to, _value);\r\n            //refund dust eth, if any ?\r\n        } else if (_payer == address(this)) {\r\n            // pay with tokens already in the contract (for the exact input multihop case)\r\n            TransferHelper.safeTransfer(_token, _to, _value);\r\n        } else {\r\n            // pull payment\r\n            TransferHelper.safeTransferFrom(_token, _payer, _to, _value);\r\n        }\r\n    }\r\n\r\n    function smardexMintCallback(ISmardexMintCallback.MintCallbackData calldata _data) external {\r\n        require(_data.amount0 > 0 || _data.amount1 > 0, \"SmardexRouter: Callback Invalid amount\");\r\n        require(\r\n            msg.sender == ISmardexFactory(factory).getPair(_data.token0, _data.token1),\r\n            \"SmarDexRouter: INVALID_PAIR\"\r\n        ); // ensure that msg.sender is a pair\r\n        pay(_data.token0, _data.payer, msg.sender, _data.amount0);\r\n        pay(_data.token1, _data.payer, msg.sender, _data.amount1);\r\n    }\r\n\r\n    function smardexSwapCallback(int256 _amount0Delta, int256 _amount1Delta, bytes calldata _data) external {\r\n        require(_amount0Delta > 0 || _amount1Delta > 0, \"SmardexRouter: Callback Invalid amount\");\r\n        SwapCallbackData memory _decodedData = abi.decode(_data, (SwapCallbackData));\r\n        (address _tokenIn, address _tokenOut) = _decodedData.path.decodeFirstPool();\r\n        // ensure that msg.sender is a pair\r\n        require(msg.sender == ISmardexFactory(factory).getPair(_tokenIn, _tokenOut), \"SmarDexRouter: INVALID_PAIR\");\r\n        (bool _isExactInput, uint256 _amountToPay) = _amount0Delta > 0\r\n            ? (_tokenIn < _tokenOut, uint256(_amount0Delta))\r\n            : (_tokenOut < _tokenIn, uint256(_amount1Delta));\r\n        if (_isExactInput) {\r\n            pay(_tokenIn, _decodedData.payer, msg.sender, _amountToPay);\r\n        } else {\r\n            _tokenIn = _tokenOut; // swap in/out because exact output swaps are reversed\r\n            pay(_tokenIn, _decodedData.payer, msg.sender, _amountToPay);\r\n        }\r\n    }\r\n\r\n    function swapETHForExactTokens(\r\n        uint256 _amountOut,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable returns (uint256 amountIn_) {\r\n        require(_path[0] == WETH, \"SmarDexRouter: INVALID_PATH\");\r\n        amountIn_ = swapTokensForExactTokens(_amountOut, msg.value, _path, _to, _deadline);\r\n    }\r\n\r\n    function swapTokensForExactTokens(\r\n        uint256 _amountOut,\r\n        uint256 _amountInMax,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 // _deadline\r\n    ) public returns (uint256 amountIn_) {\r\n        // Path needs to be reversed as to get the amountIn that we will ask from next pair hop\r\n        bytes memory _reversedPath = _path.encodeTightlyPackedReversed();\r\n        amountIn_ = _swapExactOut(_amountOut, _to, SwapCallbackData({ path: _reversedPath, payer: msg.sender }));\r\n        // amount In is only the right one for one Hop, otherwise we need cached amountIn from callback\r\n        if (_path.length > 2) amountIn_ = amountInCached;\r\n        require(amountIn_ <= _amountInMax, \"SmarDexRouter: EXCESSIVE_INPUT_AMOUNT\");\r\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\r\n\r\n        refundETH(_to);\r\n    }\r\n\r\n    function refundETH(address _to) private {\r\n        if (address(this).balance > 0) {\r\n            TransferHelper.safeTransferETH(_to, address(this).balance);\r\n        }\r\n    }\r\n\r\n    function _swapExactOut(\r\n        uint256 _amountOut,\r\n        address _to,\r\n        SwapCallbackData memory _data\r\n    ) private returns (uint256 amountIn_) {\r\n        // allow swapping to the router address with address 0\r\n        if (_to == address(0)) {\r\n            _to = address(this);\r\n        }\r\n\r\n        (address _tokenOut, address _tokenIn) = _data.path.decodeFirstPool();\r\n        bool _zeroForOne = _tokenIn < _tokenOut;\r\n\r\n        // do the swap\r\n        (int256 _amount0, int256 _amount1) = ISmardexPair(ISmardexFactory(factory).getPair(_tokenIn, _tokenOut)).swap(\r\n            _to,\r\n            _zeroForOne,\r\n            -_amountOut.toInt256(),\r\n            abi.encode(_data)\r\n        );\r\n\r\n        amountIn_ = _zeroForOne ? uint256(_amount0) : uint256(_amount1);\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/test/peripheryV2WithV1/test/SmardexRouterTestV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// libraries\r\nimport \"../libraries/PoolAddressV1.sol\";\r\nimport \"../SmardexRouterV2.sol\";\r\n\r\ncontract SmardexRouterTestV2 is SmardexRouterV2 {\r\n    constructor(address _factory, address _WETH) SmardexRouterV2(_factory, _WETH) {}\r\n\r\n    function pairFor_pure(address factory, address tokenA, address tokenB) public pure returns (address pair) {\r\n        pair = PoolAddressV1.pairFor(factory, tokenA, tokenB);\r\n    }\r\n\r\n    function mint(address _pair, address _to, uint256 _amount0, uint256 _amount1, address _payer) public {\r\n        ISmardexPair(_pair).mint(_to, _amount0, _amount1, _payer);\r\n    }\r\n\r\n    function swap(address _pair, address _to, bool _zeroForOne, int256 _amountSpecified, bytes calldata _path) public {\r\n        ISmardexPair(_pair).swap(_to, _zeroForOne, _amountSpecified, _path);\r\n    }\r\n\r\n    function unwrapWETHTest(uint256 _amountMinimum, address _to) external {\r\n        _unwrapWETH(_amountMinimum, _to);\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/test/RouterEventEmitter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// interfaces\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"../interfaces/ISmardexRouter.sol\";\r\n\r\ncontract RouterEventEmitter {\r\n    event Amount(uint256 amount);\r\n\r\n    receive() external payable {}\r\n\r\n    function swapExactTokensForTokens(\r\n        address router,\r\n        uint256 amountIn,\r\n        uint256 amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external {\r\n        IERC20(path[0]).transferFrom(msg.sender, address(this), amountIn);\r\n        IERC20(path[0]).approve(router, amountIn);\r\n        uint256 amount = ISmardexRouter(router).swapExactTokensForTokens(amountIn, amountOutMin, path, to, deadline);\r\n        emit Amount(amount);\r\n    }\r\n\r\n    function swapTokensForExactTokens(\r\n        address router,\r\n        uint256 amountOut,\r\n        uint256 amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint256 deadline\r\n    ) external {\r\n        IERC20(path[0]).transferFrom(msg.sender, address(this), amountInMax);\r\n        IERC20(path[0]).approve(router, amountInMax);\r\n        uint256 amount = ISmardexRouter(router).swapTokensForExactTokens(amountOut, amountInMax, path, to, deadline);\r\n        emit Amount(amount);\r\n    }\r\n\r\n    function swapETHForExactTokens(\r\n        address _router,\r\n        uint256 _amountOut,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable {\r\n        uint256 amount = ISmardexRouter(_router).swapETHForExactTokens{ value: msg.value }(\r\n            _amountOut,\r\n            _path,\r\n            _to,\r\n            _deadline\r\n        );\r\n        emit Amount(amount);\r\n    }\r\n\r\n    function swapExactETHForTokens(\r\n        address _router,\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable {\r\n        uint256 amount = ISmardexRouter(_router).swapExactETHForTokens{ value: msg.value }(\r\n            _amountOutMin,\r\n            _path,\r\n            _to,\r\n            _deadline\r\n        );\r\n        emit Amount(amount);\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/test/RouterForPairTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// libraries\r\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\r\nimport \"../../core/libraries/SmardexLibrary.sol\";\r\nimport \"../libraries/PoolAddress.sol\";\r\nimport \"../SmardexRouter.sol\";\r\nimport \"../libraries/Path.sol\";\r\n\r\ncontract RouterForPairTest {\r\n    using Path for bytes;\r\n    using Path for address[];\r\n    using SafeCast for uint256;\r\n    using SafeCast for int256;\r\n\r\n    struct SwapCallbackData {\r\n        bytes path;\r\n        address payer;\r\n    }\r\n\r\n    address public immutable factory;\r\n    address public immutable WETH;\r\n    uint256 private constant DEFAULT_AMOUNT_IN_CACHED = type(uint256).max;\r\n    uint256 private amountInCached = DEFAULT_AMOUNT_IN_CACHED;\r\n\r\n    constructor(address _factory, address _WETH) {\r\n        factory = _factory;\r\n        WETH = _WETH;\r\n    }\r\n\r\n    function mint(address _pair, address _to, uint256 _amount0, uint256 _amount1, address _payer) public payable {\r\n        ISmardexPair(_pair).mint(_to, _amount0, _amount1, _payer);\r\n    }\r\n\r\n    function swap(address _pair, address _to, bool _zeroForOne, int256 _amountSpecified, bytes calldata _data) public {\r\n        ISmardexPair(_pair).swap(_to, _zeroForOne, _amountSpecified, _data);\r\n    }\r\n\r\n    function pay(address _token, address _payer, address _to, uint256 _value) internal {\r\n        if (_token == WETH && address(this).balance >= _value) {\r\n            // pay with WETH\r\n            IWETH(WETH).deposit{ value: _value }(); // wrap only what is needed to pay\r\n            IWETH(WETH).transfer(_to, _value);\r\n            //refund dust eth, if any ?\r\n        } else if (_payer == address(this)) {\r\n            // pay with tokens already in the contract (for the exact input multihop case)\r\n            TransferHelper.safeTransfer(_token, _to, _value);\r\n        } else {\r\n            // pull payment\r\n            TransferHelper.safeTransferFrom(_token, _payer, _to, _value);\r\n        }\r\n    }\r\n\r\n    function smardexMintCallback(ISmardexMintCallback.MintCallbackData calldata _data) external {\r\n        require(_data.amount0 > 0 || _data.amount1 > 0, \"SmardexRouter: Callback Invalid amount\");\r\n        require(\r\n            msg.sender == ISmardexFactory(factory).getPair(_data.token0, _data.token1),\r\n            \"SmarDexRouter: INVALID_PAIR\"\r\n        ); // ensure that msg.sender is a pair\r\n        pay(_data.token0, _data.payer, msg.sender, _data.amount0);\r\n        pay(_data.token1, _data.payer, msg.sender, _data.amount1);\r\n    }\r\n\r\n    function smardexSwapCallback(int256 _amount0Delta, int256 _amount1Delta, bytes calldata _data) external {\r\n        require(_amount0Delta > 0 || _amount1Delta > 0, \"SmardexRouter: Callback Invalid amount\");\r\n        SwapCallbackData memory _decodedData = abi.decode(_data, (SwapCallbackData));\r\n        (address _tokenIn, address _tokenOut) = _decodedData.path.decodeFirstPool();\r\n        require(msg.sender == ISmardexFactory(factory).getPair(_tokenIn, _tokenOut), \"SmarDexRouter: INVALID_PAIR\"); // ensure that msg.sender is a pair\r\n        (bool _isExactInput, uint256 _amountToPay) = _amount0Delta > 0\r\n            ? (_tokenIn < _tokenOut, uint256(_amount0Delta))\r\n            : (_tokenOut < _tokenIn, uint256(_amount1Delta));\r\n        if (_isExactInput) {\r\n            pay(_tokenIn, _decodedData.payer, msg.sender, _amountToPay);\r\n        } else {\r\n            _tokenIn = _tokenOut; // swap in/out because exact output swaps are reversed\r\n            pay(_tokenIn, _decodedData.payer, msg.sender, _amountToPay);\r\n        }\r\n    }\r\n\r\n    function swapETHForExactTokens(\r\n        uint256 _amountOut,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 _deadline\r\n    ) external payable returns (uint256 amountIn_) {\r\n        require(_path[0] == WETH, \"SmarDexRouter: INVALID_PATH\");\r\n        amountIn_ = swapTokensForExactTokens(_amountOut, msg.value, _path, _to, _deadline);\r\n    }\r\n\r\n    function swapTokensForExactTokens(\r\n        uint256 _amountOut,\r\n        uint256 _amountInMax,\r\n        address[] calldata _path,\r\n        address _to,\r\n        uint256 // _deadline\r\n    ) public returns (uint256 amountIn_) {\r\n        // Path needs to be reversed as to get the amountIn that we will ask from next pair hop\r\n        bytes memory _reversedPath = _path.encodeTightlyPackedReversed();\r\n        amountIn_ = _swapExactOut(_amountOut, _to, SwapCallbackData({ path: _reversedPath, payer: msg.sender }));\r\n        // amount In is only the right one for one Hop, otherwise we need cached amountIn from callback\r\n        if (_path.length > 2) amountIn_ = amountInCached;\r\n        require(amountIn_ <= _amountInMax, \"SmarDexRouter: EXCESSIVE_INPUT_AMOUNT\");\r\n        amountInCached = DEFAULT_AMOUNT_IN_CACHED;\r\n\r\n        refundETH(_to);\r\n    }\r\n\r\n    function refundETH(address _to) private {\r\n        if (address(this).balance > 0) {\r\n            TransferHelper.safeTransferETH(_to, address(this).balance);\r\n        }\r\n    }\r\n\r\n    function _swapExactOut(\r\n        uint256 _amountOut,\r\n        address _to,\r\n        SwapCallbackData memory _data\r\n    ) private returns (uint256 amountIn_) {\r\n        // allow swapping to the router address with address 0\r\n        if (_to == address(0)) {\r\n            _to = address(this);\r\n        }\r\n\r\n        (address _tokenOut, address _tokenIn) = _data.path.decodeFirstPool();\r\n        bool _zeroForOne = _tokenIn < _tokenOut;\r\n\r\n        // do the swap\r\n        (int256 _amount0, int256 _amount1) = ISmardexPair(ISmardexFactory(factory).getPair(_tokenIn, _tokenOut)).swap(\r\n            _to,\r\n            _zeroForOne,\r\n            -_amountOut.toInt256(),\r\n            abi.encode(_data)\r\n        );\r\n\r\n        amountIn_ = _zeroForOne ? uint256(_amount0) : uint256(_amount1);\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/test/SmardexRouterTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\r\npragma solidity =0.8.17;\r\n\r\n// libraries\r\nimport \"../libraries/PoolAddress.sol\";\r\nimport \"../SmardexRouter.sol\";\r\n\r\ncontract SmardexRouterTest is SmardexRouter {\r\n    constructor(address _factory, address _WETH) SmardexRouter(_factory, _WETH) {}\r\n\r\n    function pairFor_pure(address factory, address tokenA, address tokenB) public view returns (address pair) {\r\n        pair = PoolAddress.pairFor(factory, tokenA, tokenB, whitelist);\r\n    }\r\n\r\n    function mint(address _pair, address _to, uint256 _amount0, uint256 _amount1, address _payer) public {\r\n        ISmardexPair(_pair).mint(_to, _amount0, _amount1, _payer);\r\n    }\r\n\r\n    function swap(address _pair, address _to, bool _zeroForOne, int256 _amountSpecified, bytes calldata _path) public {\r\n        ISmardexPair(_pair).swap(_to, _zeroForOne, _amountSpecified, _path);\r\n    }\r\n\r\n    function unwrapWETHTest(uint256 _amountMinimum, address _to) external {\r\n        _unwrapWETH(_amountMinimum, _to);\r\n    }\r\n}\r\n"
    },
    "contracts/periphery/test/WETH9.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\n// Copyright (C) 2015, 2016, 2017 Dapphub\r\n\r\n// This program is free software: you can redistribute it and/or modify\r\n// it under the terms of the GNU General Public License as published by\r\n// the Free Software Foundation, either version 3 of the License, or\r\n// (at your option) any later version.\r\n\r\n// This program is distributed in the hope that it will be useful,\r\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n// GNU General Public License for more details.\r\n\r\n// You should have received a copy of the GNU General Public License\r\n// along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\npragma solidity =0.8.17;\r\n\r\ncontract WETH9 {\r\n    string public name = \"Wrapped Ether\";\r\n    string public symbol = \"WETH\";\r\n    uint8 public decimals = 18;\r\n\r\n    event Approval(address indexed src, address indexed guy, uint256 wad);\r\n    event Transfer(address indexed src, address indexed dst, uint256 wad);\r\n    event Deposit(address indexed dst, uint256 wad);\r\n    event Withdrawal(address indexed src, uint256 wad);\r\n\r\n    mapping(address => uint256) public balanceOf;\r\n    mapping(address => mapping(address => uint256)) public allowance;\r\n\r\n    // function() public payable {\r\n    //     deposit();\r\n    // }\r\n    function deposit() public payable {\r\n        balanceOf[msg.sender] += msg.value;\r\n        emit Deposit(msg.sender, msg.value);\r\n    }\r\n\r\n    function withdraw(uint256 wad) public {\r\n        require(balanceOf[msg.sender] >= wad, \"\");\r\n        balanceOf[msg.sender] -= wad;\r\n        payable(msg.sender).transfer(wad);\r\n        emit Withdrawal(msg.sender, wad);\r\n    }\r\n\r\n    function totalSupply() public view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n\r\n    function approve(address guy, uint256 wad) public returns (bool) {\r\n        allowance[msg.sender][guy] = wad;\r\n        emit Approval(msg.sender, guy, wad);\r\n        return true;\r\n    }\r\n\r\n    function transfer(address dst, uint256 wad) public returns (bool) {\r\n        return transferFrom(msg.sender, dst, wad);\r\n    }\r\n\r\n    function transferFrom(address src, address dst, uint256 wad) public returns (bool) {\r\n        require(balanceOf[src] >= wad, \"\");\r\n\r\n        if (src != msg.sender && allowance[src][msg.sender] != type(uint256).max) {\r\n            require(allowance[src][msg.sender] >= wad, \"\");\r\n            allowance[src][msg.sender] -= wad;\r\n        }\r\n\r\n        balanceOf[src] -= wad;\r\n        balanceOf[dst] += wad;\r\n\r\n        emit Transfer(src, dst, wad);\r\n\r\n        return true;\r\n    }\r\n}\r\n\r\n/*\r\n                    GNU GENERAL PUBLIC LICENSE\r\n                       Version 3, 29 June 2007\r\n\r\n Copyright (C) 2007 Free Software Foundation, Inc. <http://fsf.org/>\r\n Everyone is permitted to copy and distribute verbatim copies\r\n of this license document, but changing it is not allowed.\r\n\r\n                            Preamble\r\n\r\n  The GNU General Public License is a free, copyleft license for\r\nsoftware and other kinds of works.\r\n\r\n  The licenses for most software and other practical works are designed\r\nto take away your freedom to share and change the works.  By contrast,\r\nthe GNU General Public License is intended to guarantee your freedom to\r\nshare and change all versions of a program--to make sure it remains free\r\nsoftware for all its users.  We, the Free Software Foundation, use the\r\nGNU General Public License for most of our software; it applies also to\r\nany other work released this way by its authors.  You can apply it to\r\nyour programs, too.\r\n\r\n  When we speak of free software, we are referring to freedom, not\r\nprice.  Our General Public Licenses are designed to make sure that you\r\nhave the freedom to distribute copies of free software (and charge for\r\nthem if you wish), that you receive source code or can get it if you\r\nwant it, that you can change the software or use pieces of it in new\r\nfree programs, and that you know you can do these things.\r\n\r\n  To protect your rights, we need to prevent others from denying you\r\nthese rights or asking you to surrender the rights.  Therefore, you have\r\ncertain responsibilities if you distribute copies of the software, or if\r\nyou modify it: responsibilities to respect the freedom of others.\r\n\r\n  For example, if you distribute copies of such a program, whether\r\ngratis or for a fee, you must pass on to the recipients the same\r\nfreedoms that you received.  You must make sure that they, too, receive\r\nor can get the source code.  And you must show them these terms so they\r\nknow their rights.\r\n\r\n  Developers that use the GNU GPL protect your rights with two steps:\r\n(1) assert copyright on the software, and (2) offer you this License\r\ngiving you legal permission to copy, distribute and/or modify it.\r\n\r\n  For the developers' and authors' protection, the GPL clearly explains\r\nthat there is no warranty for this free software.  For both users' and\r\nauthors' sake, the GPL requires that modified versions be marked as\r\nchanged, so that their problems will not be attributed erroneously to\r\nauthors of previous versions.\r\n\r\n  Some devices are designed to deny users access to install or run\r\nmodified versions of the software inside them, although the manufacturer\r\ncan do so.  This is fundamentally incompatible with the aim of\r\nprotecting users' freedom to change the software.  The systematic\r\npattern of such abuse occurs in the area of products for individuals to\r\nuse, which is precisely where it is most unacceptable.  Therefore, we\r\nhave designed this version of the GPL to prohibit the practice for those\r\nproducts.  If such problems arise substantially in other domains, we\r\nstand ready to extend this provision to those domains in future versions\r\nof the GPL, as needed to protect the freedom of users.\r\n\r\n  Finally, every program is threatened constantly by software patents.\r\nStates should not allow patents to restrict development and use of\r\nsoftware on general-purpose computers, but in those that do, we wish to\r\navoid the special danger that patents applied to a free program could\r\nmake it effectively proprietary.  To prevent this, the GPL assures that\r\npatents cannot be used to render the program non-free.\r\n\r\n  The precise terms and conditions for copying, distribution and\r\nmodification follow.\r\n\r\n                       TERMS AND CONDITIONS\r\n\r\n  0. Definitions.\r\n\r\n  \"This License\" refers to version 3 of the GNU General Public License.\r\n\r\n  \"Copyright\" also means copyright-like laws that apply to other kinds of\r\nworks, such as semiconductor masks.\r\n\r\n  \"The Program\" refers to any copyrightable work licensed under this\r\nLicense.  Each licensee is addressed as \"you\".  \"Licensees\" and\r\n\"recipients\" may be individuals or organizations.\r\n\r\n  To \"modify\" a work means to copy from or adapt all or part of the work\r\nin a fashion requiring copyright permission, other than the making of an\r\nexact copy.  The resulting work is called a \"modified version\" of the\r\nearlier work or a work \"based on\" the earlier work.\r\n\r\n  A \"covered work\" means either the unmodified Program or a work based\r\non the Program.\r\n\r\n  To \"propagate\" a work means to do anything with it that, without\r\npermission, would make you directly or secondarily liable for\r\ninfringement under applicable copyright law, except executing it on a\r\ncomputer or modifying a private copy.  Propagation includes copying,\r\ndistribution (with or without modification), making available to the\r\npublic, and in some countries other activities as well.\r\n\r\n  To \"convey\" a work means any kind of propagation that enables other\r\nparties to make or receive copies.  Mere interaction with a user through\r\na computer network, with no transfer of a copy, is not conveying.\r\n\r\n  An interactive user interface displays \"Appropriate Legal Notices\"\r\nto the extent that it includes a convenient and prominently visible\r\nfeature that (1) displays an appropriate copyright notice, and (2)\r\ntells the user that there is no warranty for the work (except to the\r\nextent that warranties are provided), that licensees may convey the\r\nwork under this License, and how to view a copy of this License.  If\r\nthe interface presents a list of user commands or options, such as a\r\nmenu, a prominent item in the list meets this criterion.\r\n\r\n  1. Source Code.\r\n\r\n  The \"source code\" for a work means the preferred form of the work\r\nfor making modifications to it.  \"Object code\" means any non-source\r\nform of a work.\r\n\r\n  A \"Standard Interface\" means an interface that either is an official\r\nstandard defined by a recognized standards body, or, in the case of\r\ninterfaces specified for a particular programming language, one that\r\nis widely used among developers working in that language.\r\n\r\n  The \"System Libraries\" of an executable work include anything, other\r\nthan the work as a whole, that (a) is included in the normal form of\r\npackaging a Major Component, but which is not part of that Major\r\nComponent, and (b) serves only to enable use of the work with that\r\nMajor Component, or to implement a Standard Interface for which an\r\nimplementation is available to the public in source code form.  A\r\n\"Major Component\", in this context, means a major essential component\r\n(kernel, window system, and so on) of the specific operating system\r\n(if any) on which the executable work runs, or a compiler used to\r\nproduce the work, or an object code interpreter used to run it.\r\n\r\n  The \"Corresponding Source\" for a work in object code form means all\r\nthe source code needed to generate, install, and (for an executable\r\nwork) run the object code and to modify the work, including scripts to\r\ncontrol those activities.  However, it does not include the work's\r\nSystem Libraries, or general-purpose tools or generally available free\r\nprograms which are used unmodified in performing those activities but\r\nwhich are not part of the work.  For example, Corresponding Source\r\nincludes interface definition files associated with source files for\r\nthe work, and the source code for shared libraries and dynamically\r\nlinked subprograms that the work is specifically designed to require,\r\nsuch as by intimate data communication or control flow between those\r\nsubprograms and other parts of the work.\r\n\r\n  The Corresponding Source need not include anything that users\r\ncan regenerate automatically from other parts of the Corresponding\r\nSource.\r\n\r\n  The Corresponding Source for a work in source code form is that\r\nsame work.\r\n\r\n  2. Basic Permissions.\r\n\r\n  All rights granted under this License are granted for the term of\r\ncopyright on the Program, and are irrevocable provided the stated\r\nconditions are met.  This License explicitly affirms your unlimited\r\npermission to run the unmodified Program.  The output from running a\r\ncovered work is covered by this License only if the output, given its\r\ncontent, constitutes a covered work.  This License acknowledges your\r\nrights of fair use or other equivalent, as provided by copyright law.\r\n\r\n  You may make, run and propagate covered works that you do not\r\nconvey, without conditions so long as your license otherwise remains\r\nin force.  You may convey covered works to others for the sole purpose\r\nof having them make modifications exclusively for you, or provide you\r\nwith facilities for running those works, provided that you comply with\r\nthe terms of this License in conveying all material for which you do\r\nnot control copyright.  Those thus making or running the covered works\r\nfor you must do so exclusively on your behalf, under your direction\r\nand control, on terms that prohibit them from making any copies of\r\nyour copyrighted material outside their relationship with you.\r\n\r\n  Conveying under any other circumstances is permitted solely under\r\nthe conditions stated below.  Sublicensing is not allowed; section 10\r\nmakes it unnecessary.\r\n\r\n  3. Protecting Users' Legal Rights From Anti-Circumvention Law.\r\n\r\n  No covered work shall be deemed part of an effective technological\r\nmeasure under any applicable law fulfilling obligations under article\r\n11 of the WIPO copyright treaty adopted on 20 December 1996, or\r\nsimilar laws prohibiting or restricting circumvention of such\r\nmeasures.\r\n\r\n  When you convey a covered work, you waive any legal power to forbid\r\ncircumvention of technological measures to the extent such circumvention\r\nis effected by exercising rights under this License with respect to\r\nthe covered work, and you disclaim any intention to limit operation or\r\nmodification of the work as a means of enforcing, against the work's\r\nusers, your or third parties' legal rights to forbid circumvention of\r\ntechnological measures.\r\n\r\n  4. Conveying Verbatim Copies.\r\n\r\n  You may convey verbatim copies of the Program's source code as you\r\nreceive it, in any medium, provided that you conspicuously and\r\nappropriately publish on each copy an appropriate copyright notice;\r\nkeep intact all notices stating that this License and any\r\nnon-permissive terms added in accord with section 7 apply to the code;\r\nkeep intact all notices of the absence of any warranty; and give all\r\nrecipients a copy of this License along with the Program.\r\n\r\n  You may charge any price or no price for each copy that you convey,\r\nand you may offer support or warranty protection for a fee.\r\n\r\n  5. Conveying Modified Source Versions.\r\n\r\n  You may convey a work based on the Program, or the modifications to\r\nproduce it from the Program, in the form of source code under the\r\nterms of section 4, provided that you also meet all of these conditions:\r\n\r\n    a) The work must carry prominent notices stating that you modified\r\n    it, and giving a relevant date.\r\n\r\n    b) The work must carry prominent notices stating that it is\r\n    released under this License and any conditions added under section\r\n    7.  This requirement modifies the requirement in section 4 to\r\n    \"keep intact all notices\".\r\n\r\n    c) You must license the entire work, as a whole, under this\r\n    License to anyone who comes into possession of a copy.  This\r\n    License will therefore apply, along with any applicable section 7\r\n    additional terms, to the whole of the work, and all its parts,\r\n    regardless of how they are packaged.  This License gives no\r\n    permission to license the work in any other way, but it does not\r\n    invalidate such permission if you have separately received it.\r\n\r\n    d) If the work has interactive user interfaces, each must display\r\n    Appropriate Legal Notices; however, if the Program has interactive\r\n    interfaces that do not display Appropriate Legal Notices, your\r\n    work need not make them do so.\r\n\r\n  A compilation of a covered work with other separate and independent\r\nworks, which are not by their nature extensions of the covered work,\r\nand which are not combined with it such as to form a larger program,\r\nin or on a volume of a storage or distribution medium, is called an\r\n\"aggregate\" if the compilation and its resulting copyright are not\r\nused to limit the access or legal rights of the compilation's users\r\nbeyond what the individual works permit.  Inclusion of a covered work\r\nin an aggregate does not cause this License to apply to the other\r\nparts of the aggregate.\r\n\r\n  6. Conveying Non-Source Forms.\r\n\r\n  You may convey a covered work in object code form under the terms\r\nof sections 4 and 5, provided that you also convey the\r\nmachine-readable Corresponding Source under the terms of this License,\r\nin one of these ways:\r\n\r\n    a) Convey the object code in, or embodied in, a physical product\r\n    (including a physical distribution medium), accompanied by the\r\n    Corresponding Source fixed on a durable physical medium\r\n    customarily used for software interchange.\r\n\r\n    b) Convey the object code in, or embodied in, a physical product\r\n    (including a physical distribution medium), accompanied by a\r\n    written offer, valid for at least three years and valid for as\r\n    long as you offer spare parts or customer support for that product\r\n    model, to give anyone who possesses the object code either (1) a\r\n    copy of the Corresponding Source for all the software in the\r\n    product that is covered by this License, on a durable physical\r\n    medium customarily used for software interchange, for a price no\r\n    more than your reasonable cost of physically performing this\r\n    conveying of source, or (2) access to copy the\r\n    Corresponding Source from a network server at no charge.\r\n\r\n    c) Convey individual copies of the object code with a copy of the\r\n    written offer to provide the Corresponding Source.  This\r\n    alternative is allowed only occasionally and noncommercially, and\r\n    only if you received the object code with such an offer, in accord\r\n    with subsection 6b.\r\n\r\n    d) Convey the object code by offering access from a designated\r\n    place (gratis or for a charge), and offer equivalent access to the\r\n    Corresponding Source in the same way through the same place at no\r\n    further charge.  You need not require recipients to copy the\r\n    Corresponding Source along with the object code.  If the place to\r\n    copy the object code is a network server, the Corresponding Source\r\n    may be on a different server (operated by you or a third party)\r\n    that supports equivalent copying facilities, provided you maintain\r\n    clear directions next to the object code saying where to find the\r\n    Corresponding Source.  Regardless of what server hosts the\r\n    Corresponding Source, you remain obligated to ensure that it is\r\n    available for as long as needed to satisfy these requirements.\r\n\r\n    e) Convey the object code using peer-to-peer transmission, provided\r\n    you inform other peers where the object code and Corresponding\r\n    Source of the work are being offered to the general public at no\r\n    charge under subsection 6d.\r\n\r\n  A separable portion of the object code, whose source code is excluded\r\nfrom the Corresponding Source as a System Library, need not be\r\nincluded in conveying the object code work.\r\n\r\n  A \"User Product\" is either (1) a \"consumer product\", which means any\r\ntangible personal property which is normally used for personal, family,\r\nor household purposes, or (2) anything designed or sold for incorporation\r\ninto a dwelling.  In determining whether a product is a consumer product,\r\ndoubtful cases shall be resolved in favor of coverage.  For a particular\r\nproduct received by a particular user, \"normally used\" refers to a\r\ntypical or common use of that class of product, regardless of the status\r\nof the particular user or of the way in which the particular user\r\nactually uses, or expects or is expected to use, the product.  A product\r\nis a consumer product regardless of whether the product has substantial\r\ncommercial, industrial or non-consumer uses, unless such uses represent\r\nthe only significant mode of use of the product.\r\n\r\n  \"Installation Information\" for a User Product means any methods,\r\nprocedures, authorization keys, or other information required to install\r\nand execute modified versions of a covered work in that User Product from\r\na modified version of its Corresponding Source.  The information must\r\nsuffice to ensure that the continued functioning of the modified object\r\ncode is in no case prevented or interfered with solely because\r\nmodification has been made.\r\n\r\n  If you convey an object code work under this section in, or with, or\r\nspecifically for use in, a User Product, and the conveying occurs as\r\npart of a transaction in which the right of possession and use of the\r\nUser Product is transferred to the recipient in perpetuity or for a\r\nfixed term (regardless of how the transaction is characterized), the\r\nCorresponding Source conveyed under this section must be accompanied\r\nby the Installation Information.  But this requirement does not apply\r\nif neither you nor any third party retains the ability to install\r\nmodified object code on the User Product (for example, the work has\r\nbeen installed in ROM).\r\n\r\n  The requirement to provide Installation Information does not include a\r\nrequirement to continue to provide support service, warranty, or updates\r\nfor a work that has been modified or installed by the recipient, or for\r\nthe User Product in which it has been modified or installed.  Access to a\r\nnetwork may be denied when the modification itself materially and\r\nadversely affects the operation of the network or violates the rules and\r\nprotocols for communication across the network.\r\n\r\n  Corresponding Source conveyed, and Installation Information provided,\r\nin accord with this section must be in a format that is publicly\r\ndocumented (and with an implementation available to the public in\r\nsource code form), and must require no special password or key for\r\nunpacking, reading or copying.\r\n\r\n  7. Additional Terms.\r\n\r\n  \"Additional permissions\" are terms that supplement the terms of this\r\nLicense by making exceptions from one or more of its conditions.\r\nAdditional permissions that are applicable to the entire Program shall\r\nbe treated as though they were included in this License, to the extent\r\nthat they are valid under applicable law.  If additional permissions\r\napply only to part of the Program, that part may be used separately\r\nunder those permissions, but the entire Program remains governed by\r\nthis License without regard to the additional permissions.\r\n\r\n  When you convey a copy of a covered work, you may at your option\r\nremove any additional permissions from that copy, or from any part of\r\nit.  (Additional permissions may be written to require their own\r\nremoval in certain cases when you modify the work.)  You may place\r\nadditional permissions on material, added by you to a covered work,\r\nfor which you have or can give appropriate copyright permission.\r\n\r\n  Notwithstanding any other provision of this License, for material you\r\nadd to a covered work, you may (if authorized by the copyright holders of\r\nthat material) supplement the terms of this License with terms:\r\n\r\n    a) Disclaiming warranty or limiting liability differently from the\r\n    terms of sections 15 and 16 of this License; or\r\n\r\n    b) Requiring preservation of specified reasonable legal notices or\r\n    author attributions in that material or in the Appropriate Legal\r\n    Notices displayed by works containing it; or\r\n\r\n    c) Prohibiting misrepresentation of the origin of that material, or\r\n    requiring that modified versions of such material be marked in\r\n    reasonable ways as different from the original version; or\r\n\r\n    d) Limiting the use for publicity purposes of names of licensors or\r\n    authors of the material; or\r\n\r\n    e) Declining to grant rights under trademark law for use of some\r\n    trade names, trademarks, or service marks; or\r\n\r\n    f) Requiring indemnification of licensors and authors of that\r\n    material by anyone who conveys the material (or modified versions of\r\n    it) with contractual assumptions of liability to the recipient, for\r\n    any liability that these contractual assumptions directly impose on\r\n    those licensors and authors.\r\n\r\n  All other non-permissive additional terms are considered \"further\r\nrestrictions\" within the meaning of section 10.  If the Program as you\r\nreceived it, or any part of it, contains a notice stating that it is\r\ngoverned by this License along with a term that is a further\r\nrestriction, you may remove that term.  If a license document contains\r\na further restriction but permits relicensing or conveying under this\r\nLicense, you may add to a covered work material governed by the terms\r\nof that license document, provided that the further restriction does\r\nnot survive such relicensing or conveying.\r\n\r\n  If you add terms to a covered work in accord with this section, you\r\nmust place, in the relevant source files, a statement of the\r\nadditional terms that apply to those files, or a notice indicating\r\nwhere to find the applicable terms.\r\n\r\n  Additional terms, permissive or non-permissive, may be stated in the\r\nform of a separately written license, or stated as exceptions;\r\nthe above requirements apply either way.\r\n\r\n  8. Termination.\r\n\r\n  You may not propagate or modify a covered work except as expressly\r\nprovided under this License.  Any attempt otherwise to propagate or\r\nmodify it is void, and will automatically terminate your rights under\r\nthis License (including any patent licenses granted under the third\r\nparagraph of section 11).\r\n\r\n  However, if you cease all violation of this License, then your\r\nlicense from a particular copyright holder is reinstated (a)\r\nprovisionally, unless and until the copyright holder explicitly and\r\nfinally terminates your license, and (b) permanently, if the copyright\r\nholder fails to notify you of the violation by some reasonable means\r\nprior to 60 days after the cessation.\r\n\r\n  Moreover, your license from a particular copyright holder is\r\nreinstated permanently if the copyright holder notifies you of the\r\nviolation by some reasonable means, this is the first time you have\r\nreceived notice of violation of this License (for any work) from that\r\ncopyright holder, and you cure the violation prior to 30 days after\r\nyour receipt of the notice.\r\n\r\n  Termination of your rights under this section does not terminate the\r\nlicenses of parties who have received copies or rights from you under\r\nthis License.  If your rights have been terminated and not permanently\r\nreinstated, you do not qualify to receive new licenses for the same\r\nmaterial under section 10.\r\n\r\n  9. Acceptance Not Required for Having Copies.\r\n\r\n  You are not required to accept this License in order to receive or\r\nrun a copy of the Program.  Ancillary propagation of a covered work\r\noccurring solely as a consequence of using peer-to-peer transmission\r\nto receive a copy likewise does not require acceptance.  However,\r\nnothing other than this License grants you permission to propagate or\r\nmodify any covered work.  These actions infringe copyright if you do\r\nnot accept this License.  Therefore, by modifying or propagating a\r\ncovered work, you indicate your acceptance of this License to do so.\r\n\r\n  10. Automatic Licensing of Downstream Recipients.\r\n\r\n  Each time you convey a covered work, the recipient automatically\r\nreceives a license from the original licensors, to run, modify and\r\npropagate that work, subject to this License.  You are not responsible\r\nfor enforcing compliance by third parties with this License.\r\n\r\n  An \"entity transaction\" is a transaction transferring control of an\r\norganization, or substantially all assets of one, or subdividing an\r\norganization, or merging organizations.  If propagation of a covered\r\nwork results from an entity transaction, each party to that\r\ntransaction who receives a copy of the work also receives whatever\r\nlicenses to the work the party's predecessor in interest had or could\r\ngive under the previous paragraph, plus a right to possession of the\r\nCorresponding Source of the work from the predecessor in interest, if\r\nthe predecessor has it or can get it with reasonable efforts.\r\n\r\n  You may not impose any further restrictions on the exercise of the\r\nrights granted or affirmed under this License.  For example, you may\r\nnot impose a license fee, royalty, or other charge for exercise of\r\nrights granted under this License, and you may not initiate litigation\r\n(including a cross-claim or counterclaim in a lawsuit) alleging that\r\nany patent claim is infringed by making, using, selling, offering for\r\nsale, or importing the Program or any portion of it.\r\n\r\n  11. Patents.\r\n\r\n  A \"contributor\" is a copyright holder who authorizes use under this\r\nLicense of the Program or a work on which the Program is based.  The\r\nwork thus licensed is called the contributor's \"contributor version\".\r\n\r\n  A contributor's \"essential patent claims\" are all patent claims\r\nowned or controlled by the contributor, whether already acquired or\r\nhereafter acquired, that would be infringed by some manner, permitted\r\nby this License, of making, using, or selling its contributor version,\r\nbut do not include claims that would be infringed only as a\r\nconsequence of further modification of the contributor version.  For\r\npurposes of this definition, \"control\" includes the right to grant\r\npatent sublicenses in a manner consistent with the requirements of\r\nthis License.\r\n\r\n  Each contributor grants you a non-exclusive, worldwide, royalty-free\r\npatent license under the contributor's essential patent claims, to\r\nmake, use, sell, offer for sale, import and otherwise run, modify and\r\npropagate the contents of its contributor version.\r\n\r\n  In the following three paragraphs, a \"patent license\" is any express\r\nagreement or commitment, however denominated, not to enforce a patent\r\n(such as an express permission to practice a patent or covenant not to\r\nsue for patent infringement).  To \"grant\" such a patent license to a\r\nparty means to make such an agreement or commitment not to enforce a\r\npatent against the party.\r\n\r\n  If you convey a covered work, knowingly relying on a patent license,\r\nand the Corresponding Source of the work is not available for anyone\r\nto copy, free of charge and under the terms of this License, through a\r\npublicly available network server or other readily accessible means,\r\nthen you must either (1) cause the Corresponding Source to be so\r\navailable, or (2) arrange to deprive yourself of the benefit of the\r\npatent license for this particular work, or (3) arrange, in a manner\r\nconsistent with the requirements of this License, to extend the patent\r\nlicense to downstream recipients.  \"Knowingly relying\" means you have\r\nactual knowledge that, but for the patent license, your conveying the\r\ncovered work in a country, or your recipient's use of the covered work\r\nin a country, would infringe one or more identifiable patents in that\r\ncountry that you have reason to believe are valid.\r\n\r\n  If, pursuant to or in connection with a single transaction or\r\narrangement, you convey, or propagate by procuring conveyance of, a\r\ncovered work, and grant a patent license to some of the parties\r\nreceiving the covered work authorizing them to use, propagate, modify\r\nor convey a specific copy of the covered work, then the patent license\r\nyou grant is automatically extended to all recipients of the covered\r\nwork and works based on it.\r\n\r\n  A patent license is \"discriminatory\" if it does not include within\r\nthe scope of its coverage, prohibits the exercise of, or is\r\nconditioned on the non-exercise of one or more of the rights that are\r\nspecifically granted under this License.  You may not convey a covered\r\nwork if you are a party to an arrangement with a third party that is\r\nin the business of distributing software, under which you make payment\r\nto the third party based on the extent of your activity of conveying\r\nthe work, and under which the third party grants, to any of the\r\nparties who would receive the covered work from you, a discriminatory\r\npatent license (a) in connection with copies of the covered work\r\nconveyed by you (or copies made from those copies), or (b) primarily\r\nfor and in connection with specific products or compilations that\r\ncontain the covered work, unless you entered into that arrangement,\r\nor that patent license was granted, prior to 28 March 2007.\r\n\r\n  Nothing in this License shall be construed as excluding or limiting\r\nany implied license or other defenses to infringement that may\r\notherwise be available to you under applicable patent law.\r\n\r\n  12. No Surrender of Others' Freedom.\r\n\r\n  If conditions are imposed on you (whether by court order, agreement or\r\notherwise) that contradict the conditions of this License, they do not\r\nexcuse you from the conditions of this License.  If you cannot convey a\r\ncovered work so as to satisfy simultaneously your obligations under this\r\nLicense and any other pertinent obligations, then as a consequence you may\r\nnot convey it at all.  For example, if you agree to terms that obligate you\r\nto collect a royalty for further conveying from those to whom you convey\r\nthe Program, the only way you could satisfy both those terms and this\r\nLicense would be to refrain entirely from conveying the Program.\r\n\r\n  13. Use with the GNU Affero General Public License.\r\n\r\n  Notwithstanding any other provision of this License, you have\r\npermission to link or combine any covered work with a work licensed\r\nunder version 3 of the GNU Affero General Public License into a single\r\ncombined work, and to convey the resulting work.  The terms of this\r\nLicense will continue to apply to the part which is the covered work,\r\nbut the special requirements of the GNU Affero General Public License,\r\nsection 13, concerning interaction through a network will apply to the\r\ncombination as such.\r\n\r\n  14. Revised Versions of this License.\r\n\r\n  The Free Software Foundation may publish revised and/or new versions of\r\nthe GNU General Public License from time to time.  Such new versions will\r\nbe similar in spirit to the present version, but may differ in detail to\r\naddress new problems or concerns.\r\n\r\n  Each version is given a distinguishing version number.  If the\r\nProgram specifies that a certain numbered version of the GNU General\r\nPublic License \"or any later version\" applies to it, you have the\r\noption of following the terms and conditions either of that numbered\r\nversion or of any later version published by the Free Software\r\nFoundation.  If the Program does not specify a version number of the\r\nGNU General Public License, you may choose any version ever published\r\nby the Free Software Foundation.\r\n\r\n  If the Program specifies that a proxy can decide which future\r\nversions of the GNU General Public License can be used, that proxy's\r\npublic statement of acceptance of a version permanently authorizes you\r\nto choose that version for the Program.\r\n\r\n  Later license versions may give you additional or different\r\npermissions.  However, no additional obligations are imposed on any\r\nauthor or copyright holder as a result of your choosing to follow a\r\nlater version.\r\n\r\n  15. Disclaimer of Warranty.\r\n\r\n  THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY\r\nAPPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT\r\nHOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM \"AS IS\" WITHOUT WARRANTY\r\nOF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO,\r\nTHE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\r\nPURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE PROGRAM\r\nIS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF\r\nALL NECESSARY SERVICING, REPAIR OR CORRECTION.\r\n\r\n  16. Limitation of Liability.\r\n\r\n  IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\r\nWILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR CONVEYS\r\nTHE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, INCLUDING ANY\r\nGENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE\r\nUSE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF\r\nDATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD\r\nPARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS),\r\nEVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF\r\nSUCH DAMAGES.\r\n\r\n  17. Interpretation of Sections 15 and 16.\r\n\r\n  If the disclaimer of warranty and limitation of liability provided\r\nabove cannot be given local legal effect according to their terms,\r\nreviewing courts shall apply local law that most closely approximates\r\nan absolute waiver of all civil liability in connection with the\r\nProgram, unless a warranty or assumption of liability accompanies a\r\ncopy of the Program in return for a fee.\r\n\r\n                     END OF TERMS AND CONDITIONS\r\n\r\n            How to Apply These Terms to Your New Programs\r\n\r\n  If you develop a new program, and you want it to be of the greatest\r\npossible use to the public, the best way to achieve this is to make it\r\nfree software which everyone can redistribute and change under these terms.\r\n\r\n  To do so, attach the following notices to the program.  It is safest\r\nto attach them to the start of each source file to most effectively\r\nstate the exclusion of warranty; and each file should have at least\r\nthe \"copyright\" line and a pointer to where the full notice is found.\r\n\r\n    <one line to give the program's name and a brief idea of what it does.>\r\n    Copyright (C) <year>  <name of author>\r\n\r\n    This program is free software: you can redistribute it and/or modify\r\n    it under the terms of the GNU General Public License as published by\r\n    the Free Software Foundation, either version 3 of the License, or\r\n    (at your option) any later version.\r\n\r\n    This program is distributed in the hope that it will be useful,\r\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n    GNU General Public License for more details.\r\n\r\n    You should have received a copy of the GNU General Public License\r\n    along with this program.  If not, see <http://www.gnu.org/licenses/>.\r\n\r\nAlso add information on how to contact you by electronic and paper mail.\r\n\r\n  If the program does terminal interaction, make it output a short\r\nnotice like this when it starts in an interactive mode:\r\n\r\n    <program>  Copyright (C) <year>  <name of author>\r\n    This program comes with ABSOLUTELY NO WARRANTY; for details type `show w'.\r\n    This is free software, and you are welcome to redistribute it\r\n    under certain conditions; type `show c' for details.\r\n\r\nThe hypothetical commands `show w' and `show c' should show the appropriate\r\nparts of the General Public License.  Of course, your program's commands\r\nmight be different; for a GUI interface, you would use an \"about box\".\r\n\r\n  You should also get your employer (if you work as a programmer) or school,\r\nif any, to sign a \"copyright disclaimer\" for the program, if necessary.\r\nFor more information on this, and how to apply and follow the GNU GPL, see\r\n<http://www.gnu.org/licenses/>.\r\n\r\n  The GNU General Public License does not permit incorporating your program\r\ninto proprietary programs.  If your program is a subroutine library, you\r\nmay consider it more useful to permit linking proprietary applications with\r\nthe library.  If this is what you want to do, use the GNU Lesser General\r\nPublic License instead of this License.  But first, please read\r\n<http://www.gnu.org/philosophy/why-not-lgpl.html>.\r\n\r\n*/\r\n"
    },
    "contracts/rewards/AutoSwapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\n// libraries\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../core/libraries/SmardexLibrary.sol\";\r\nimport \"../periphery/libraries/Path.sol\";\r\n\r\n// interfaces\r\nimport \"../periphery/interfaces/ISmardexRouter.sol\";\r\nimport \"../core/interfaces/ISmardexPair.sol\";\r\nimport \"./interfaces/IAutoSwapper.sol\";\r\n\r\n/**\r\n * @title AutoSwapper\r\n * @notice AutoSwapper makes it automatic and/or public to get fees from Smardex and convert it to tokens for staking\r\n */\r\ncontract AutoSwapper is IAutoSwapper, Ownable {\r\n    using SafeERC20 for IERC20;\r\n    using SafeCast for uint256;\r\n    using SafeCast for int256;\r\n    using Path for bytes;\r\n    using Path for address[];\r\n\r\n    bytes4 private constant SWAP_SELECTOR = bytes4(keccak256(bytes(\"swap(address,bool,int256,bytes)\")));\r\n    uint256 private constant AUTOSWAP_SLIPPAGE = 2; // 2%\r\n    uint256 private constant AUTOSWAP_SLIPPAGE_BASE = 100;\r\n\r\n    ISmardexFactory public immutable factory;\r\n    address public immutable stakingAddress;\r\n    IERC20 public immutable smardexToken;\r\n\r\n    ISmardexPair private constant DEFAULT_CACHED_PAIR = ISmardexPair(address(0));\r\n    ISmardexPair private cachedPair = DEFAULT_CACHED_PAIR;\r\n\r\n    ISmardexRouter public immutable router;\r\n\r\n    constructor(ISmardexFactory _factory, IERC20 _smardexToken, address _stakingAddress, ISmardexRouter _router) {\r\n        require(address(_factory) != address(0), \"AutoSwapper: INVALID_FACTORY_ADDRESS\");\r\n        require(address(_smardexToken) != address(0), \"AutoSwapper: INVALID_SDEX_ADDRESS\");\r\n        require(_stakingAddress != address(0), \"AutoSwapper: INVALID_STAKING_ADDRESS\");\r\n\r\n        factory = _factory;\r\n        smardexToken = _smardexToken;\r\n        stakingAddress = _stakingAddress;\r\n        router = _router;\r\n    }\r\n\r\n    /// @inheritdoc IAutoSwapper\r\n    function executeWork(IERC20 _token0, IERC20 _token1) external {\r\n        uint256 _amount0 = _swapAndSend(_token0);\r\n        uint256 _amount1 = _swapAndSend(_token1);\r\n        uint256 _transferredAmount = transferTokens();\r\n\r\n        emit workExecuted(_token0, _amount0, _token1, _amount1, _transferredAmount);\r\n    }\r\n\r\n    /// @inheritdoc IAutoSwapper\r\n    function swapTokenWithPath(\r\n        uint256 _amountToSwap,\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        uint256 _deadline\r\n    ) external onlyOwner {\r\n        require(_path.length > 1, \"AutoSwapper: INVALID_PATH\");\r\n        require(_path[_path.length - 1] == address(smardexToken), \"AutoSwapper: INVALID_LAST_TOKEN\");\r\n        IERC20 _token = IERC20(_path[0]);\r\n\r\n        uint256 _balance = _token.balanceOf(address(this));\r\n        require(_amountToSwap <= _balance, \"AutoSwapper: INVALID_AMOUNT\");\r\n\r\n        uint256 _amountIn;\r\n        if (_amountToSwap != 0) _amountIn = _amountToSwap;\r\n        else _amountIn = _balance;\r\n        _token.safeApprove(address(router), _amountIn);\r\n\r\n        router.swapExactTokensForTokens(_amountIn, _amountOutMin, _path, stakingAddress, _deadline);\r\n    }\r\n\r\n    /// @inheritdoc IAutoSwapper\r\n    function transferTokens() public returns (uint256 _amount) {\r\n        _amount = smardexToken.balanceOf(address(this));\r\n        if (_amount != 0) {\r\n            smardexToken.safeTransfer(stakingAddress, _amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice private function to swap token in SDEX and send it to the staking address\r\n     * @param _token address of the token to swap into sdex\r\n     * @return amount of input tokens swapped\r\n     */\r\n    function _swapAndSend(IERC20 _token) private returns (uint256) {\r\n        if (_token == smardexToken) {\r\n            return 0;\r\n        }\r\n        SwapCallParams memory _params = SwapCallParams({\r\n            zeroForOne: _token < smardexToken,\r\n            balanceIn: _token.balanceOf(address(this)),\r\n            pair: ISmardexPair(factory.getPair(address(_token), address(smardexToken))),\r\n            fictiveReserve0: 0,\r\n            fictiveReserve1: 0,\r\n            oldPriceAv0: 0,\r\n            oldPriceAv1: 0,\r\n            oldPriceAvTimestamp: 0,\r\n            newPriceAvIn: 0,\r\n            newPriceAvOut: 0\r\n        });\r\n\r\n        // basic check on input data\r\n        if (_params.balanceIn == 0 || address(_params.pair) == address(0)) {\r\n            return 0;\r\n        }\r\n\r\n        // get reserves and pricesAv\r\n        (_params.fictiveReserve0, _params.fictiveReserve1) = _params.pair.getFictiveReserves();\r\n        (_params.oldPriceAv0, _params.oldPriceAv1, _params.oldPriceAvTimestamp) = _params.pair.getPriceAverage();\r\n\r\n        if (_params.oldPriceAv0 == 0 || _params.oldPriceAv1 == 0) {\r\n            (_params.oldPriceAv0, _params.oldPriceAv1) = (_params.fictiveReserve0, _params.fictiveReserve1);\r\n        }\r\n\r\n        if (_params.zeroForOne) {\r\n            (_params.newPriceAvIn, _params.newPriceAvOut) = SmardexLibrary.getUpdatedPriceAverage(\r\n                _params.fictiveReserve0,\r\n                _params.fictiveReserve1,\r\n                _params.oldPriceAvTimestamp,\r\n                _params.oldPriceAv0,\r\n                _params.oldPriceAv1,\r\n                block.timestamp\r\n            );\r\n        } else {\r\n            (_params.newPriceAvIn, _params.newPriceAvOut) = SmardexLibrary.getUpdatedPriceAverage(\r\n                _params.fictiveReserve1,\r\n                _params.fictiveReserve0,\r\n                _params.oldPriceAvTimestamp,\r\n                _params.oldPriceAv1,\r\n                _params.oldPriceAv0,\r\n                block.timestamp\r\n            );\r\n        }\r\n\r\n        // we allow for 2% slippage from previous swaps in block\r\n        uint256 _amountOutWithSlippage = (_params.balanceIn *\r\n            _params.newPriceAvOut *\r\n            (AUTOSWAP_SLIPPAGE_BASE - AUTOSWAP_SLIPPAGE)) / (_params.newPriceAvIn * AUTOSWAP_SLIPPAGE_BASE);\r\n        require(_amountOutWithSlippage != 0, \"AutoSwapper: slippage calculation failed\");\r\n\r\n        cachedPair = _params.pair;\r\n\r\n        // we dont check for success as we dont want to revert the whole tx if the swap fails\r\n        (bool success, ) = address(_params.pair).call(\r\n            abi.encodeWithSelector(\r\n                SWAP_SELECTOR,\r\n                stakingAddress,\r\n                _token < smardexToken,\r\n                _params.balanceIn.toInt256(),\r\n                abi.encode(\r\n                    SwapCallbackData({ path: abi.encodePacked(_token, smardexToken), payer: address(this) }),\r\n                    _amountOutWithSlippage\r\n                )\r\n            )\r\n        );\r\n\r\n        cachedPair = DEFAULT_CACHED_PAIR;\r\n\r\n        return success ? _params.balanceIn : 0;\r\n    }\r\n\r\n    /// @inheritdoc ISmardexSwapCallback\r\n    function smardexSwapCallback(int256 _amount0Delta, int256 _amount1Delta, bytes calldata _dataFromPair) external {\r\n        require(_amount0Delta > 0 || _amount1Delta > 0, \"SmardexRouter: Callback Invalid amount\");\r\n        (SwapCallbackData memory _data, uint256 _amountOutWithSlippage) = abi.decode(\r\n            _dataFromPair,\r\n            (SwapCallbackData, uint256)\r\n        );\r\n        (address _tokenIn, ) = _data.path.decodeFirstPool();\r\n        require(msg.sender == address(cachedPair), \"SmarDexRouter: INVALID_PAIR\"); // ensure that msg.sender is a pair\r\n        // ensure that the trade gives at least the minimum amount of output token (negative delta)\r\n        require(\r\n            (_amount0Delta < 0 ? uint256(-_amount0Delta) : (-_amount1Delta).toUint256()) >= _amountOutWithSlippage,\r\n            \"SmardexAutoSwapper: Invalid price\"\r\n        );\r\n        // send positive delta to pair\r\n        IERC20(_tokenIn).safeTransfer(\r\n            msg.sender,\r\n            _amount0Delta > 0 ? uint256(_amount0Delta) : _amount1Delta.toUint256()\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/AutoSwapperL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\n// libraries\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/SafeCast.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"../core/libraries/SmardexLibrary.sol\";\r\nimport \"../periphery/libraries/Path.sol\";\r\n\r\n// interfaces\r\nimport \"../periphery/interfaces/ISmardexRouter.sol\";\r\nimport \"../core/interfaces/ISmardexPair.sol\";\r\nimport \"./interfaces/IAutoSwapper.sol\";\r\n\r\n/**\r\n * @title AutoSwapper\r\n * @notice AutoSwapper makes it automatic and/or public to get fees from Smardex and burn it\r\n */\r\ncontract AutoSwapperL2 is IAutoSwapper, Ownable {\r\n    using SafeERC20 for IERC20;\r\n    using SafeCast for uint256;\r\n    using SafeCast for int256;\r\n    using Path for bytes;\r\n\r\n    bytes4 private constant SWAP_SELECTOR = bytes4(keccak256(bytes(\"swap(address,bool,int256,bytes)\")));\r\n    uint256 private constant AUTOSWAP_SLIPPAGE = 2; // 2%\r\n    uint256 private constant AUTOSWAP_SLIPPAGE_BASE = 100;\r\n\r\n    // burn address 0x000000000000000000000000000000000000dEaD\r\n    address private constant DEAD_ADR = address(0xdead);\r\n\r\n    ISmardexFactory public immutable factory;\r\n    IERC20 public immutable smardexToken;\r\n\r\n    ISmardexPair private constant DEFAULT_CACHED_PAIR = ISmardexPair(address(0));\r\n    ISmardexPair private cachedPair = DEFAULT_CACHED_PAIR;\r\n\r\n    ISmardexRouter public immutable router;\r\n\r\n    constructor(ISmardexFactory _factory, IERC20 _smardexToken, ISmardexRouter _router) {\r\n        require(address(_factory) != address(0), \"AutoSwapper: INVALID_FACTORY_ADDRESS\");\r\n        require(address(_smardexToken) != address(0), \"AutoSwapper: INVALID_SDEX_ADDRESS\");\r\n\r\n        factory = _factory;\r\n        smardexToken = _smardexToken;\r\n        router = _router;\r\n    }\r\n\r\n    /// @inheritdoc IAutoSwapper\r\n    function executeWork(IERC20 _token0, IERC20 _token1) external {\r\n        uint256 _amount0 = _swapAndSend(_token0);\r\n        uint256 _amount1 = _swapAndSend(_token1);\r\n        uint256 _transferredAmount = transferTokens();\r\n\r\n        emit workExecuted(_token0, _amount0, _token1, _amount1, _transferredAmount);\r\n    }\r\n\r\n    /// @inheritdoc IAutoSwapper\r\n    function swapTokenWithPath(\r\n        uint256 _amountToSwap,\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        uint256 _deadline\r\n    ) external onlyOwner {\r\n        require(_path.length > 1, \"AutoSwapper: INVALID_PATH\");\r\n        require(_path[_path.length - 1] == address(smardexToken), \"AutoSwapper: INVALID_LAST_TOKEN\");\r\n        IERC20 _token = IERC20(_path[0]);\r\n\r\n        uint256 _balance = _token.balanceOf(address(this));\r\n        require(_amountToSwap <= _balance, \"AutoSwapper: INVALID_AMOUNT\");\r\n\r\n        uint256 _amountIn;\r\n        if (_amountToSwap != 0) _amountIn = _amountToSwap;\r\n        else _amountIn = _balance;\r\n        _token.safeApprove(address(router), _amountIn);\r\n\r\n        router.swapExactTokensForTokens(_amountIn, _amountOutMin, _path, DEAD_ADR, _deadline);\r\n    }\r\n\r\n    /// @inheritdoc IAutoSwapper\r\n    function transferTokens() public returns (uint256 _amount) {\r\n        _amount = smardexToken.balanceOf(address(this));\r\n        if (_amount != 0) {\r\n            smardexToken.safeTransfer(DEAD_ADR, _amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice private function to swap token in SDEX and burn it\r\n     * @param _token address of the token to swap into sdex\r\n     * @return amount of input tokens swapped\r\n     */\r\n    function _swapAndSend(IERC20 _token) private returns (uint256) {\r\n        if (_token == smardexToken) {\r\n            return 0;\r\n        }\r\n        SwapCallParams memory _params = SwapCallParams({\r\n            zeroForOne: _token < smardexToken,\r\n            balanceIn: _token.balanceOf(address(this)),\r\n            pair: ISmardexPair(factory.getPair(address(_token), address(smardexToken))),\r\n            fictiveReserve0: 0,\r\n            fictiveReserve1: 0,\r\n            oldPriceAv0: 0,\r\n            oldPriceAv1: 0,\r\n            oldPriceAvTimestamp: 0,\r\n            newPriceAvIn: 0,\r\n            newPriceAvOut: 0\r\n        });\r\n\r\n        // basic check on input data\r\n        if (_params.balanceIn == 0 || address(_params.pair) == address(0)) {\r\n            return 0;\r\n        }\r\n\r\n        // get reserves and pricesAv\r\n        (_params.fictiveReserve0, _params.fictiveReserve1) = _params.pair.getFictiveReserves();\r\n        (_params.oldPriceAv0, _params.oldPriceAv1, _params.oldPriceAvTimestamp) = _params.pair.getPriceAverage();\r\n\r\n        if (_params.oldPriceAv0 == 0 || _params.oldPriceAv1 == 0) {\r\n            (_params.oldPriceAv0, _params.oldPriceAv1) = (_params.fictiveReserve0, _params.fictiveReserve1);\r\n        }\r\n\r\n        if (_params.zeroForOne) {\r\n            (_params.newPriceAvIn, _params.newPriceAvOut) = SmardexLibrary.getUpdatedPriceAverage(\r\n                _params.fictiveReserve0,\r\n                _params.fictiveReserve1,\r\n                _params.oldPriceAvTimestamp,\r\n                _params.oldPriceAv0,\r\n                _params.oldPriceAv1,\r\n                block.timestamp\r\n            );\r\n        } else {\r\n            (_params.newPriceAvIn, _params.newPriceAvOut) = SmardexLibrary.getUpdatedPriceAverage(\r\n                _params.fictiveReserve1,\r\n                _params.fictiveReserve0,\r\n                _params.oldPriceAvTimestamp,\r\n                _params.oldPriceAv1,\r\n                _params.oldPriceAv0,\r\n                block.timestamp\r\n            );\r\n        }\r\n\r\n        // we allow for 2% slippage from previous swaps in block\r\n        uint256 _amountOutWithSlippage = (_params.balanceIn *\r\n            _params.newPriceAvOut *\r\n            (AUTOSWAP_SLIPPAGE_BASE - AUTOSWAP_SLIPPAGE)) / (_params.newPriceAvIn * AUTOSWAP_SLIPPAGE_BASE);\r\n        require(_amountOutWithSlippage != 0, \"AutoSwapper: slippage calculation failed\");\r\n\r\n        cachedPair = _params.pair;\r\n\r\n        // we dont check for success as we dont want to revert the whole tx if the swap fails\r\n        (bool success, ) = address(_params.pair).call(\r\n            abi.encodeWithSelector(\r\n                SWAP_SELECTOR,\r\n                DEAD_ADR,\r\n                _token < smardexToken,\r\n                _params.balanceIn.toInt256(),\r\n                abi.encode(\r\n                    SwapCallbackData({ path: abi.encodePacked(_token, smardexToken), payer: address(this) }),\r\n                    _amountOutWithSlippage\r\n                )\r\n            )\r\n        );\r\n\r\n        cachedPair = DEFAULT_CACHED_PAIR;\r\n\r\n        return success ? _params.balanceIn : 0;\r\n    }\r\n\r\n    /// @inheritdoc ISmardexSwapCallback\r\n    function smardexSwapCallback(int256 _amount0Delta, int256 _amount1Delta, bytes calldata _dataFromPair) external {\r\n        require(_amount0Delta > 0 || _amount1Delta > 0, \"SmardexRouter: Callback Invalid amount\");\r\n        (SwapCallbackData memory _data, uint256 _amountOutWithSlippage) = abi.decode(\r\n            _dataFromPair,\r\n            (SwapCallbackData, uint256)\r\n        );\r\n        (address _tokenIn, ) = _data.path.decodeFirstPool();\r\n        require(msg.sender == address(cachedPair), \"SmarDexRouter: INVALID_PAIR\"); // ensure that msg.sender is a pair\r\n        // ensure that the trade gives at least the minimum amount of output token (negative delta)\r\n        require(\r\n            (_amount0Delta < 0 ? uint256(-_amount0Delta) : (-_amount1Delta).toUint256()) >= _amountOutWithSlippage,\r\n            \"SmardexAutoSwapper: Invalid price\"\r\n        );\r\n        // send positive delta to pair\r\n        IERC20(_tokenIn).safeTransfer(\r\n            msg.sender,\r\n            _amount0Delta > 0 ? uint256(_amount0Delta) : _amount1Delta.toUint256()\r\n        );\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/FarmingRange.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n// contracts\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\n// libraries\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n// interfaces\r\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\r\nimport \"./interfaces/IFarmingRange.sol\";\r\n\r\n/**\r\n * @title FarmingRange\r\n * @notice Farming Range allows users to stake LP Tokens to receive various rewards\r\n * @custom:from Contract taken from the alpaca protocol, adapted to version 0.8.17 and modified with more functions\r\n * @custom:url https://github.com/alpaca-finance/bsc-alpaca-contract/blob/main/solidity/contracts/6.12/GrazingRange.sol\r\n */\r\ncontract FarmingRange is IFarmingRange, Ownable, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n\r\n    mapping(uint256 => RewardInfo[]) public campaignRewardInfo;\r\n\r\n    CampaignInfo[] public campaignInfo;\r\n    mapping(uint256 => mapping(address => UserInfo)) public userInfo;\r\n\r\n    uint256 public rewardInfoLimit;\r\n    address public immutable rewardManager;\r\n\r\n    constructor(address _rewardManager) {\r\n        rewardInfoLimit = 52;\r\n        require(_rewardManager != address(0), \"FarmingRange::constructor::Reward manager is not defined\");\r\n        rewardManager = _rewardManager;\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function setRewardInfoLimit(uint256 _updatedRewardInfoLimit) external onlyOwner {\r\n        rewardInfoLimit = _updatedRewardInfoLimit;\r\n        emit SetRewardInfoLimit(rewardInfoLimit);\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function addCampaignInfo(\r\n        IERC20 _stakingToken,\r\n        IERC20 _rewardToken,\r\n        uint256 _startBlock\r\n    ) external virtual onlyOwner {\r\n        require(_startBlock > block.number, \"FarmingRange::addCampaignInfo::Start block should be in the future\");\r\n        campaignInfo.push(\r\n            CampaignInfo({\r\n                stakingToken: _stakingToken,\r\n                rewardToken: _rewardToken,\r\n                startBlock: _startBlock,\r\n                lastRewardBlock: _startBlock,\r\n                accRewardPerShare: 0,\r\n                totalStaked: 0,\r\n                totalRewards: 0\r\n            })\r\n        );\r\n        emit AddCampaignInfo(campaignInfo.length - 1, _stakingToken, _rewardToken, _startBlock);\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function addRewardInfo(\r\n        uint256 _campaignID,\r\n        uint256 _endBlock,\r\n        uint256 _rewardPerBlock\r\n    ) public virtual onlyOwner nonReentrant {\r\n        RewardInfo[] storage rewardInfo = campaignRewardInfo[_campaignID];\r\n        CampaignInfo storage campaign = campaignInfo[_campaignID];\r\n        require(\r\n            rewardInfo.length < rewardInfoLimit,\r\n            \"FarmingRange::addRewardInfo::reward info length exceeds the limit\"\r\n        );\r\n\r\n        // assign last reward block by default\r\n        uint256 _startBlock = campaignInfo[_campaignID].lastRewardBlock;\r\n\r\n        uint256 _currentCampaignEnd = rewardInfo.length == 0\r\n            ? campaign.startBlock\r\n            : rewardInfo[rewardInfo.length - 1].endBlock;\r\n\r\n        if (_currentCampaignEnd < block.number) {\r\n            require(_rewardPerBlock == 0, \"FarmingRange::addRewardInfo::reward period ended\");\r\n        }\r\n\r\n        // assign largest between endblock and lastRewardBlock\r\n        if (_startBlock < _currentCampaignEnd) {\r\n            _startBlock = _currentCampaignEnd;\r\n        }\r\n\r\n        require(_currentCampaignEnd < _endBlock, \"FarmingRange::addRewardInfo::bad new endblock\");\r\n\r\n        uint256 _blockRange = _endBlock - _startBlock;\r\n        uint256 _totalRewards = _rewardPerBlock * _blockRange;\r\n        campaign.totalRewards = campaign.totalRewards + _totalRewards;\r\n        rewardInfo.push(RewardInfo({ endBlock: _endBlock, rewardPerBlock: _rewardPerBlock }));\r\n        _transferFromWithAllowance(campaign.rewardToken, _totalRewards, _campaignID);\r\n        emit AddRewardInfo(_campaignID, rewardInfo.length - 1, _endBlock, _rewardPerBlock);\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function addRewardInfoMultiple(\r\n        uint256 _campaignID,\r\n        uint256[] calldata _endBlock,\r\n        uint256[] calldata _rewardPerBlock\r\n    ) external onlyOwner {\r\n        require(_endBlock.length == _rewardPerBlock.length, \"FarmingRange::addRewardMultiple::wrong parameters length\");\r\n        for (uint256 _i; _i != _endBlock.length; ) {\r\n            addRewardInfo(_campaignID, _endBlock[_i], _rewardPerBlock[_i]);\r\n            unchecked {\r\n                ++_i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function updateRewardInfo(\r\n        uint256 _campaignID,\r\n        uint256 _rewardIndex,\r\n        uint256 _endBlock,\r\n        uint256 _rewardPerBlock\r\n    ) public virtual onlyOwner nonReentrant {\r\n        RewardInfo[] storage rewardInfo = campaignRewardInfo[_campaignID];\r\n        CampaignInfo storage campaign = campaignInfo[_campaignID];\r\n        RewardInfo storage selectedRewardInfo = rewardInfo[_rewardIndex];\r\n        uint256 _previousEndBlock = selectedRewardInfo.endBlock;\r\n        _updateCampaign(_campaignID);\r\n        require(_previousEndBlock >= block.number, \"FarmingRange::updateRewardInfo::reward period ended\");\r\n        if (_rewardIndex != 0) {\r\n            require(\r\n                rewardInfo[_rewardIndex - 1].endBlock < _endBlock,\r\n                \"FarmingRange::updateRewardInfo::bad new endblock\"\r\n            );\r\n        }\r\n        if (rewardInfo.length > _rewardIndex + 1) {\r\n            require(\r\n                _endBlock < rewardInfo[_rewardIndex + 1].endBlock,\r\n                \"FarmingRange::updateRewardInfo::reward period end is in next range\"\r\n            );\r\n        }\r\n        (bool _refund, uint256 _diff) = _updateRewardsDiff(\r\n            _rewardIndex,\r\n            _endBlock,\r\n            _rewardPerBlock,\r\n            rewardInfo,\r\n            campaign,\r\n            selectedRewardInfo\r\n        );\r\n        if (!_refund && _diff != 0) {\r\n            _transferFromWithAllowance(campaign.rewardToken, _diff, _campaignID);\r\n        }\r\n        // If _endblock is changed, and if we have another range after the updated one,\r\n        // we need to update rewardPerBlock to distribute on the next new range or we could run out of tokens\r\n        if (_endBlock != _previousEndBlock && rewardInfo.length - 1 > _rewardIndex) {\r\n            RewardInfo storage nextRewardInfo = rewardInfo[_rewardIndex + 1];\r\n            uint256 _nextRewardInfoEndBlock = nextRewardInfo.endBlock;\r\n            uint256 _initialBlockRange = _nextRewardInfoEndBlock - _previousEndBlock;\r\n            uint256 _nextBlockRange = _nextRewardInfoEndBlock - _endBlock;\r\n            uint256 _currentRewardPerBlock = nextRewardInfo.rewardPerBlock;\r\n            uint256 _initialNextTotal = _initialBlockRange * _currentRewardPerBlock;\r\n            _currentRewardPerBlock = (_currentRewardPerBlock * _initialBlockRange) / _nextBlockRange;\r\n            uint256 _nextTotal = _nextBlockRange * _currentRewardPerBlock;\r\n            nextRewardInfo.rewardPerBlock = _currentRewardPerBlock;\r\n            if (_nextTotal < _initialNextTotal) {\r\n                campaign.rewardToken.safeTransfer(rewardManager, _initialNextTotal - _nextTotal);\r\n                campaign.totalRewards -= _initialNextTotal - _nextTotal;\r\n            }\r\n        }\r\n        // UPDATE total\r\n        campaign.totalRewards = _refund ? campaign.totalRewards - _diff : campaign.totalRewards + _diff;\r\n        selectedRewardInfo.endBlock = _endBlock;\r\n        selectedRewardInfo.rewardPerBlock = _rewardPerBlock;\r\n        emit UpdateRewardInfo(_campaignID, _rewardIndex, _endBlock, _rewardPerBlock);\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function updateRewardMultiple(\r\n        uint256 _campaignID,\r\n        uint256[] memory _rewardIndex,\r\n        uint256[] memory _endBlock,\r\n        uint256[] memory _rewardPerBlock\r\n    ) public onlyOwner {\r\n        require(\r\n            _rewardIndex.length == _endBlock.length && _rewardIndex.length == _rewardPerBlock.length,\r\n            \"FarmingRange::updateRewardMultiple::wrong parameters length\"\r\n        );\r\n        for (uint256 _i; _i != _rewardIndex.length; ) {\r\n            updateRewardInfo(_campaignID, _rewardIndex[_i], _endBlock[_i], _rewardPerBlock[_i]);\r\n            unchecked {\r\n                ++_i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function updateCampaignsRewards(\r\n        uint256[] calldata _campaignID,\r\n        uint256[][] calldata _rewardIndex,\r\n        uint256[][] calldata _endBlock,\r\n        uint256[][] calldata _rewardPerBlock\r\n    ) external onlyOwner {\r\n        require(\r\n            _campaignID.length == _rewardIndex.length &&\r\n                _rewardIndex.length == _endBlock.length &&\r\n                _rewardIndex.length == _rewardPerBlock.length,\r\n            \"FarmingRange::updateCampaignsRewards::wrong rewardInfo length\"\r\n        );\r\n        for (uint256 _i; _i != _campaignID.length; ) {\r\n            updateRewardMultiple(_campaignID[_i], _rewardIndex[_i], _endBlock[_i], _rewardPerBlock[_i]);\r\n            unchecked {\r\n                ++_i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function removeLastRewardInfo(uint256 _campaignID) public virtual onlyOwner {\r\n        RewardInfo[] storage rewardInfo = campaignRewardInfo[_campaignID];\r\n        CampaignInfo storage campaign = campaignInfo[_campaignID];\r\n        uint256 _rewardInfoLength = rewardInfo.length;\r\n        require(_rewardInfoLength != 0, \"FarmingRange::updateCampaignsRewards::no rewardInfoLen\");\r\n        RewardInfo storage lastRewardInfo = rewardInfo[_rewardInfoLength - 1];\r\n        uint256 _lastRewardInfoEndBlock = lastRewardInfo.endBlock;\r\n        require(_lastRewardInfoEndBlock > block.number, \"FarmingRange::removeLastRewardInfo::reward period ended\");\r\n        _updateCampaign(_campaignID);\r\n        if (lastRewardInfo.rewardPerBlock != 0) {\r\n            (bool _refund, uint256 _diff) = _updateRewardsDiff(\r\n                _rewardInfoLength - 1,\r\n                _lastRewardInfoEndBlock,\r\n                0,\r\n                rewardInfo,\r\n                campaign,\r\n                lastRewardInfo\r\n            );\r\n            if (_refund) {\r\n                campaign.totalRewards = campaign.totalRewards - _diff;\r\n            }\r\n        }\r\n        rewardInfo.pop();\r\n        emit RemoveRewardInfo(_campaignID, _rewardInfoLength - 1);\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function removeLastRewardInfoMultiple(uint256 _campaignID, uint256 _number) external virtual onlyOwner {\r\n        require(_number > 0, \"FarmingRange::removeLastRewardInfoMultiple::number should be > 0\");\r\n        for (uint256 _i; _i != _number; ) {\r\n            removeLastRewardInfo(_campaignID);\r\n            unchecked {\r\n                ++_i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function rewardInfoLen(uint256 _campaignID) external view returns (uint256) {\r\n        return campaignRewardInfo[_campaignID].length;\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function campaignInfoLen() external view returns (uint256) {\r\n        return campaignInfo.length;\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function currentEndBlock(uint256 _campaignID) external view virtual returns (uint256) {\r\n        return _endBlockOf(_campaignID, block.number);\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function currentRewardPerBlock(uint256 _campaignID) external view virtual returns (uint256) {\r\n        return _rewardPerBlockOf(_campaignID, block.number);\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function getMultiplier(uint256 _from, uint256 _to, uint256 _endBlock) public pure returns (uint256) {\r\n        if ((_from >= _endBlock) || (_from > _to)) {\r\n            return 0;\r\n        }\r\n        if (_to <= _endBlock) {\r\n            return _to - _from;\r\n        }\r\n        return _endBlock - _from;\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function pendingReward(uint256 _campaignID, address _user) external view returns (uint256) {\r\n        return\r\n            _pendingReward(_campaignID, userInfo[_campaignID][_user].amount, userInfo[_campaignID][_user].rewardDebt);\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function updateCampaign(uint256 _campaignID) external nonReentrant {\r\n        _updateCampaign(_campaignID);\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function massUpdateCampaigns() external nonReentrant {\r\n        uint256 _length = campaignInfo.length;\r\n        for (uint256 _i; _i != _length; ) {\r\n            _updateCampaign(_i);\r\n            unchecked {\r\n                ++_i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function deposit(uint256 _campaignID, uint256 _amount, address _for) public nonReentrant {\r\n        require(_for != address(0), \"FarmingRange::deposit::bad _for\");\r\n        CampaignInfo storage campaign = campaignInfo[_campaignID];\r\n        UserInfo storage user = userInfo[_campaignID][_for];\r\n        _updateCampaign(_campaignID);\r\n        if (user.amount != 0) {\r\n            uint256 _pending = (user.amount * campaign.accRewardPerShare) / 1e20 - user.rewardDebt;\r\n            if (_pending != 0) {\r\n                campaign.rewardToken.safeTransfer(_for, _pending);\r\n            }\r\n        }\r\n        if (_amount != 0) {\r\n            user.amount = user.amount + _amount;\r\n            campaign.totalStaked = campaign.totalStaked + _amount;\r\n            campaign.stakingToken.safeTransferFrom(msg.sender, address(this), _amount);\r\n        }\r\n        user.rewardDebt = (user.amount * campaign.accRewardPerShare) / (1e20);\r\n        emit Deposit(_for, _amount, _campaignID);\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function depositWithPermit(\r\n        uint256 _campaignID,\r\n        uint256 _amount,\r\n        bool _approveMax,\r\n        uint256 _deadline,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external {\r\n        SafeERC20.safePermit(\r\n            IERC20Permit(address(campaignInfo[_campaignID].stakingToken)),\r\n            msg.sender,\r\n            address(this),\r\n            _approveMax ? type(uint256).max : _amount,\r\n            _deadline,\r\n            _v,\r\n            _r,\r\n            _s\r\n        );\r\n\r\n        deposit(_campaignID, _amount, msg.sender);\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function withdraw(\r\n        uint256 _campaignID,\r\n        uint256 _amount,\r\n        address _rewardTo,\r\n        address _stakingTo\r\n    ) external nonReentrant {\r\n        _withdraw(_campaignID, _amount, _rewardTo, _stakingTo);\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function harvest(uint256[] calldata _campaignIDs, address _rewardTo) external nonReentrant {\r\n        for (uint256 _i; _i != _campaignIDs.length; ) {\r\n            _withdraw(_campaignIDs[_i], 0, _rewardTo, _rewardTo);\r\n            unchecked {\r\n                ++_i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRange\r\n    function emergencyWithdraw(uint256 _campaignID) external nonReentrant {\r\n        CampaignInfo storage campaign = campaignInfo[_campaignID];\r\n        UserInfo storage user = userInfo[_campaignID][msg.sender];\r\n        uint256 _amount = user.amount;\r\n        campaign.totalStaked = campaign.totalStaked - _amount;\r\n        user.amount = 0;\r\n        user.rewardDebt = 0;\r\n        campaign.stakingToken.safeTransfer(msg.sender, _amount);\r\n        emit EmergencyWithdraw(msg.sender, _amount, _campaignID);\r\n    }\r\n\r\n    /**\r\n     * @notice function to trick the compilator to use safeTransferFrom in try catch\r\n     * @param _token token to interact with\r\n     * @param _from address who own token\r\n     * @param _to address to transfer token\r\n     * @param _amount quantity to be transferred\r\n     */\r\n    function attemptTransfer(IERC20 _token, address _from, address _to, uint256 _amount) external {\r\n        require(msg.sender == address(this), \"FarmingRange::attemptTransfer::Sender not farming\"); // this function should be called only by this contract\r\n        _token.safeTransferFrom(_from, _to, _amount);\r\n    }\r\n\r\n    /**\r\n     * @notice return the endblock of the phase that contains _blockNumber\r\n     * @param _campaignID the campaign id of the phases to check\r\n     * @param _blockNumber the block number to check\r\n     * @return the endblock of the phase that contains _blockNumber\r\n     */\r\n    function _endBlockOf(uint256 _campaignID, uint256 _blockNumber) internal view returns (uint256) {\r\n        RewardInfo[] memory rewardInfo = campaignRewardInfo[_campaignID];\r\n        uint256 _len = rewardInfo.length;\r\n        if (_len == 0) {\r\n            return 0;\r\n        }\r\n        for (uint256 _i; _i != _len; ) {\r\n            if (_blockNumber <= rewardInfo[_i].endBlock) {\r\n                return rewardInfo[_i].endBlock;\r\n            }\r\n            unchecked {\r\n                ++_i;\r\n            }\r\n        }\r\n        /// @dev when couldn't find any reward info, it means that _blockNumber exceed endblock\r\n        /// so return the latest reward info.\r\n        return rewardInfo[_len - 1].endBlock;\r\n    }\r\n\r\n    /**\r\n     * @notice return the rewardPerBlock of the phase that contains _blockNumber\r\n     * @param _campaignID the campaign id of the phases to check\r\n     * @param _blockNumber the block number to check\r\n     * @return the rewardPerBlock of the phase that contains _blockNumber\r\n     */\r\n    function _rewardPerBlockOf(uint256 _campaignID, uint256 _blockNumber) internal view returns (uint256) {\r\n        RewardInfo[] memory rewardInfo = campaignRewardInfo[_campaignID];\r\n        uint256 _len = rewardInfo.length;\r\n        if (_len == 0) {\r\n            return 0;\r\n        }\r\n        for (uint256 _i; _i != _len; ) {\r\n            if (_blockNumber <= rewardInfo[_i].endBlock) {\r\n                return rewardInfo[_i].rewardPerBlock;\r\n            }\r\n            unchecked {\r\n                ++_i;\r\n            }\r\n        }\r\n        /// @dev when couldn't find any reward info, it means that timestamp exceed endblock\r\n        /// so return 0\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * @notice in case of reward update, return reward diff and refund user if needed\r\n     * @param _rewardIndex the number of the phase to update\r\n     * @param _endBlock new endblock of the phase\r\n     * @param _rewardPerBlock new rewardPerBlock of the phase\r\n     * @param rewardInfo pointer on the array of rewardInfo in storage\r\n     * @param campaign pointer on the campaign in storage\r\n     * @param selectedRewardInfo pointer on the selectedRewardInfo in storage\r\n     * @return refund_ boolean, true if user got refund\r\n     * @return diff_ the reward difference\r\n     */\r\n    function _updateRewardsDiff(\r\n        uint256 _rewardIndex,\r\n        uint256 _endBlock,\r\n        uint256 _rewardPerBlock,\r\n        RewardInfo[] storage rewardInfo,\r\n        CampaignInfo storage campaign,\r\n        RewardInfo storage selectedRewardInfo\r\n    ) internal virtual returns (bool refund_, uint256 diff_) {\r\n        uint256 _previousStartBlock = _rewardIndex == 0 ? campaign.startBlock : rewardInfo[_rewardIndex - 1].endBlock;\r\n        uint256 _newStartBlock = block.number > _previousStartBlock ? block.number : _previousStartBlock;\r\n        uint256 _previousBlockRange = selectedRewardInfo.endBlock - _previousStartBlock;\r\n        uint256 _newBlockRange = _endBlock - _newStartBlock;\r\n        uint256 _selectedRewardPerBlock = selectedRewardInfo.rewardPerBlock;\r\n        uint256 _accumulatedRewards = (_newStartBlock - _previousStartBlock) * _selectedRewardPerBlock;\r\n        uint256 _previousTotalRewards = _selectedRewardPerBlock * _previousBlockRange;\r\n        uint256 _totalRewards = _rewardPerBlock * _newBlockRange;\r\n        refund_ = _previousTotalRewards > _totalRewards + _accumulatedRewards;\r\n        diff_ = refund_\r\n            ? _previousTotalRewards - _totalRewards - _accumulatedRewards\r\n            : _totalRewards + _accumulatedRewards - _previousTotalRewards;\r\n        if (refund_) {\r\n            campaign.rewardToken.safeTransfer(rewardManager, diff_);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice transfer tokens from rewardManger to this contract.\r\n     * @param _rewardToken to reward token to be transferred from the rewardManager to this contract\r\n     * @param _amount qty to be transferred\r\n     * @param _campaignID id of the campaign so the rewardManager can fetch the rewardToken address to transfer\r\n     *\r\n     * @dev in case of fail, not enough allowance is considered to be the reason, so we call resetAllowance(uint256) on\r\n     * the reward manager (which will reset allowance to uint256.max) and we try again to transfer\r\n     */\r\n    function _transferFromWithAllowance(IERC20 _rewardToken, uint256 _amount, uint256 _campaignID) internal {\r\n        try this.attemptTransfer(_rewardToken, rewardManager, address(this), _amount) {} catch {\r\n            rewardManager.call(abi.encodeWithSignature(\"resetAllowance(uint256)\", _campaignID));\r\n            _rewardToken.safeTransferFrom(rewardManager, address(this), _amount);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice View function to retrieve pending Reward.\r\n     * @param _campaignID pending reward of campaign id\r\n     * @param _amount qty of staked token\r\n     * @param _rewardDebt user info rewardDebt\r\n     * @return pending rewards\r\n     */\r\n    function _pendingReward(\r\n        uint256 _campaignID,\r\n        uint256 _amount,\r\n        uint256 _rewardDebt\r\n    ) internal view virtual returns (uint256) {\r\n        CampaignInfo memory _campaign = campaignInfo[_campaignID];\r\n        RewardInfo[] memory _rewardInfo = campaignRewardInfo[_campaignID];\r\n        uint256 _accRewardPerShare = _campaign.accRewardPerShare;\r\n\r\n        if (block.number > _campaign.lastRewardBlock && _campaign.totalStaked != 0) {\r\n            uint256 _cursor = _campaign.lastRewardBlock;\r\n            for (uint256 _i; _i != _rewardInfo.length; ) {\r\n                uint256 _multiplier = getMultiplier(_cursor, block.number, _rewardInfo[_i].endBlock);\r\n                if (_multiplier != 0) {\r\n                    _cursor = _rewardInfo[_i].endBlock;\r\n                    _accRewardPerShare =\r\n                        _accRewardPerShare +\r\n                        ((_multiplier * _rewardInfo[_i].rewardPerBlock * 1e20) / _campaign.totalStaked);\r\n                }\r\n                unchecked {\r\n                    ++_i;\r\n                }\r\n            }\r\n        }\r\n        return ((_amount * _accRewardPerShare) / 1e20) - _rewardDebt;\r\n    }\r\n\r\n    /**\r\n     * @notice Update reward variables of the given campaign to be up-to-date.\r\n     *         NOTE: All rewards relating to periods devoid of any depositors are sent back to the reward manager.\r\n     * @param _campaignID campaign id\r\n     */\r\n    function _updateCampaign(uint256 _campaignID) internal virtual {\r\n        require(campaignInfo.length > _campaignID, \"FarmingRange::_updateCampaign::Campaign id not valid\");\r\n        CampaignInfo storage campaign = campaignInfo[_campaignID];\r\n        RewardInfo[] memory _rewardInfo = campaignRewardInfo[_campaignID];\r\n        if (block.number <= campaign.lastRewardBlock) {\r\n            return;\r\n        }\r\n        if (campaign.totalStaked == 0) {\r\n            uint256 _amount;\r\n            for (uint256 _i; _i != _rewardInfo.length; ) {\r\n                if (_rewardInfo[_i].endBlock >= campaign.lastRewardBlock) {\r\n                    uint256 _startBlock = _i != 0 ? _rewardInfo[_i - 1].endBlock : campaign.lastRewardBlock;\r\n                    bool _lastRewardInfo = _rewardInfo[_i].endBlock > block.number;\r\n                    uint256 _blockRange = (_lastRewardInfo ? block.number : _rewardInfo[_i].endBlock) -\r\n                        (_startBlock > campaign.lastRewardBlock ? _startBlock : campaign.lastRewardBlock);\r\n                    _amount += _rewardInfo[_i].rewardPerBlock * _blockRange;\r\n                    if (_lastRewardInfo) {\r\n                        break;\r\n                    }\r\n                }\r\n                unchecked {\r\n                    ++_i;\r\n                }\r\n            }\r\n\r\n            if (_amount != 0) {\r\n                campaign.rewardToken.safeTransfer(rewardManager, _amount);\r\n            }\r\n\r\n            campaign.lastRewardBlock = block.number;\r\n\r\n            return;\r\n        }\r\n        /// @dev for each reward info\r\n        for (uint256 _i; _i != _rewardInfo.length; ) {\r\n            // @dev get multiplier based on current Block and rewardInfo's end block\r\n            // multiplier will be a range of either (current block - campaign.lastRewardBlock)\r\n            // or (reward info's endblock - campaign.lastRewardBlock) or 0\r\n            uint256 _multiplier = getMultiplier(campaign.lastRewardBlock, block.number, _rewardInfo[_i].endBlock);\r\n            if (_multiplier != 0) {\r\n                // @dev if currentBlock exceed end block, use end block as the last reward block\r\n                // so that for the next iteration, previous endBlock will be used as the last reward block\r\n                if (block.number > _rewardInfo[_i].endBlock) {\r\n                    campaign.lastRewardBlock = _rewardInfo[_i].endBlock;\r\n                } else {\r\n                    campaign.lastRewardBlock = block.number;\r\n                }\r\n                campaign.accRewardPerShare =\r\n                    campaign.accRewardPerShare +\r\n                    ((_multiplier * _rewardInfo[_i].rewardPerBlock * 1e20) / campaign.totalStaked);\r\n            }\r\n            unchecked {\r\n                ++_i;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @notice Withdraw staking token in a campaign. Also withdraw the current pending reward\r\n     * @param _campaignID campaign id\r\n     * @param _amount amount to withdraw\r\n     * @param _rewardTo address to which the reward tokens will be sent\r\n     * @param _stakingTo address to which the staking tokens will be sent\r\n     */\r\n    function _withdraw(uint256 _campaignID, uint256 _amount, address _rewardTo, address _stakingTo) internal {\r\n        require(_rewardTo != address(0), \"FarmingRange::withdraw::bad _rewardTo\");\r\n        require(_stakingTo != address(0), \"FarmingRange::withdraw::bad _stakingTo\");\r\n        CampaignInfo storage campaign = campaignInfo[_campaignID];\r\n        UserInfo storage user = userInfo[_campaignID][msg.sender];\r\n        require(user.amount >= _amount, \"FarmingRange::withdraw::bad withdraw amount\");\r\n        _updateCampaign(_campaignID);\r\n        uint256 _pending = (user.amount * campaign.accRewardPerShare) / 1e20 - user.rewardDebt;\r\n        if (_pending != 0) {\r\n            campaign.rewardToken.safeTransfer(_rewardTo, _pending);\r\n        }\r\n        if (_amount != 0) {\r\n            user.amount = user.amount - _amount;\r\n            campaign.totalStaked = campaign.totalStaked - _amount;\r\n            campaign.stakingToken.safeTransfer(_stakingTo, _amount);\r\n        }\r\n        user.rewardDebt = (user.amount * campaign.accRewardPerShare) / 1e20;\r\n\r\n        emit Withdraw(_rewardTo, _stakingTo, _amount, _campaignID);\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/FarmingRangeL2Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n// contracts\r\nimport \"./FarmingRange.sol\";\r\n\r\n// interfaces\r\nimport \"./interfaces/IFarmingRangeL2Arbitrum.sol\";\r\nimport \"./interfaces/IArbSys.sol\";\r\n\r\n/**\r\n * @title FarmingRangeArbitrum\r\n * @notice Farming Range allows users to stake LP Tokens to receive various rewards on Arbitrum\r\n * @custom:from Contract taken from the alpaca protocol, adapted to version 0.8.17 and modified with more functions\r\n * @custom:url https://github.com/alpaca-finance/bsc-alpaca-contract/blob/main/solidity/contracts/6.12/GrazingRange.sol\r\n */\r\ncontract FarmingRangeL2Arbitrum is FarmingRange, IFarmingRangeArbitrum {\r\n    using SafeERC20 for IERC20;\r\n\r\n    constructor(address _rewardManager) FarmingRange(_rewardManager) {}\r\n\r\n    /// @inheritdoc FarmingRange\r\n    function addCampaignInfo(\r\n        IERC20 _stakingToken,\r\n        IERC20 _rewardToken,\r\n        uint256 _startBlock\r\n    ) external override onlyOwner {\r\n        require(\r\n            _startBlock > arbitrumBlockNumber(),\r\n            \"FarmingRange::addCampaignInfo::Start block should be in the future\"\r\n        );\r\n        campaignInfo.push(\r\n            CampaignInfo({\r\n                stakingToken: _stakingToken,\r\n                rewardToken: _rewardToken,\r\n                startBlock: _startBlock,\r\n                lastRewardBlock: _startBlock,\r\n                accRewardPerShare: 0,\r\n                totalStaked: 0,\r\n                totalRewards: 0\r\n            })\r\n        );\r\n        emit AddCampaignInfo(campaignInfo.length - 1, _stakingToken, _rewardToken, _startBlock);\r\n    }\r\n\r\n    /// @inheritdoc FarmingRange\r\n    function addRewardInfo(\r\n        uint256 _campaignID,\r\n        uint256 _endBlock,\r\n        uint256 _rewardPerBlock\r\n    ) public override onlyOwner nonReentrant {\r\n        RewardInfo[] storage rewardInfo = campaignRewardInfo[_campaignID];\r\n        CampaignInfo storage campaign = campaignInfo[_campaignID];\r\n        require(\r\n            rewardInfo.length < rewardInfoLimit,\r\n            \"FarmingRange::addRewardInfo::reward info length exceeds the limit\"\r\n        );\r\n\r\n        // assign last reward block by default\r\n        uint256 _startBlock = campaignInfo[_campaignID].lastRewardBlock;\r\n\r\n        uint256 _currentCampaignEnd = rewardInfo.length == 0\r\n            ? campaign.startBlock\r\n            : rewardInfo[rewardInfo.length - 1].endBlock;\r\n\r\n        if (_currentCampaignEnd < arbitrumBlockNumber()) {\r\n            require(_rewardPerBlock == 0, \"FarmingRange::addRewardInfo::reward period ended\");\r\n        }\r\n\r\n        // assign largest between endblock and lastRewardBlock\r\n        if (_startBlock < _currentCampaignEnd) {\r\n            _startBlock = _currentCampaignEnd;\r\n        }\r\n\r\n        require(_currentCampaignEnd < _endBlock, \"FarmingRange::addRewardInfo::bad new endblock\");\r\n\r\n        uint256 _blockRange = _endBlock - _startBlock;\r\n        uint256 _totalRewards = _rewardPerBlock * _blockRange;\r\n        campaign.totalRewards = campaign.totalRewards + _totalRewards;\r\n        rewardInfo.push(RewardInfo({ endBlock: _endBlock, rewardPerBlock: _rewardPerBlock }));\r\n        _transferFromWithAllowance(campaign.rewardToken, _totalRewards, _campaignID);\r\n        emit AddRewardInfo(_campaignID, rewardInfo.length - 1, _endBlock, _rewardPerBlock);\r\n    }\r\n\r\n    /// @inheritdoc FarmingRange\r\n    function updateRewardInfo(\r\n        uint256 _campaignID,\r\n        uint256 _rewardIndex,\r\n        uint256 _endBlock,\r\n        uint256 _rewardPerBlock\r\n    ) public override onlyOwner nonReentrant {\r\n        RewardInfo[] storage rewardInfo = campaignRewardInfo[_campaignID];\r\n        CampaignInfo storage campaign = campaignInfo[_campaignID];\r\n        RewardInfo storage selectedRewardInfo = rewardInfo[_rewardIndex];\r\n        uint256 _previousEndBlock = selectedRewardInfo.endBlock;\r\n        _updateCampaign(_campaignID);\r\n        require(_previousEndBlock >= arbitrumBlockNumber(), \"FarmingRange::updateRewardInfo::reward period ended\");\r\n        if (_rewardIndex != 0) {\r\n            require(\r\n                rewardInfo[_rewardIndex - 1].endBlock < _endBlock,\r\n                \"FarmingRange::updateRewardInfo::bad new endblock\"\r\n            );\r\n        }\r\n        if (rewardInfo.length > _rewardIndex + 1) {\r\n            require(\r\n                _endBlock < rewardInfo[_rewardIndex + 1].endBlock,\r\n                \"FarmingRange::updateRewardInfo::reward period end is in next range\"\r\n            );\r\n        }\r\n        (bool _refund, uint256 _diff) = _updateRewardsDiff(\r\n            _rewardIndex,\r\n            _endBlock,\r\n            _rewardPerBlock,\r\n            rewardInfo,\r\n            campaign,\r\n            selectedRewardInfo\r\n        );\r\n        if (!_refund && _diff != 0) {\r\n            _transferFromWithAllowance(campaign.rewardToken, _diff, _campaignID);\r\n        }\r\n        // If _endblock is changed, and if we have another range after the updated one,\r\n        // we need to update rewardPerBlock to distribute on the next new range or we could run out of tokens\r\n        if (_endBlock != _previousEndBlock && rewardInfo.length - 1 > _rewardIndex) {\r\n            RewardInfo storage nextRewardInfo = rewardInfo[_rewardIndex + 1];\r\n            uint256 _nextRewardInfoEndBlock = nextRewardInfo.endBlock;\r\n            uint256 _initialBlockRange = _nextRewardInfoEndBlock - _previousEndBlock;\r\n            uint256 _nextBlockRange = _nextRewardInfoEndBlock - _endBlock;\r\n            uint256 _currentRewardPerBlock = nextRewardInfo.rewardPerBlock;\r\n            uint256 _initialNextTotal = _initialBlockRange * _currentRewardPerBlock;\r\n            _currentRewardPerBlock = (_currentRewardPerBlock * _initialBlockRange) / _nextBlockRange;\r\n            uint256 _nextTotal = _nextBlockRange * _currentRewardPerBlock;\r\n            nextRewardInfo.rewardPerBlock = _currentRewardPerBlock;\r\n            if (_nextTotal < _initialNextTotal) {\r\n                campaign.rewardToken.safeTransfer(rewardManager, _initialNextTotal - _nextTotal);\r\n                campaign.totalRewards -= _initialNextTotal - _nextTotal;\r\n            }\r\n        }\r\n        // UPDATE total\r\n        campaign.totalRewards = _refund ? campaign.totalRewards - _diff : campaign.totalRewards + _diff;\r\n        selectedRewardInfo.endBlock = _endBlock;\r\n        selectedRewardInfo.rewardPerBlock = _rewardPerBlock;\r\n        emit UpdateRewardInfo(_campaignID, _rewardIndex, _endBlock, _rewardPerBlock);\r\n    }\r\n\r\n    /// @inheritdoc FarmingRange\r\n    function removeLastRewardInfo(uint256 _campaignID) public override onlyOwner {\r\n        RewardInfo[] storage rewardInfo = campaignRewardInfo[_campaignID];\r\n        CampaignInfo storage campaign = campaignInfo[_campaignID];\r\n        uint256 _rewardInfoLength = rewardInfo.length;\r\n        require(_rewardInfoLength != 0, \"FarmingRange::updateCampaignsRewards::no rewardInfoLen\");\r\n        RewardInfo storage lastRewardInfo = rewardInfo[_rewardInfoLength - 1];\r\n        uint256 _lastRewardInfoEndBlock = lastRewardInfo.endBlock;\r\n        require(\r\n            _lastRewardInfoEndBlock > arbitrumBlockNumber(),\r\n            \"FarmingRange::removeLastRewardInfo::reward period ended\"\r\n        );\r\n        _updateCampaign(_campaignID);\r\n        if (lastRewardInfo.rewardPerBlock != 0) {\r\n            (bool _refund, uint256 _diff) = _updateRewardsDiff(\r\n                _rewardInfoLength - 1,\r\n                _lastRewardInfoEndBlock,\r\n                0,\r\n                rewardInfo,\r\n                campaign,\r\n                lastRewardInfo\r\n            );\r\n            if (_refund) {\r\n                campaign.totalRewards = campaign.totalRewards - _diff;\r\n            }\r\n        }\r\n        rewardInfo.pop();\r\n        emit RemoveRewardInfo(_campaignID, _rewardInfoLength - 1);\r\n    }\r\n\r\n    /// @inheritdoc FarmingRange\r\n    function currentEndBlock(uint256 _campaignID) external view override returns (uint256) {\r\n        return _endBlockOf(_campaignID, arbitrumBlockNumber());\r\n    }\r\n\r\n    /// @inheritdoc FarmingRange\r\n    function currentRewardPerBlock(uint256 _campaignID) external view override returns (uint256) {\r\n        return _rewardPerBlockOf(_campaignID, arbitrumBlockNumber());\r\n    }\r\n\r\n    /// @inheritdoc IFarmingRangeArbitrum\r\n    function arbitrumBlockNumber() public view returns (uint256) {\r\n        return ARBSYS.arbBlockNumber();\r\n    }\r\n\r\n    /// @inheritdoc FarmingRange\r\n    function _updateRewardsDiff(\r\n        uint256 _rewardIndex,\r\n        uint256 _endBlock,\r\n        uint256 _rewardPerBlock,\r\n        RewardInfo[] storage rewardInfo,\r\n        CampaignInfo storage campaign,\r\n        RewardInfo storage selectedRewardInfo\r\n    ) internal override returns (bool refund_, uint256 diff_) {\r\n        uint256 blockNumber = arbitrumBlockNumber();\r\n        uint256 _previousStartBlock = _rewardIndex == 0 ? campaign.startBlock : rewardInfo[_rewardIndex - 1].endBlock;\r\n        uint256 _newStartBlock = blockNumber > _previousStartBlock ? blockNumber : _previousStartBlock;\r\n        uint256 _previousBlockRange = selectedRewardInfo.endBlock - _previousStartBlock;\r\n        uint256 _newBlockRange = _endBlock - _newStartBlock;\r\n        uint256 _selectedRewardPerBlock = selectedRewardInfo.rewardPerBlock;\r\n        uint256 _accumulatedRewards = (_newStartBlock - _previousStartBlock) * _selectedRewardPerBlock;\r\n        uint256 _previousTotalRewards = _selectedRewardPerBlock * _previousBlockRange;\r\n        uint256 _totalRewards = _rewardPerBlock * _newBlockRange;\r\n        refund_ = _previousTotalRewards > _totalRewards + _accumulatedRewards;\r\n        diff_ = refund_\r\n            ? _previousTotalRewards - _totalRewards - _accumulatedRewards\r\n            : _totalRewards + _accumulatedRewards - _previousTotalRewards;\r\n        if (refund_) {\r\n            campaign.rewardToken.safeTransfer(rewardManager, diff_);\r\n        }\r\n    }\r\n\r\n    /// @inheritdoc FarmingRange\r\n    function _pendingReward(\r\n        uint256 _campaignID,\r\n        uint256 _amount,\r\n        uint256 _rewardDebt\r\n    ) internal view override returns (uint256) {\r\n        CampaignInfo memory _campaign = campaignInfo[_campaignID];\r\n        RewardInfo[] memory _rewardInfo = campaignRewardInfo[_campaignID];\r\n        uint256 _accRewardPerShare = _campaign.accRewardPerShare;\r\n        uint256 blockNumber = arbitrumBlockNumber();\r\n\r\n        if (blockNumber > _campaign.lastRewardBlock && _campaign.totalStaked != 0) {\r\n            uint256 _cursor = _campaign.lastRewardBlock;\r\n            for (uint256 _i; _i != _rewardInfo.length; ) {\r\n                uint256 _multiplier = getMultiplier(_cursor, blockNumber, _rewardInfo[_i].endBlock);\r\n                if (_multiplier != 0) {\r\n                    _cursor = _rewardInfo[_i].endBlock;\r\n                    _accRewardPerShare =\r\n                        _accRewardPerShare +\r\n                        ((_multiplier * _rewardInfo[_i].rewardPerBlock * 1e20) / _campaign.totalStaked);\r\n                }\r\n                unchecked {\r\n                    ++_i;\r\n                }\r\n            }\r\n        }\r\n        return ((_amount * _accRewardPerShare) / 1e20) - _rewardDebt;\r\n    }\r\n\r\n    /// @inheritdoc FarmingRange\r\n    function _updateCampaign(uint256 _campaignID) internal override {\r\n        require(campaignInfo.length > _campaignID, \"FarmingRange::_updateCampaign::Campaign id not valid\");\r\n        CampaignInfo storage campaign = campaignInfo[_campaignID];\r\n        RewardInfo[] memory _rewardInfo = campaignRewardInfo[_campaignID];\r\n        uint256 blockNumber = arbitrumBlockNumber();\r\n\r\n        if (blockNumber <= campaign.lastRewardBlock) {\r\n            return;\r\n        }\r\n        if (campaign.totalStaked == 0) {\r\n            uint256 _amount;\r\n            for (uint256 _i; _i != _rewardInfo.length; ) {\r\n                if (_rewardInfo[_i].endBlock >= campaign.lastRewardBlock) {\r\n                    uint256 _startBlock = _i != 0 ? _rewardInfo[_i - 1].endBlock : campaign.lastRewardBlock;\r\n                    bool _lastRewardInfo = _rewardInfo[_i].endBlock > blockNumber;\r\n                    uint256 _blockRange = (_lastRewardInfo ? blockNumber : _rewardInfo[_i].endBlock) -\r\n                        (_startBlock > campaign.lastRewardBlock ? _startBlock : campaign.lastRewardBlock);\r\n                    _amount += _rewardInfo[_i].rewardPerBlock * _blockRange;\r\n                    if (_lastRewardInfo) {\r\n                        break;\r\n                    }\r\n                }\r\n                unchecked {\r\n                    ++_i;\r\n                }\r\n            }\r\n\r\n            if (_amount != 0) {\r\n                campaign.rewardToken.safeTransfer(rewardManager, _amount);\r\n            }\r\n\r\n            campaign.lastRewardBlock = blockNumber;\r\n\r\n            return;\r\n        }\r\n        /// @dev for each reward info\r\n        for (uint256 _i; _i != _rewardInfo.length; ) {\r\n            // @dev get multiplier based on current Block and rewardInfo's end block\r\n            // multiplier will be a range of either (current block - campaign.lastRewardBlock)\r\n            // or (reward info's endblock - campaign.lastRewardBlock) or 0\r\n            uint256 _multiplier = getMultiplier(campaign.lastRewardBlock, blockNumber, _rewardInfo[_i].endBlock);\r\n            if (_multiplier != 0) {\r\n                // @dev if currentBlock exceed end block, use end block as the last reward block\r\n                // so that for the next iteration, previous endBlock will be used as the last reward block\r\n                if (blockNumber > _rewardInfo[_i].endBlock) {\r\n                    campaign.lastRewardBlock = _rewardInfo[_i].endBlock;\r\n                } else {\r\n                    campaign.lastRewardBlock = blockNumber;\r\n                }\r\n                campaign.accRewardPerShare =\r\n                    campaign.accRewardPerShare +\r\n                    ((_multiplier * _rewardInfo[_i].rewardPerBlock * 1e20) / campaign.totalStaked);\r\n            }\r\n            unchecked {\r\n                ++_i;\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/interfaces/IArbSys.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\nArbSys constant ARBSYS = ArbSys(address(100));\r\n\r\ninterface ArbSys {\r\n    /**\r\n     * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\r\n     * @return block number as int\r\n     */\r\n    function arbBlockNumber() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/rewards/interfaces/IAutoSwapper.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\n// interfaces\r\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\r\nimport \"../../core/interfaces/ISmardexFactory.sol\";\r\nimport \"../../core/interfaces/ISmardexSwapCallback.sol\";\r\nimport \"../../core/interfaces/ISmardexPair.sol\";\r\n\r\ninterface IAutoSwapper is ISmardexSwapCallback {\r\n    /**\r\n     * @notice swap parameters used by function _swapAndSend\r\n     * @param zeroForOne true if we swap the token0 with token1, false otherwise\r\n     * @param balanceIn balance of in-token to be swapped\r\n     * @param pair pair address\r\n     * @param fictiveReserve0 fictive reserve of token0 of the pair\r\n     * @param fictiveReserve1 fictive reserve of token1 of the pair\r\n     * @param oldPriceAv0 priceAverage of token0 of the pair before the swap\r\n     * @param oldPriceAv1 priceAverage of token1 of the pair before the swap\r\n     * @param oldPriceAvTimestamp priceAverageLastTimestamp of the pair before the swap\r\n     * @param newPriceAvIn priceAverage of token0 of the pair after the swap\r\n     * @param newPriceAvOut priceAverage of token1 of the pair after the swap\r\n     */\r\n    struct SwapCallParams {\r\n        bool zeroForOne;\r\n        uint256 balanceIn;\r\n        ISmardexPair pair;\r\n        uint256 fictiveReserve0;\r\n        uint256 fictiveReserve1;\r\n        uint256 oldPriceAv0;\r\n        uint256 oldPriceAv1;\r\n        uint256 oldPriceAvTimestamp;\r\n        uint256 newPriceAvIn;\r\n        uint256 newPriceAvOut;\r\n    }\r\n\r\n    /**\r\n     * @notice emitted every time the AutoSwapper swaps and stacks SDEXs\r\n     * @param _token0 the first swapped token\r\n     * @param _amount0 the amount of token0 swapped\r\n     * @param _token1 the second swapped token\r\n     * @param _amount1 the amount of token1 swapped\r\n     * @param _stakedAmount the staked amount\r\n     */\r\n    event workExecuted(IERC20 _token0, uint256 _amount0, IERC20 _token1, uint256 _amount1, uint256 _stakedAmount);\r\n\r\n    /**\r\n     * @notice public function for executing swaps on tokens and burn, will be called from a\r\n     * Smardex Pair on mint and burn, and can be forced call by anyone\r\n     * @param _token0 token to be converted to sdex\r\n     * @param _token1 token to be converted to sdex\r\n     */\r\n    function executeWork(IERC20 _token0, IERC20 _token1) external;\r\n\r\n    /**\r\n     * @notice onlyOwner function to swap token in SDEX and send it to the staking address (or burn on L2)\r\n     * @param _amountToSwap amount of tokens from _path[0] to be converted into SDEX\r\n     * @param _amountOutMin The minimum SDEX amount required to prevent the transaction from reverting\r\n     * @param _path An array of token addresses. path.length must be >= 2. Pools for each consecutive pair of addresses\r\n     * must exist and have liquidity. Last token must be SDEX\r\n     * @param _deadline Unix timestamp after which the transaction will revert\r\n     */\r\n    function swapTokenWithPath(\r\n        uint256 _amountToSwap,\r\n        uint256 _amountOutMin,\r\n        address[] calldata _path,\r\n        uint256 _deadline\r\n    ) external;\r\n\r\n    /**\r\n     * @notice transfer SDEX from here to address dead\r\n     * @return _amount the transferred SDEX amount\r\n     */\r\n    function transferTokens() external returns (uint256 _amount);\r\n\r\n    /**\r\n     * @notice return the factory address\r\n     * @return factory address\r\n     */\r\n    function factory() external view returns (ISmardexFactory);\r\n\r\n    /**\r\n     * @notice return the smardexToken address\r\n     * @return smardexToken address\r\n     */\r\n    function smardexToken() external view returns (IERC20);\r\n}\r\n"
    },
    "contracts/rewards/interfaces/IFarmingRange.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\n// interfaces\r\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\r\n\r\ninterface IFarmingRange {\r\n    /**\r\n     * @notice Info of each user.\r\n     * @param amount How many Staking tokens the user has provided.\r\n     * @param rewardDebt We do some fancy math here. Basically, any point in time, the amount of reward\r\n     *  entitled to a user but is pending to be distributed is:\r\n     *\r\n     *    pending reward = (user.amount * pool.accRewardPerShare) - user.rewardDebt\r\n     *\r\n     *  Whenever a user deposits or withdraws LP tokens to a pool. Here's what happens:\r\n     *    1. The pool's `accRewardPerShare` (and `lastRewardBlock`) gets updated.\r\n     *    2. User receives the pending reward sent to his/her address.\r\n     *    3. User's `amount` gets updated.\r\n     *    4. User's `rewardDebt` gets updated.\r\n     *\r\n     * from: https://github.com/jazz-defi/contracts/blob/master/MasterChefV2.sol\r\n     */\r\n    struct UserInfo {\r\n        uint256 amount;\r\n        uint256 rewardDebt;\r\n    }\r\n\r\n    /**\r\n     * @notice Info of each reward distribution campaign.\r\n     * @param stakingToken address of Staking token contract.\r\n     * @param rewardToken address of Reward token contract\r\n     * @param startBlock start block of the campaign\r\n     * @param lastRewardBlock last block number that Reward Token distribution occurs.\r\n     * @param accRewardPerShare accumulated Reward Token per share, times 1e20.\r\n     * @param totalStaked total staked amount each campaign's stake token, typically,\r\n     * @param totalRewards total amount of reward to be distributed until the end of the last phase\r\n     *\r\n     * @dev each campaign has the same stake token, so no need to track it separetely\r\n     */\r\n    struct CampaignInfo {\r\n        IERC20 stakingToken;\r\n        IERC20 rewardToken;\r\n        uint256 startBlock;\r\n        uint256 lastRewardBlock;\r\n        uint256 accRewardPerShare;\r\n        uint256 totalStaked;\r\n        uint256 totalRewards;\r\n    }\r\n\r\n    /**\r\n     * @notice Info about a reward-phase\r\n     * @param endBlock block number of the end of the phase\r\n     * @param rewardPerBlock amount of reward to be distributed per block in this phase\r\n     */\r\n    struct RewardInfo {\r\n        uint256 endBlock;\r\n        uint256 rewardPerBlock;\r\n    }\r\n\r\n    /**\r\n     * @notice emitted at each deposit\r\n     * @param user address that deposit its funds\r\n     * @param amount amount deposited\r\n     * @param campaign campaingId on which the user has deposited funds\r\n     */\r\n    event Deposit(address indexed user, uint256 amount, uint256 campaign);\r\n\r\n    /**\r\n     * @notice emitted at each withdraw\r\n     * @param _rewardTo address to which the reward tokens will be sent\r\n     * @param _stakingTo address to which the staking tokens will be sent\r\n     * @param amount amount withdrawn\r\n     * @param campaign campaingId on which the user has deposited funds\r\n     */\r\n    event Withdraw(address indexed _rewardTo, address indexed _stakingTo, uint256 amount, uint256 campaign);\r\n\r\n    /**\r\n     * @notice emitted at each emergency withdraw\r\n     * @param user address that emergency-withdrawn its funds\r\n     * @param amount amount emergency-withdrawn\r\n     * @param campaign campaingId on which the user has emergency-withdrawn funds\r\n     */\r\n    event EmergencyWithdraw(address indexed user, uint256 amount, uint256 campaign);\r\n\r\n    /**\r\n     * @notice emitted at each campaign added\r\n     * @param campaignID new campaign id\r\n     * @param stakingToken token address to be staked in this campaign\r\n     * @param rewardToken token address of the rewards in this campaign\r\n     * @param startBlock starting block of this campaign\r\n     */\r\n    event AddCampaignInfo(uint256 indexed campaignID, IERC20 stakingToken, IERC20 rewardToken, uint256 startBlock);\r\n\r\n    /**\r\n     * @notice emitted at each phase of reward added\r\n     * @param campaignID campaign id on which rewards were added\r\n     * @param phase number of the new phase added (latest at the moment of add)\r\n     * @param endBlock number of the block that the phase stops (phase starts at the endblock of the previous phase's\r\n     * endblock, and if it's the phase 0, it start at the startBlock of the campaign struct)\r\n     * @param rewardPerBlock amount of reward distributed per block in this phase\r\n     */\r\n    event AddRewardInfo(uint256 indexed campaignID, uint256 indexed phase, uint256 endBlock, uint256 rewardPerBlock);\r\n\r\n    /**\r\n     * @notice emitted when a reward phase is updated\r\n     * @param campaignID campaign id on which the rewards-phase is updated\r\n     * @param phase id of phase updated\r\n     * @param endBlock new endblock of the phase\r\n     * @param rewardPerBlock new rewardPerBlock of the phase\r\n     */\r\n    event UpdateRewardInfo(uint256 indexed campaignID, uint256 indexed phase, uint256 endBlock, uint256 rewardPerBlock);\r\n\r\n    /**\r\n     * @notice emitted when a reward phase is removed\r\n     * @param campaignID campaign id on which the rewards-phase is removed\r\n     * @param phase id of phase removed (only the latest phase can be removed)\r\n     */\r\n    event RemoveRewardInfo(uint256 indexed campaignID, uint256 indexed phase);\r\n\r\n    /**\r\n     * @notice emitted when the rewardInfoLimit is updated\r\n     * @param rewardInfoLimit new max phase amount per campaign\r\n     */\r\n    event SetRewardInfoLimit(uint256 rewardInfoLimit);\r\n\r\n    /**\r\n     * @notice set new reward info limit, defining how many phases are allowed\r\n     * @param _updatedRewardInfoLimit new reward info limit\r\n     */\r\n    function setRewardInfoLimit(uint256 _updatedRewardInfoLimit) external;\r\n\r\n    /**\r\n     * @notice reward campaign, one campaign represent a pair of staking and reward token,\r\n     * last reward Block and acc reward Per Share\r\n     * @param _stakingToken staking token address\r\n     * @param _rewardToken reward token address\r\n     * @param _startBlock block number when the campaign will start\r\n     */\r\n    function addCampaignInfo(IERC20 _stakingToken, IERC20 _rewardToken, uint256 _startBlock) external;\r\n\r\n    /**\r\n     * @notice add a new reward info, when a new reward info is added, the reward\r\n     * & its end block will be extended by the newly pushed reward info.\r\n     * @param _campaignID id of the campaign\r\n     * @param _endBlock end block of this reward info\r\n     * @param _rewardPerBlock reward per block to distribute until the end\r\n     */\r\n    function addRewardInfo(uint256 _campaignID, uint256 _endBlock, uint256 _rewardPerBlock) external;\r\n\r\n    /**\r\n     * @notice add multiple reward Info into a campaign in one tx.\r\n     * @param _campaignID id of the campaign\r\n     * @param _endBlock array of end blocks\r\n     * @param _rewardPerBlock array of reward per block\r\n     */\r\n    function addRewardInfoMultiple(\r\n        uint256 _campaignID,\r\n        uint256[] calldata _endBlock,\r\n        uint256[] calldata _rewardPerBlock\r\n    ) external;\r\n\r\n    /**\r\n     * @notice update one campaign reward info for a specified range index.\r\n     * @param _campaignID id of the campaign\r\n     * @param _rewardIndex index of the reward info\r\n     * @param _endBlock end block of this reward info\r\n     * @param _rewardPerBlock reward per block to distribute until the end\r\n     */\r\n    function updateRewardInfo(\r\n        uint256 _campaignID,\r\n        uint256 _rewardIndex,\r\n        uint256 _endBlock,\r\n        uint256 _rewardPerBlock\r\n    ) external;\r\n\r\n    /**\r\n     * @notice update multiple campaign rewards info for all range index.\r\n     * @param _campaignID id of the campaign\r\n     * @param _rewardIndex array of reward info index\r\n     * @param _endBlock array of end block\r\n     * @param _rewardPerBlock array of rewardPerBlock\r\n     */\r\n    function updateRewardMultiple(\r\n        uint256 _campaignID,\r\n        uint256[] memory _rewardIndex,\r\n        uint256[] memory _endBlock,\r\n        uint256[] memory _rewardPerBlock\r\n    ) external;\r\n\r\n    /**\r\n     * @notice update multiple campaigns and rewards info for all range index.\r\n     * @param _campaignID array of campaign id\r\n     * @param _rewardIndex multi dimensional array of reward info index\r\n     * @param _endBlock multi dimensional array of end block\r\n     * @param _rewardPerBlock multi dimensional array of rewardPerBlock\r\n     */\r\n    function updateCampaignsRewards(\r\n        uint256[] calldata _campaignID,\r\n        uint256[][] calldata _rewardIndex,\r\n        uint256[][] calldata _endBlock,\r\n        uint256[][] calldata _rewardPerBlock\r\n    ) external;\r\n\r\n    /**\r\n     * @notice remove last reward info for specified campaign.\r\n     * @param _campaignID campaign id\r\n     */\r\n    function removeLastRewardInfo(uint256 _campaignID) external;\r\n\r\n    /**\r\n     * @notice remove the _number last RewardInfos for specified campaign.\r\n     * @param _campaignID campaign id\r\n     * @param _number number of RewardInfos to remove\r\n     */\r\n    function removeLastRewardInfoMultiple(uint256 _campaignID, uint256 _number) external;\r\n\r\n    /**\r\n     * @notice return the entries amount of reward info for one campaign.\r\n     * @param _campaignID campaign id\r\n     * @return reward info quantity\r\n     */\r\n    function rewardInfoLen(uint256 _campaignID) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice return the number of campaigns.\r\n     * @return campaign quantity\r\n     */\r\n    function campaignInfoLen() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice return the end block of the current reward info for a given campaign.\r\n     * @param _campaignID campaign id\r\n     * @return reward info end block number\r\n     */\r\n    function currentEndBlock(uint256 _campaignID) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice return the reward per block of the current reward info for a given campaign.\r\n     * @param _campaignID campaign id\r\n     * @return current reward per block\r\n     */\r\n    function currentRewardPerBlock(uint256 _campaignID) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Return reward multiplier over the given _from to _to block.\r\n     * Reward multiplier is the amount of blocks between from and to\r\n     * @param _from start block number\r\n     * @param _to end block number\r\n     * @param _endBlock end block number of the reward info\r\n     * @return block distance\r\n     */\r\n    function getMultiplier(uint256 _from, uint256 _to, uint256 _endBlock) external returns (uint256);\r\n\r\n    /**\r\n     * @notice View function to retrieve pending Reward.\r\n     * @param _campaignID pending reward of campaign id\r\n     * @param _user address to retrieve pending reward\r\n     * @return current pending reward\r\n     */\r\n    function pendingReward(uint256 _campaignID, address _user) external view returns (uint256);\r\n\r\n    /**\r\n     * @notice Update reward variables of the given campaign to be up-to-date.\r\n     * @param _campaignID campaign id\r\n     */\r\n    function updateCampaign(uint256 _campaignID) external;\r\n\r\n    /**\r\n     * @notice Update reward variables for all campaigns. gas spending is HIGH in this method call, BE CAREFUL.\r\n     */\r\n    function massUpdateCampaigns() external;\r\n\r\n    /**\r\n     * @notice Deposit staking token in a campaign.\r\n     * @param _campaignID campaign id\r\n     * @param _amount amount to deposit\r\n     * @param _for address to deposit for\r\n     */\r\n    function deposit(uint256 _campaignID, uint256 _amount, address _for) external;\r\n\r\n    /**\r\n     * @notice Deposit staking token in a campaign with the EIP-2612 signature off chain\r\n     * @param _campaignID campaign id\r\n     * @param _amount amount to deposit\r\n     * @param _approveMax Whether or not the approval amount in the signature is for liquidity or uint(-1).\r\n     * @param _deadline Unix timestamp after which the transaction will revert.\r\n     * @param _v The v component of the permit signature.\r\n     * @param _r The r component of the permit signature.\r\n     * @param _s The s component of the permit signature.\r\n     */\r\n    function depositWithPermit(\r\n        uint256 _campaignID,\r\n        uint256 _amount,\r\n        bool _approveMax,\r\n        uint256 _deadline,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Withdraw staking token in a campaign. Also withdraw the current pending reward\r\n     * @param _campaignID campaign id\r\n     * @param _amount amount to withdraw\r\n     * @param _rewardTo address to which the reward tokens will be sent\r\n     * @param _stakingTo address to which the staking tokens will be sent\r\n     */\r\n    function withdraw(uint256 _campaignID, uint256 _amount, address _rewardTo, address _stakingTo) external;\r\n\r\n    /**\r\n     * @notice Harvest campaigns, will claim rewards token of every campaign ids in the array\r\n     * @param _campaignIDs array of campaign id\r\n     * @param _rewardTo address to which the reward tokens will be sent\r\n     */\r\n    function harvest(uint256[] calldata _campaignIDs, address _rewardTo) external;\r\n\r\n    /**\r\n     * @notice Withdraw without caring about rewards. EMERGENCY ONLY.\r\n     * @param _campaignID campaign id\r\n     */\r\n    function emergencyWithdraw(uint256 _campaignID) external;\r\n\r\n    /**\r\n     * @notice get Reward info for a campaign ID and index, that is a set of {endBlock, rewardPerBlock}\r\n     *  indexed by campaign ID\r\n     * @param _campaignID campaign id\r\n     * @param _rewardIndex index of the reward info\r\n     * @return endBlock_ end block of this reward info\r\n     * @return rewardPerBlock_ reward per block to distribute\r\n     */\r\n    function campaignRewardInfo(\r\n        uint256 _campaignID,\r\n        uint256 _rewardIndex\r\n    ) external view returns (uint256 endBlock_, uint256 rewardPerBlock_);\r\n\r\n    /**\r\n     * @notice get a Campaign Reward info for a campaign ID\r\n     * @param _campaignID campaign id\r\n     * @return all params from CampaignInfo struct\r\n     */\r\n    function campaignInfo(\r\n        uint256 _campaignID\r\n    ) external view returns (IERC20, IERC20, uint256, uint256, uint256, uint256, uint256);\r\n\r\n    /**\r\n     * @notice get a User Reward info for a campaign ID and user address\r\n     * @param _campaignID campaign id\r\n     * @param _user user address\r\n     * @return all params from UserInfo struct\r\n     */\r\n    function userInfo(uint256 _campaignID, address _user) external view returns (uint256, uint256);\r\n\r\n    /**\r\n     * @notice how many reward phases can be set for a campaign\r\n     * @return rewards phases size limit\r\n     */\r\n    function rewardInfoLimit() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice get reward Manager address holding rewards to distribute\r\n     * @return address of reward manager\r\n     */\r\n    function rewardManager() external view returns (address);\r\n}\r\n"
    },
    "contracts/rewards/interfaces/IFarmingRangeL2Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\ninterface IFarmingRangeArbitrum {\r\n    /**\r\n     * @notice return arbitrum L2 block.number\r\n     */\r\n    function arbitrumBlockNumber() external returns (uint256);\r\n}\r\n"
    },
    "contracts/rewards/interfaces/IRewardManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\n// interfaces\r\nimport \"./IRewardManagerL2.sol\";\r\nimport \"./IStaking.sol\";\r\n\r\ninterface IRewardManager is IRewardManagerL2 {\r\n    /**\r\n     * @notice used to get the staking contract address\r\n     * @return staking contract address (or Staking contract type in Solidity)\r\n     */\r\n    function staking() external view returns (IStaking);\r\n}\r\n"
    },
    "contracts/rewards/interfaces/IRewardManagerL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\n// interfaces\r\nimport \"./IFarmingRange.sol\";\r\n\r\ninterface IRewardManagerL2 {\r\n    /**\r\n     * @notice used to resetAllowance with farming contract to take rewards\r\n     * @param _campaignId campaign id\r\n     */\r\n    function resetAllowance(uint256 _campaignId) external;\r\n\r\n    /**\r\n     * @notice used to get the farming contract address\r\n     * @return farming contract address (or FarmingRange contract type in Solidity)\r\n     */\r\n    function farming() external view returns (IFarmingRange);\r\n}\r\n"
    },
    "contracts/rewards/interfaces/IRewardManagerWithdrawable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\ninterface IRewardManagerWithdrawable {\r\n    /**\r\n     * @notice used to get retrieve tokens\r\n     * @param _token token contract address to retrieve\r\n     * @param _amount amount of token to retrieve\r\n     * @param _to address to send the tokens\r\n     */\r\n    function withdrawFunds(address _token, uint256 _amount, address _to) external;\r\n}\r\n"
    },
    "contracts/rewards/interfaces/IStaking.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\n// interfaces\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./IFarmingRange.sol\";\r\n\r\ninterface IStaking is IERC20 {\r\n    /**\r\n     * @notice info of each user\r\n     * @param shares shares owned in the staking\r\n     * @param lastBlockUpdate last block the user called deposit or withdraw\r\n     */\r\n    struct UserInfo {\r\n        uint256 shares;\r\n        uint256 lastBlockUpdate;\r\n    }\r\n\r\n    /**\r\n     * @notice emitted at each deposit\r\n     * @param from address that deposit its funds\r\n     * @param depositAmount amount deposited\r\n     * @param shares shares corresponding to the token amount deposited\r\n     */\r\n    event Deposit(address indexed from, uint256 depositAmount, uint256 shares);\r\n\r\n    /**\r\n     * @notice emitted at each withdraw\r\n     * @param from address that calls the withdraw function, and of which the shares are withdrawn\r\n     * @param to address that receives the funds\r\n     * @param tokenReceived amount of token received by to\r\n     * @param shares shares corresponding to the token amount withdrawn\r\n     */\r\n    event Withdraw(address indexed from, address indexed to, uint256 tokenReceived, uint256 shares);\r\n\r\n    /**\r\n     * @notice emitted when calling emergencyWithdraw\r\n     * @param from address that calls the withdraw function, and of which the shares are withdrawn\r\n     * @param to address that receives the funds\r\n     * @param tokenReceived amount of token received by to\r\n     * @param shares shares corresponding to the token amount withdrawn\r\n     */\r\n    event EmergencyWithdraw(address indexed from, address indexed to, uint256 tokenReceived, uint256 shares);\r\n\r\n    /**\r\n     * @notice Initialize staking connection with farming\r\n     * Mint one token of stSDEX and then deposit in the staking farming pool\r\n     * This contract should be the only participant of the staking farming pool\r\n     */\r\n    function initializeFarming() external;\r\n\r\n    /**\r\n     * @notice Send SDEX to get shares in the staking pool\r\n     * @param _depositAmount The amount of SDEX to send\r\n     */\r\n    function deposit(uint256 _depositAmount) external;\r\n\r\n    /**\r\n     * @notice Send SDEX to get shares in the staking pool with the EIP-2612 signature off chain\r\n     * @param _depositAmount The amount of SDEX to send\r\n     * @param _approveMax Whether or not the approval amount in the signature is for liquidity or uint(-1).\r\n     * @param _deadline Unix timestamp after which the transaction will revert.\r\n     * @param _v The v component of the permit signature.\r\n     * @param _r The r component of the permit signature.\r\n     * @param _s The s component of the permit signature.\r\n     */\r\n    function depositWithPermit(\r\n        uint256 _depositAmount,\r\n        bool _approveMax,\r\n        uint256 _deadline,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external;\r\n\r\n    /**\r\n     * @notice Harvest and withdraw SDEX for the amount of shares defined\r\n     * @param _to The address who will receive SDEX\r\n     * @param _sharesAmount The amount of shares to use\r\n     */\r\n    function withdraw(address _to, uint256 _sharesAmount) external;\r\n\r\n    /**\r\n     * @notice Withdraw SDEX for all shares of the sender, will not harvest before. Only use this function in emergency\r\n     *         WARNING: This function may result in a lower amount of SDEX being withdrawn because it bypasses potential\r\n     *         SDEX earnings from farming.\r\n     *         Only use this function if standard withdrawal does not work for unknown reasons.\r\n     * @param _to The address who will receive SDEX\r\n     */\r\n    function emergencyWithdraw(address _to) external;\r\n\r\n    /**\r\n     * @notice Harvest the farming pool for the staking, will increase the SDEX\r\n     */\r\n    function harvestFarming() external;\r\n\r\n    /**\r\n     * @notice Calculate shares qty for an amount of sdex tokens\r\n     * @param _tokens user qty of sdex to be converted to shares\r\n     * @return shares_ shares equivalent to the token amount. _shares <= totalShares\r\n     */\r\n    function tokensToShares(uint256 _tokens) external view returns (uint256 shares_);\r\n\r\n    /**\r\n     * @notice Calculate shares values in sdex tokens\r\n     * @param _shares amount of shares. _shares <= totalShares\r\n     * @return tokens_ qty of sdex token equivalent to the _shares. tokens_ <= _currentBalance\r\n     */\r\n    function sharesToTokens(uint256 _shares) external view returns (uint256 tokens_);\r\n\r\n    /**\r\n     * @notice Campaign id for staking in the farming contract\r\n     * @return ID of the campaign\r\n     */\r\n    function CAMPAIGN_ID() external view returns (uint256);\r\n\r\n    /**\r\n     * @notice get farming initialized status\r\n     * @return boolean inititalized or not\r\n     */\r\n    function farmingInitialized() external view returns (bool);\r\n\r\n    /**\r\n     * @notice get smardex Token contract address\r\n     * @return smardex contract (address or type for Solidity)\r\n     */\r\n    function smardexToken() external view returns (IERC20);\r\n\r\n    /**\r\n     * @notice get farming contract address\r\n     * @return farming contract (address or type for Solidity)\r\n     */\r\n    function farming() external view returns (IFarmingRange);\r\n\r\n    /**\r\n     * @notice get user info for staking status\r\n     * @param _user user address\r\n     * @return shares amount for user\r\n     * @return lastBlockUpdate last block the user called deposit or withdraw\r\n     */\r\n    function userInfo(address _user) external view returns (uint256, uint256);\r\n\r\n    /**\r\n     * @notice get total shares in the staking\r\n     * @return total shares amount\r\n     */\r\n    function totalShares() external view returns (uint256);\r\n}\r\n"
    },
    "contracts/rewards/RewardManager.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\n// contracts\r\nimport \"./FarmingRange.sol\";\r\nimport \"./Staking.sol\";\r\n\r\n// libraries\r\nimport \"../core/libraries/TransferHelper.sol\";\r\n\r\n// interfaces\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./interfaces/IRewardManager.sol\";\r\n\r\n/**\r\n * @title RewardManager\r\n * @notice RewardManager handles the creation of the contract staking and farming, automatically create a campaignInfo\r\n * in the farming for the staking, at slot 0 and initialize farming. The RewardManager is the owner of the funds in\r\n * the FarmingRange, only the RewardManager is capable of sending funds to be farmed and only the RewardManager will get\r\n * the funds back when updating of removing campaigns.\r\n */\r\ncontract RewardManager is IRewardManager {\r\n    bytes4 private constant TRANSFER_OWNERSHIP_SELECTOR = bytes4(keccak256(bytes(\"transferOwnership(address)\")));\r\n\r\n    IFarmingRange public immutable farming;\r\n    IStaking public immutable staking;\r\n\r\n    /**\r\n     * @param _farmingOwner address who will own the farming\r\n     * @param _smardexToken address of the smardex token\r\n     * @param _startFarmingCampaign block number the staking pool in the farming will start to give rewards\r\n     */\r\n    constructor(address _farmingOwner, IERC20 _smardexToken, uint256 _startFarmingCampaign) {\r\n        require(_startFarmingCampaign > block.number, \"RewardManager:start farming is in the past\");\r\n        farming = new FarmingRange(address(this));\r\n        staking = new Staking(_smardexToken, farming);\r\n        farming.addCampaignInfo(staking, _smardexToken, _startFarmingCampaign);\r\n        staking.initializeFarming();\r\n\r\n        address(farming).call(abi.encodeWithSelector(TRANSFER_OWNERSHIP_SELECTOR, _farmingOwner));\r\n    }\r\n\r\n    /// @inheritdoc IRewardManagerL2\r\n    function resetAllowance(uint256 _campaignId) external {\r\n        require(_campaignId < farming.campaignInfoLen(), \"RewardManager:campaignId:wrong campaign ID\");\r\n\r\n        (, IERC20 _rewardToken, , , , , ) = farming.campaignInfo(_campaignId);\r\n\r\n        // In case of tokens like USDT, an approval must be set to zero before setting it to another value.\r\n        // Unlike most tokens, USDT does not ignore a non-zero current allowance value, leading to a possible\r\n        // transaction failure when you are trying to change the allowance.\r\n        if (_rewardToken.allowance(address(this), address(farming)) != 0) {\r\n            TransferHelper.safeApprove(address(_rewardToken), address(farming), 0);\r\n        }\r\n\r\n        // After ensuring that the allowance is zero (or it was zero to begin with), we then set the allowance to max.\r\n        TransferHelper.safeApprove(address(_rewardToken), address(farming), type(uint256).max);\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/RewardManagerL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\n// contracts\r\nimport \"./FarmingRange.sol\";\r\n\r\n// libraries\r\nimport \"../core/libraries/TransferHelper.sol\";\r\n\r\n// interfaces\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./interfaces/IRewardManagerL2.sol\";\r\n\r\n/**\r\n * @title RewardManagerL2\r\n * @notice RewardManagerL2 handles the creation of the contract farming\r\n * The RewardManager is the owner of the funds in the FarmingRange,\r\n * only the RewardManager is capable of sending funds to be farmed and only the RewardManager will get\r\n * the funds back when updating of removing campaigns.\r\n */\r\ncontract RewardManagerL2 is IRewardManagerL2 {\r\n    bytes4 private constant TRANSFER_OWNERSHIP_SELECTOR = bytes4(keccak256(bytes(\"transferOwnership(address)\")));\r\n\r\n    IFarmingRange public immutable farming;\r\n\r\n    /**\r\n     * @param _farmingOwner address who will own the farming\r\n     */\r\n    constructor(address _farmingOwner) {\r\n        farming = new FarmingRange(address(this));\r\n\r\n        address(farming).call(abi.encodeWithSelector(TRANSFER_OWNERSHIP_SELECTOR, _farmingOwner));\r\n    }\r\n\r\n    /// @inheritdoc IRewardManagerL2\r\n    function resetAllowance(uint256 _campaignId) external {\r\n        require(_campaignId < farming.campaignInfoLen(), \"RewardManager:campaignId:wrong campaign ID\");\r\n\r\n        (, IERC20 _rewardToken, , , , , ) = farming.campaignInfo(_campaignId);\r\n\r\n        // In case of tokens like USDT, an approval must be set to zero before setting it to another value.\r\n        // Unlike most tokens, USDT does not ignore a non-zero current allowance value, leading to a possible\r\n        // transaction failure when you are trying to change the allowance.\r\n        if (_rewardToken.allowance(address(this), address(farming)) != 0) {\r\n            TransferHelper.safeApprove(address(_rewardToken), address(farming), 0);\r\n        }\r\n\r\n        // After ensuring that the allowance is zero (or it was zero to begin with), we then set the allowance to max.\r\n        TransferHelper.safeApprove(address(_rewardToken), address(farming), type(uint256).max);\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/RewardManagerL2Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\n// contracts\r\nimport \"./FarmingRangeL2Arbitrum.sol\";\r\n\r\n// libraries\r\nimport \"../core/libraries/TransferHelper.sol\";\r\n\r\n// interfaces\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"./interfaces/IRewardManagerL2.sol\";\r\n\r\n/**\r\n * @title RewardManagerL2Arbitrum\r\n * @notice RewardManagerL2Arbitrum handles the creation of the contract farming\r\n * The RewardManager is the owner of the funds in the FarmingRangeArbitrum,\r\n * only the RewardManager is capable of sending funds to be farmed and only the RewardManager will get\r\n * the funds back when updating of removing campaigns.\r\n * Use only for Arbitrum chain\r\n */\r\ncontract RewardManagerL2Arbitrum is IRewardManagerL2 {\r\n    bytes4 private constant TRANSFER_OWNERSHIP_SELECTOR = bytes4(keccak256(bytes(\"transferOwnership(address)\")));\r\n\r\n    IFarmingRange public immutable farming;\r\n\r\n    /**\r\n     * @param _farmingOwner address who will own the farming\r\n     */\r\n    constructor(address _farmingOwner) {\r\n        farming = new FarmingRangeL2Arbitrum(address(this));\r\n\r\n        address(farming).call(abi.encodeWithSelector(TRANSFER_OWNERSHIP_SELECTOR, _farmingOwner));\r\n    }\r\n\r\n    /// @inheritdoc IRewardManagerL2\r\n    function resetAllowance(uint256 _campaignId) external {\r\n        require(_campaignId < farming.campaignInfoLen(), \"RewardManager:campaignId:wrong campaign ID\");\r\n\r\n        (, IERC20 _rewardToken, , , , , ) = farming.campaignInfo(_campaignId);\r\n\r\n        // In case of tokens like USDT, an approval must be set to zero before setting it to another value.\r\n        // Unlike most tokens, USDT does not ignore a non-zero current allowance value, leading to a possible\r\n        // transaction failure when you are trying to change the allowance.\r\n        if (_rewardToken.allowance(address(this), address(farming)) != 0) {\r\n            TransferHelper.safeApprove(address(_rewardToken), address(farming), 0);\r\n        }\r\n\r\n        // After ensuring that the allowance is zero (or it was zero to begin with), we then set the allowance to max.\r\n        TransferHelper.safeApprove(address(_rewardToken), address(farming), type(uint256).max);\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/RewardManagerWithdrawable.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\n// contracts\r\nimport \"./RewardManagerL2.sol\";\r\n\r\n// interfaces\r\nimport \"./interfaces/IRewardManagerWithdrawable.sol\";\r\n\r\n/**\r\n * @title RewardManagerWithdrawable\r\n * @notice RewardManagerWithdrawable handles the creation of the contract farming\r\n * The RewardManager is the owner of the funds in the FarmingRange,\r\n * only the RewardManager is capable of sending funds to be farmed and only the RewardManager will get\r\n * the funds back when updating of removing campaigns. The specificity of the withdrawable reward manager\r\n * is that it's used for promoted campaigns, and thus the needs to be able to withdraw funds is here.\r\n */\r\ncontract RewardManagerWithdrawable is RewardManagerL2, IRewardManagerWithdrawable {\r\n    constructor(address _farming) RewardManagerL2(_farming) {}\r\n\r\n    /// @inheritdoc IRewardManagerWithdrawable\r\n    function withdrawFunds(address _token, uint256 _amount, address _to) external {\r\n        require(\r\n            msg.sender == Ownable(address(farming)).owner(),\r\n            \"RewardManager:withdrawFunds:Only the farming owner can withdraw funds\"\r\n        );\r\n\r\n        TransferHelper.safeTransfer(_token, _to, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/RewardManagerWithdrawableArbitrum.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\n// contracts\r\nimport \"./RewardManagerL2Arbitrum.sol\";\r\n\r\n// interfaces\r\nimport \"./interfaces/IRewardManagerWithdrawable.sol\";\r\n\r\n/**\r\n * @title RewardManagerWithdrawableArbitrum\r\n * @notice RewardManagerWithdrawableArbitrum handles the creation of the contract farming\r\n * The RewardManager is the owner of the funds in the FarmingRange,\r\n * only the RewardManager is capable of sending funds to be farmed and only the RewardManager will get\r\n * the funds back when updating of removing campaigns. The specificity of the withdrawable reward manager\r\n * is that it's used for promoted campaigns, and thus the needs to be able to withdraw funds is here.\r\n */\r\ncontract RewardManagerWithdrawableArbitrum is RewardManagerL2Arbitrum, IRewardManagerWithdrawable {\r\n    constructor(address _farming) RewardManagerL2Arbitrum(_farming) {}\r\n\r\n    /// @inheritdoc IRewardManagerWithdrawable\r\n    function withdrawFunds(address _token, uint256 _amount, address _to) external {\r\n        require(\r\n            msg.sender == Ownable(address(farming)).owner(),\r\n            \"RewardManager:withdrawFunds:Only the farming owner can withdraw funds\"\r\n        );\r\n\r\n        TransferHelper.safeTransfer(_token, _to, _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/Staking.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\n// libraries\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n// interfaces\r\nimport \"./interfaces/IStaking.sol\";\r\n\r\n/**\r\n * @title Staking\r\n * @notice Implementation of an APY staking pool. Users can deposit SDEX for a share in the pool. New shares depend of\r\n * current shares supply and SDEX in the pool. Pool will receive SDEX rewards fees by external transfer from admin or\r\n * contract but also from farming pool. Each deposit/withdraw will harvest the user funds in the farming pool as well.\r\n */\r\ncontract Staking is IStaking, ERC20 {\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 public constant CAMPAIGN_ID = 0;\r\n    uint256 internal constant SHARES_FACTOR = 1e18;\r\n    uint256 public constant MINIMUM_SHARES = 10 ** 3;\r\n\r\n    IERC20 public immutable smardexToken;\r\n    IFarmingRange public immutable farming;\r\n\r\n    mapping(address => UserInfo) public userInfo;\r\n    uint256 public totalShares;\r\n    bool public farmingInitialized = false;\r\n\r\n    modifier isFarmingInitialized() {\r\n        require(farmingInitialized == true, \"Staking::isFarmingInitialized::Farming campaign not initialized\");\r\n        _;\r\n    }\r\n\r\n    modifier checkUserBlock() {\r\n        require(\r\n            userInfo[msg.sender].lastBlockUpdate < block.number,\r\n            \"Staking::checkUserBlock::User already called deposit or withdraw this block\"\r\n        );\r\n        userInfo[msg.sender].lastBlockUpdate = block.number;\r\n        _;\r\n    }\r\n\r\n    constructor(IERC20 _smardexToken, IFarmingRange _farming) ERC20(\"Staked SmarDex Token\", \"stSDEX\") {\r\n        require(address(_smardexToken) != address(0), \"Staking::constructor::Smardex token is not defined\");\r\n        require(address(_farming) != address(0), \"Staking::constructor::Farming is not defined\");\r\n        smardexToken = _smardexToken;\r\n        farming = _farming;\r\n    }\r\n\r\n    /// @inheritdoc IStaking\r\n    function initializeFarming() external {\r\n        require(farmingInitialized == false, \"Staking::initializeFarming::Farming campaign already initialized\");\r\n        _approve(address(this), address(farming), 1 wei);\r\n        _mint(address(this), 1 wei);\r\n        farming.deposit(CAMPAIGN_ID, 1 wei, address(this));\r\n\r\n        farmingInitialized = true;\r\n    }\r\n\r\n    /// @inheritdoc IStaking\r\n    function deposit(uint256 _depositAmount) public isFarmingInitialized checkUserBlock {\r\n        require(_depositAmount != 0, \"Staking::deposit::can't deposit zero token\");\r\n\r\n        harvestFarming();\r\n\r\n        uint256 _currentBalance = smardexToken.balanceOf(address(this));\r\n        uint256 _newShares = _tokensToShares(_depositAmount, _currentBalance);\r\n\r\n        uint256 _userNewShares;\r\n        if (totalShares == 0) {\r\n            _userNewShares = _newShares - MINIMUM_SHARES;\r\n        } else {\r\n            _userNewShares = _newShares;\r\n        }\r\n        require(_userNewShares != 0, \"Staking::deposit::no new shares received\");\r\n        userInfo[msg.sender].shares += _userNewShares;\r\n        totalShares += _newShares;\r\n\r\n        smardexToken.safeTransferFrom(msg.sender, address(this), _depositAmount);\r\n\r\n        emit Deposit(msg.sender, _depositAmount, _userNewShares);\r\n    }\r\n\r\n    /// @inheritdoc IStaking\r\n    function depositWithPermit(\r\n        uint256 _depositAmount,\r\n        bool _approveMax,\r\n        uint256 _deadline,\r\n        uint8 _v,\r\n        bytes32 _r,\r\n        bytes32 _s\r\n    ) external {\r\n        SafeERC20.safePermit(\r\n            IERC20Permit(address(smardexToken)),\r\n            msg.sender,\r\n            address(this),\r\n            _approveMax ? type(uint256).max : _depositAmount,\r\n            _deadline,\r\n            _v,\r\n            _r,\r\n            _s\r\n        );\r\n\r\n        deposit(_depositAmount);\r\n    }\r\n\r\n    /// @inheritdoc IStaking\r\n    function withdraw(address _to, uint256 _sharesAmount) external isFarmingInitialized checkUserBlock {\r\n        require(\r\n            _sharesAmount != 0 && userInfo[msg.sender].shares >= _sharesAmount,\r\n            \"Staking::withdraw::can't withdraw more than user shares or zero\"\r\n        );\r\n\r\n        harvestFarming();\r\n\r\n        uint256 _currentBalance = smardexToken.balanceOf(address(this));\r\n        uint256 _tokensToWithdraw = _sharesToTokens(_sharesAmount, _currentBalance);\r\n\r\n        userInfo[msg.sender].shares -= _sharesAmount;\r\n        totalShares -= _sharesAmount;\r\n        smardexToken.safeTransfer(_to, _tokensToWithdraw);\r\n\r\n        emit Withdraw(msg.sender, _to, _tokensToWithdraw, _sharesAmount);\r\n    }\r\n\r\n    /// @inheritdoc IStaking\r\n    function emergencyWithdraw(address _to) external isFarmingInitialized checkUserBlock {\r\n        require(userInfo[msg.sender].shares != 0, \"Staking::emergencyWithdraw::no shares to withdraw\");\r\n\r\n        uint256 _sharesAmount = userInfo[msg.sender].shares;\r\n        uint256 _currentBalance = smardexToken.balanceOf(address(this));\r\n        uint256 _tokensToWithdraw = _sharesToTokens(_sharesAmount, _currentBalance);\r\n\r\n        totalShares -= _sharesAmount;\r\n        userInfo[msg.sender].shares = 0;\r\n        smardexToken.safeTransfer(_to, _tokensToWithdraw);\r\n\r\n        emit EmergencyWithdraw(msg.sender, _to, _tokensToWithdraw, _sharesAmount);\r\n    }\r\n\r\n    /// @inheritdoc IStaking\r\n    function harvestFarming() public {\r\n        farming.withdraw(CAMPAIGN_ID, 0, address(this), address(this));\r\n    }\r\n\r\n    /// @inheritdoc IStaking\r\n    function tokensToShares(uint256 _tokens) external view returns (uint256 shares_) {\r\n        uint256 _currentBalance = smardexToken.balanceOf(address(this));\r\n        _currentBalance += farming.pendingReward(CAMPAIGN_ID, address(this));\r\n\r\n        shares_ = _tokensToShares(_tokens, _currentBalance);\r\n    }\r\n\r\n    /// @inheritdoc IStaking\r\n    function sharesToTokens(uint256 _shares) external view returns (uint256 tokens_) {\r\n        uint256 _currentBalance = smardexToken.balanceOf(address(this));\r\n        _currentBalance += farming.pendingReward(CAMPAIGN_ID, address(this));\r\n\r\n        tokens_ = _sharesToTokens(_shares, _currentBalance);\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate shares qty for an amount of sdex tokens\r\n     * @param _tokens user qty of sdex to be converted to shares\r\n     * @param _currentBalance contract balance sdex. _tokens <= _currentBalance\r\n     * @return shares_ shares equivalent to the token amount. _shares <= totalShares\r\n     */\r\n    function _tokensToShares(uint256 _tokens, uint256 _currentBalance) internal view returns (uint256 shares_) {\r\n        shares_ = totalShares != 0 ? (_tokens * totalShares) / _currentBalance : _tokens * SHARES_FACTOR;\r\n    }\r\n\r\n    /**\r\n     * @notice Calculate shares values in sdex tokens\r\n     * @param _shares amount of shares. _shares <= totalShares\r\n     * @param _currentBalance contract balance in sdex\r\n     * @return tokens_ qty of sdex token equivalent to the _shares. tokens_ <= _currentBalance\r\n     */\r\n    function _sharesToTokens(uint256 _shares, uint256 _currentBalance) internal view returns (uint256 tokens_) {\r\n        tokens_ = totalShares != 0 ? (_shares * _currentBalance) / totalShares : _shares / SHARES_FACTOR;\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/test/ArbSysCoreTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.17;\r\n\r\ncontract ArbSysCoreTest {\r\n    /**\r\n     * @notice Get Arbitrum block number (distinct from L1 block number; Arbitrum genesis block has block number 0)\r\n     * @return block number as int\r\n     */\r\n    function arbBlockNumber() external view returns (uint256) {\r\n        return block.number;\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/test/CheckBlockTest.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\n// interfaces\r\nimport \"@openzeppelin/contracts/interfaces/IERC20.sol\";\r\nimport \"../interfaces/IStaking.sol\";\r\n\r\ncontract CheckBlockTest {\r\n    IStaking staking;\r\n    IERC20 sdex;\r\n\r\n    constructor(IStaking _staking, IERC20 _sdex) {\r\n        staking = _staking;\r\n        sdex = _sdex;\r\n        sdex.approve(address(staking), type(uint256).max);\r\n    }\r\n\r\n    function exploitStaking(uint256 amount) external {\r\n        staking.deposit(amount);\r\n        staking.withdraw(address(this), amount * 1e27);\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/test/MultiCall.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\ncontract MultiCall {\r\n    function multiCall(address _target, bytes[] calldata _data) external returns (bytes[] memory) {\r\n        uint256 _dataLength = _data.length;\r\n        bytes[] memory _results = new bytes[](_dataLength);\r\n\r\n        for (uint _i; _i < _dataLength; ) {\r\n            (bool _success, bytes memory _result) = _target.call(_data[_i]);\r\n            require(_success, string(_result));\r\n            _results[_i] = _result;\r\n\r\n            unchecked {\r\n                ++_i;\r\n            }\r\n        }\r\n\r\n        return _results;\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/test/RewardManagerTest.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\nimport \"../RewardManager.sol\";\r\n\r\ncontract RewardManagerTest is RewardManager {\r\n    constructor(\r\n        address _farmingOwner,\r\n        IERC20 _smardexToken,\r\n        uint256 _startFarmingCampaign\r\n    ) RewardManager(_farmingOwner, _smardexToken, _startFarmingCampaign) {}\r\n\r\n    function setAllowance(address _token, uint256 _amount) external {\r\n        TransferHelper.safeApprove(_token, address(farming), _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/test/RewardManagerTestL2.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\nimport \"../RewardManagerL2.sol\";\r\n\r\ncontract RewardManagerTestL2 is RewardManagerL2 {\r\n    constructor(address _farmingOwner) RewardManagerL2(_farmingOwner) {}\r\n\r\n    function setAllowance(address _token, uint256 _amount) external {\r\n        TransferHelper.safeApprove(_token, address(farming), _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/test/RewardManagerTestL2Arbitrum.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\r\npragma solidity 0.8.17;\r\n\r\nimport \"../RewardManagerL2Arbitrum.sol\";\r\n\r\ncontract RewardManagerTestL2Arbitrum is RewardManagerL2Arbitrum {\r\n    constructor(address _farmingOwner) RewardManagerL2Arbitrum(_farmingOwner) {}\r\n\r\n    function setAllowance(address _token, uint256 _amount) external {\r\n        TransferHelper.safeApprove(_token, address(farming), _amount);\r\n    }\r\n}\r\n"
    },
    "contracts/rewards/test/TestToken/TestToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\r\n\r\n/**\r\n * @title Test Token\r\n * @notice Inherit from the ERC20Permit, allowing to sign approve off chain\r\n */\r\ncontract TestToken is ERC20Permit {\r\n    uint8 private immutable _decimals;\r\n\r\n    constructor(string memory _name, string memory _symbol, uint8 decimals_) ERC20(_name, _symbol) ERC20Permit(_name) {\r\n        _decimals = decimals_;\r\n    }\r\n\r\n    function decimals() public view override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n\r\n    function mint(address to, uint256 amount) external {\r\n        _mint(to, amount);\r\n    }\r\n\r\n    function burn(address from, uint256 amount) external {\r\n        _burn(from, amount);\r\n    }\r\n}\r\n"
    },
    "contracts/SmardexToken/SmardexToken.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol\";\r\n\r\n/**\r\n * @title SmardexToken (SDEX), ERC-20 token\r\n * @notice Inherit from the ERC20Permit, allowing to sign approve off chain\r\n */\r\ncontract SmardexToken is ERC20Permit {\r\n    constructor(string memory _name, string memory _symbol, uint256 _supply) ERC20(_name, _symbol) ERC20Permit(_name) {\r\n        _mint(msg.sender, _supply);\r\n    }\r\n}\r\n"
    },
    "contracts/SmardexToken/SmardexTokenL2.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\n/**\r\n * @title SmardexToken L2 (SDEX), ERC-20 token\r\n * @notice ERC20 representation of SDEX on L2s\r\n */\r\ncontract SmardexTokenL2 is ERC20 {\r\n    constructor(string memory _name, string memory _symbol) ERC20(_name, _symbol) {}\r\n}\r\n"
    },
    "contracts/SmardexToken/test/SmardexTokenTest.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\r\npragma solidity 0.8.17;\r\n\r\nimport \"../SmardexToken.sol\";\r\n\r\ncontract SmardexTokenTest is SmardexToken {\r\n    constructor(string memory _name, string memory _symbol, uint256 _supply) SmardexToken(_name, _symbol, _supply) {}\r\n\r\n    function mint(address to, uint256 value) external {\r\n        _mint(to, value);\r\n    }\r\n}\r\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}